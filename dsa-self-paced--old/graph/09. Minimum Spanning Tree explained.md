# Minimum Spanning Tree (MST)

## What is a Minimum Spanning Tree?

A **Minimum Spanning Tree** is a subset of edges in a connected, weighted, undirected graph that:

1. **Connects all vertices** together
2. Has **no cycles** (it's a tree)
3. Has the **minimum possible total edge weight**

Think of it like connecting cities with roads where you want to minimize the total construction cost while ensuring every city is reachable.

### Key Properties:

- A graph with V vertices has exactly V-1 edges in its MST
- There can be multiple MSTs if edges have equal weights
- Used in network design, circuit design, clustering, etc.

---

## Example Graph

Let me show you with a simple example:

```
        2
    A ---- B
    |    / |
  6 |  8/  | 5
    |  /   |
    | /    |
    C ---- D
        3
```

**Edges with weights:**

- A-B: 2
- A-C: 6
- B-C: 8
- B-D: 5
- C-D: 3

**MST will include:** A-B (2), C-D (3), B-D (5)
**Total weight:** 2 + 3 + 5 = 10

---

## Two Main Algorithms

### 1. **Kruskal's Algorithm** (Edge-based approach)

- Sort all edges by weight
- Pick smallest edge that doesn't form a cycle
- Use Union-Find to detect cycles

### 2. **Prim's Algorithm** (Vertex-based approach)

- Start from any vertex
- Grow tree by adding minimum weight edge connecting tree to non-tree vertex
- Use priority queue for efficiency

---

## C++ Implementation---

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <climits>
using namespace std;

// ==================== KRUSKAL'S ALGORITHM ====================

// Edge structure for Kruskal's
struct Edge {
    int src, dest, weight;

    // Constructor
    Edge(int s, int d, int w) : src(s), dest(d), weight(w) {}

    // Comparator for sorting edges by weight
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

// Union-Find (Disjoint Set Union) data structure
class UnionFind {
private:
    vector<int> parent, rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        // Initially, each vertex is its own parent
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    // Find with path compression
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    // Union by rank
    bool unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return false; // Already in same set (would form cycle)
        }

        // Union by rank
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
        return true;
    }
};

// Kruskal's Algorithm
void kruskalMST(vector<Edge>& edges, int V) {
    // Step 1: Sort edges by weight
    sort(edges.begin(), edges.end());

    UnionFind uf(V);
    vector<Edge> mst;
    int totalWeight = 0;

    cout << "\n========== KRUSKAL'S ALGORITHM ==========\n";
    cout << "Processing edges in sorted order:\n\n";

    // Step 2: Process each edge
    for (const Edge& edge : edges) {
        cout << "Edge (" << edge.src << "-" << edge.dest
             << ") weight=" << edge.weight;

        // Step 3: Check if adding this edge creates a cycle
        if (uf.unite(edge.src, edge.dest)) {
            mst.push_back(edge);
            totalWeight += edge.weight;
            cout << " -> ADDED to MST\n";
        } else {
            cout << " -> REJECTED (would form cycle)\n";
        }
    }

    // Print MST
    cout << "\n--- MST Edges (Kruskal's) ---\n";
    for (const Edge& edge : mst) {
        cout << edge.src << " - " << edge.dest
             << " : " << edge.weight << "\n";
    }
    cout << "Total MST Weight: " << totalWeight << "\n";
}

// ==================== PRIM'S ALGORITHM ====================

// Edge structure for adjacency list
struct AdjEdge {
    int dest, weight;
    AdjEdge(int d, int w) : dest(d), weight(w) {}
};

// Comparator for priority queue (min-heap)
struct ComparePrim {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second; // Min-heap based on weight
    }
};

// Prim's Algorithm
void primMST(vector<vector<AdjEdge>>& graph, int V) {
    vector<bool> inMST(V, false);
    vector<int> key(V, INT_MAX);  // Minimum weight to connect vertex
    vector<int> parent(V, -1);    // To store MST structure

    // Min-heap: {vertex, weight}
    priority_queue<pair<int, int>, vector<pair<int, int>>, ComparePrim> pq;

    cout << "\n========== PRIM'S ALGORITHM ==========\n";

    // Step 1: Start from vertex 0
    int start = 0;
    key[start] = 0;
    pq.push({start, 0});

    int totalWeight = 0;

    while (!pq.empty()) {
        // Step 2: Extract vertex with minimum key value
        int u = pq.top().first;
        int weight = pq.top().second;
        pq.pop();

        // Skip if already in MST
        if (inMST[u]) continue;

        // Step 3: Add vertex to MST
        inMST[u] = true;
        totalWeight += weight;

        if (parent[u] != -1) {
            cout << "Added edge: " << parent[u] << " - " << u
                 << " (weight=" << weight << ")\n";
        }

        // Step 4: Update keys of adjacent vertices
        for (const AdjEdge& edge : graph[u]) {
            int v = edge.dest;
            int w = edge.weight;

            // If v is not in MST and weight is smaller than current key
            if (!inMST[v] && w < key[v]) {
                key[v] = w;
                parent[v] = u;
                pq.push({v, w});
            }
        }
    }

    // Print MST
    cout << "\n--- MST Edges (Prim's) ---\n";
    for (int i = 1; i < V; i++) {
        if (parent[i] != -1) {
            cout << parent[i] << " - " << i
                 << " : " << key[i] << "\n";
        }
    }
    cout << "Total MST Weight: " << totalWeight << "\n";
}

// ==================== MAIN FUNCTION ====================

int main() {
    int V = 5; // Number of vertices

    cout << "Graph Representation:\n";
    cout << "    2       3\n";
    cout << "0-----1---------2\n";
    cout << "|   / |         |\n";
    cout << "|  /  |         |\n";
    cout << "|4/   |6        |1\n";
    cout << "|/    |         |\n";
    cout << "3-----4---------+\n";
    cout << "   5\n\n";

    // Edge list for Kruskal's
    vector<Edge> edges = {
        Edge(0, 1, 2),
        Edge(0, 3, 6),
        Edge(1, 2, 3),
        Edge(1, 3, 8),
        Edge(1, 4, 5),
        Edge(2, 4, 7),
        Edge(3, 4, 9)
    };

    // Run Kruskal's Algorithm
    kruskalMST(edges, V);

    // Adjacency list for Prim's
    vector<vector<AdjEdge>> graph(V);
    graph[0].push_back(AdjEdge(1, 2));
    graph[0].push_back(AdjEdge(3, 6));
    graph[1].push_back(AdjEdge(0, 2));
    graph[1].push_back(AdjEdge(2, 3));
    graph[1].push_back(AdjEdge(3, 8));
    graph[1].push_back(AdjEdge(4, 5));
    graph[2].push_back(AdjEdge(1, 3));
    graph[2].push_back(AdjEdge(4, 7));
    graph[3].push_back(AdjEdge(0, 6));
    graph[3].push_back(AdjEdge(1, 8));
    graph[3].push_back(AdjEdge(4, 9));
    graph[4].push_back(AdjEdge(1, 5));
    graph[4].push_back(AdjEdge(2, 7));
    graph[4].push_back(AdjEdge(3, 9));

    // Run Prim's Algorithm
    primMST(graph, V);

    return 0;
}
```

## Code Walkthrough

### **Kruskal's Algorithm - How It Works**

#### **Key Data Structure: Union-Find (Disjoint Set Union)**

```cpp
class UnionFind {
    vector<int> parent, rank;
```

**Why Union-Find?**

- We need to quickly check if adding an edge creates a cycle
- Union-Find tracks which vertices are connected
- Two operations: `find()` (which set?) and `unite()` (merge sets)

**Path Compression in `find()`:**

```cpp
if (parent[x] != x) {
    parent[x] = find(parent[x]); // Flatten tree
}
```

- Makes future finds faster (nearly O(1))
- Example: If 0→1→2→3, after finding 3, all point directly to root

**Union by Rank in `unite()`:**

```cpp
if (rank[rootX] < rank[rootY]) {
    parent[rootX] = rootY;
}
```

- Attach smaller tree under larger tree
- Keeps trees balanced, preventing long chains

#### **Kruskal's Main Algorithm:**

**Step 1: Sort edges**

```cpp
sort(edges.begin(), edges.end());
```

- Processes edges from smallest to largest weight
- Ensures we always add the cheapest available edge

**Step 2: Process each edge**

```cpp
if (uf.unite(edge.src, edge.dest)) {
    mst.push_back(edge);
```

- `unite()` returns `true` if vertices were in different sets (no cycle)
- `unite()` returns `false` if already connected (would create cycle)

**Example execution:**

1. Edge (0-1, weight=2): Different sets → ADD
2. Edge (1-2, weight=3): Different sets → ADD
3. Edge (1-4, weight=5): Different sets → ADD
4. Edge (0-3, weight=6): Different sets → ADD
5. Edge (1-3, weight=8): Same set → REJECT (would form cycle)

---

### **Prim's Algorithm - How It Works**

#### **Key Data Structures:**

```cpp
vector<bool> inMST;        // Track which vertices are in MST
vector<int> key;           // Minimum weight to add each vertex
vector<int> parent;        // Track MST edges
priority_queue pq;         // Min-heap of {vertex, weight}
```

**Why Priority Queue?**

- Efficiently get the next closest vertex to add
- Always expands MST with minimum-weight edge

#### **Prim's Main Algorithm:**

**Step 1: Start from vertex 0**

```cpp
key[start] = 0;
pq.push({start, 0});
```

- MST grows from a single starting vertex
- Could start from any vertex

**Step 2: Extract minimum**

```cpp
int u = pq.top().first;
if (inMST[u]) continue;
inMST[u] = true;
```

- Get vertex with minimum connection weight
- Skip if already added (priority queue may have duplicates)

**Step 3: Update neighbors**

```cpp
if (!inMST[v] && w < key[v]) {
    key[v] = w;
    parent[v] = u;
    pq.push({v, w});
}
```

- For each neighbor not in MST, check if we found a cheaper connection
- Update if new edge is lighter than previous best

**Example execution:**

1. Start at vertex 0, key[0]=0
2. Add 0 to MST, update neighbors: key[1]=2, key[3]=6
3. Extract 1 (minimum), add to MST
4. Update neighbors: key[2]=3, key[4]=5
5. Extract 2, add to MST
6. Continue until all vertices added

---

## Time Complexity Comparison

| Algorithm     | Time Complexity | Space    | Best For                  |
| ------------- | --------------- | -------- | ------------------------- |
| **Kruskal's** | O(E log E)      | O(V + E) | Sparse graphs (few edges) |
| **Prim's**    | O(E log V)      | O(V + E) | Dense graphs (many edges) |

**Why the difference?**

- **Kruskal's:** Dominated by edge sorting (E log E)
- **Prim's:** Priority queue operations (E log V), better when E >> V

---

## When to Use Each?

**Use Kruskal's when:**

- Graph is sparse (few edges)
- Edges are already sorted
- Working with edge list representation

**Use Prim's when:**

- Graph is dense (many edges)
- Using adjacency list/matrix
- Want to build MST from specific starting vertex

Both algorithms are **greedy** - they make locally optimal choices (pick minimum weight edge) that lead to a globally optimal solution!

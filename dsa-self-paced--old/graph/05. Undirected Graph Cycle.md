https://www.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1

```cpp
class Solution {
  public:
    bool isCycle(int V, vector<vector<int>>& edges) {
        vector<vector<int>> adj(V,vector<int>());

        for(auto &edge:edges){
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }

        /////////////
        vector<bool> visited(V,false);
        for(int i=0;i<V;i++){
            if(visited[i]) continue;
            if(isCycle(adj,visited,-1,i)) return true;
        }
        return false;
    }
  private:
    bool isCycle(vector<vector<int>> &adj,vector<bool> &visited,int parent,int root){
        if(visited[root]) return false;
        visited[root]=true;

        for(int neighbour:adj[root]){
            if(visited[neighbour]) {
                if(neighbour!=parent) return true;
                continue;
            }
            if(isCycle(adj,visited,root,neighbour)) return true;
        }
        return false;
    }
};
```

```cpp
class Solution {
  public:
    bool isCycle(int V, vector<vector<int>>& edges) {
        vector<vector<int>> adj(V,vector<int>());

        for(auto &edge:edges){
            adj[edge[0]].push_back(edge[1]);
            adj[edge[1]].push_back(edge[0]);
        }

        /////////////
        vector<bool> visited(V,false);
        for(int i=0;i<V;i++){
            if(visited[i]) continue;
            if(isCycle(adj,visited,i)) return true;
        }
        return false;
    }
  private:
    bool isCycle(vector<vector<int>> &adj,vector<bool> &visited,int root){
        if(visited[root]) return false;
        queue<int> nodes;
        nodes.push(root);
        visited[root]=true;
        vector<int> parent(adj.size(),-1);
        while(!nodes.empty()){
            int sz=nodes.size();
            while(sz--){
                int node=nodes.front();
                nodes.pop();

                for(int neighbour:adj[node]){
                    if(visited[neighbour]){
                        if(neighbour!=parent[node]) return true;
                        continue;
                    }
                    visited[neighbour]=true;
                    parent[neighbour]=node;
                    nodes.push(neighbour);
                }
            }
        }
        return false;
    }
};
```

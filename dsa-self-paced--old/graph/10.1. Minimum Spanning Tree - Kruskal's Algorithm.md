https://www.geeksforgeeks.org/problems/minimum-spanning-tree-kruskals-algorithm/1
https://www.geeksforgeeks.org/dsa/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/

```cpp

class DisjointSet{
    private:
        vector<int> rank;
        vector<int> parent;
    public:
        DisjointSet(int n){
            rank.resize(n,0);
            parent.resize(n);

            // Initially, each element is representative of its own set
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        int find(int x){
            if(parent[x]==x) return x;
            //compression of nodes
            return (parent[x]=find(parent[x]));
        }
        void unite(int x,int y){
            int px=find(x);
            int py=find(y);
            if(px==py) return;

            //compression by rank
            if(rank[px]<rank[py]){
                parent[px]=py;
            }else if(rank[px]>rank[py]){
                parent[py]=px;
            }else{
                parent[px]=py;
                rank[px]++;
            }
        }
};
class WeighAscCmp{
    public:
        bool operator()(const vector<int> &edgex,const vector<int> &edgey) const{
            return edgex[2] < edgey[2];
        }
};

class Solution {
  public:
    int kruskalsMST(int V, vector<vector<int>> &edges) {
        sort(edges.begin(),edges.end(),WeighAscCmp());
        DisjointSet ds(V);

        int pickCount=0;
        int mstW=0;
        for(auto edge:edges){
            int u=edge[0];
            int v=edge[1];
            int w=edge[2];

            int px=ds.find(u);
            int py=ds.find(v);
            if(px==py) continue;
            pickCount++;
            ds.unite(px,py);
            mstW+=w;
            if(pickCount==V-1) break;
        }
        return mstW;
    }
};
```

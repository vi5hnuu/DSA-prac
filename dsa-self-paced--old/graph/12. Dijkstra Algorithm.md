https://www.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1

```cpp
// User Function Template
class Solution {
  public:
    vector<int> dijkstra(int V, vector<vector<int>> &edges, int src) {
        vector<vector<int>> adj(V,vector<int>(V,0));

        for(auto &edge:edges){
            int u=edge[0];
            int v=edge[1];
            int w=edge[2];
            adj[u][v]=w;
            adj[v][u]=w;
        }

        vector<bool> visited(V,false);
        vector<int> distance(V,INT_MAX);//distance of nodes from src to...
        distance[src]=0;

        for(int i=0;i<V;i++){
            int minWeightVertext=-1;
            for(int i=0;i<V;i++){//select min weight vertex from source
                if(visited[i]) continue;
                if(minWeightVertext==-1 || distance[i]<distance[minWeightVertext]) minWeightVertext=i;
            }

            visited[minWeightVertext]=true;

            //relax neighbours
            for(int i=0;i<V;i++){
                if(visited[i] || !adj[minWeightVertext][i]) continue;
                distance[i]=min(distance[i],distance[minWeightVertext]+adj[minWeightVertext][i]);
            }
        }
        return distance;
    }
};
```

```cpp
class MinComparator{
public:  // Also add public!
    bool operator()(const pair<int,int> &p, const pair<int,int> &q) const {
        return p.second > q.second;
    }
};
// User Function Template
class Solution {
  public:
    vector<int> dijkstra(int V, vector<vector<int>> &edges, int src) {
        vector<vector<pair<int,int>>> adj(V,vector<pair<int,int>>());

        for(auto &edge:edges){
            int u=edge[0];
            int v=edge[1];
            int w=edge[2];
            adj[u].push_back({v,w});
            adj[v].push_back({u,w});
        }

        vector<bool> visited(V,false);
        vector<int> distance(V,INT_MAX);//distance of nodes from src to...
        distance[src]=0;

        priority_queue<pair<int,int>,vector<pair<int,int>>,MinComparator> pq;
        pq.push({src,0});

        while(!pq.empty()){
            auto mVertex=pq.top();
            pq.pop();

            if(visited[mVertex.first]) continue;
            visited[mVertex.first]=true;

            //relax neighbours
            for(auto &neighbour : adj[mVertex.first]) {
                if(visited[neighbour.first]) continue;

                int newDist = distance[mVertex.first] + neighbour.second;
                if(newDist < distance[neighbour.first]) {
                    distance[neighbour.first] = newDist;
                    pq.push({neighbour.first, newDist});  // Push with distance!
                }
            }
        }
        return distance;
    }
};
```

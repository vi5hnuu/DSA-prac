https://www.geeksforgeeks.org/problems/connected-components-in-an-undirected-graph/1

```cpp
class Solution {
  public:
    vector<vector<int>> getComponents(int V, vector<vector<int>>& edges) {
        map<int,vector<int>> *adjL=buildAdj(edges);

        vector<bool> visited(V,false);

        vector<vector<int>> components;
        for(int i=0;i<V;i++){
            if(visited[i]) continue;
            vector<int> component;
            dfs(adjL,visited,component,i);
            components.push_back(component);
        }
        delete adjL;
        return components;
    }
  private:
    map<int,vector<int>>* buildAdj(vector<vector<int>>& edges){
        map<int,vector<int>> *adjL=new map<int,vector<int>> ;

        for(auto &edge:edges){
            (*adjL)[edge[0]].push_back(edge[1]);
            (*adjL)[edge[1]].push_back(edge[0]);
        }
        return adjL;
    }
    void dfs(map<int,vector<int>> *adjL,vector<bool> &visited,vector<int> &component,int root){
        if(visited[root]) return;
        visited[root]=true;
        component.push_back(root);
        for(int neighbour:(*adjL)[root]){
            if(!visited[neighbour]) dfs(adjL,visited,component,neighbour);
        }
    }
};
```

```cpp
class Solution {
  public:
    vector<vector<int>> getComponents(int V, vector<vector<int>>& edges) {
        map<int,vector<int>> *adjL=buildAdj(edges);

        vector<bool> visited(V,false);

        vector<vector<int>> components;
        for(int i=0;i<V;i++){
            if(visited[i]) continue;
            vector<int> component;
            dfs(adjL,visited,component,i);
            components.push_back(component);
        }
        delete adjL;
        return components;
    }
  private:
    map<int,vector<int>>* buildAdj(vector<vector<int>>& edges){
        map<int,vector<int>> *adjL=new map<int,vector<int>> ;

        for(auto &edge:edges){
            (*adjL)[edge[0]].push_back(edge[1]);
            (*adjL)[edge[1]].push_back(edge[0]);
        }
        return adjL;
    }
    void dfs(map<int,vector<int>> *adjL,vector<bool> &visited,vector<int> &component,int root){
        stack<int> stck;
        stck.push(root);

        while(!stck.empty()){
            int node=stck.top();
            stck.pop();
            if(visited[node]) continue;
            visited[node]=true;
            component.push_back(node);
            for(int neighbour:(*adjL)[node]){
                if(!visited[neighbour]) stck.push(neighbour);
            }
        }
    }
};
```

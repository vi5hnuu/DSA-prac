https://www.geeksforgeeks.org/problems/bridge-edge-in-graph/1

```cpp
class Solution {
  public:
    bool isBridge(int v, vector<vector<int>> &edges, int c, int d) {
        map<int,vector<int>> adjList=createAdjList(edges);
        vector<bool> visited=vector<bool>(v,false);
        vector<int> discoveryTime=vector<int>(v,-1);
        vector<int> lowestReachTime=vector<int>(v,-1);
        int parent=-1;
        int timer=0;
        vector<pair<int,int>> bridges;
        for(int i=0;i<v;i++){
            if(!visited[i]) tarjansAlgo(adjList,visited,discoveryTime,lowestReachTime,bridges,parent,i,timer);
        }

        for(const auto bridge:bridges){
            if((bridge.first==c && bridge.second==d) || (bridge.second==c && bridge.first==d)) return true;
        }
        return false;;
    }
  private:
    void tarjansAlgo(map<int,vector<int>> &adjList,
                    vector<bool> &visited,
                    vector<int> &discoveryTime,
                    vector<int> &lowestReachTime,
                    vector<pair<int,int>> &bridges,int parent,int node,int &timer){
        if(visited[node]) return;
        visited[node]=true;
        discoveryTime[node] = lowestReachTime[node] = timer++;
        for(const auto &neighbour:adjList[node]){
            if(neighbour==parent) continue;
            if(visited[neighbour]){//backedge [cannot be bridge]
                lowestReachTime[node]=min(lowestReachTime[node],discoveryTime[neighbour]);

            }else{
                tarjansAlgo(adjList,visited,discoveryTime,lowestReachTime,bridges,node,neighbour,timer);
                lowestReachTime[node]=min(lowestReachTime[node],lowestReachTime[neighbour]);

                //check if it is a bridge
                if(lowestReachTime[neighbour]>discoveryTime[node]){//is bridge
                    bridges.push_back(make_pair(node,neighbour));
                }
            }
        }
    }
    map<int,vector<int>> createAdjList(vector<vector<int>> &edges){
        map<int,vector<int>> adjList;

        for(const auto&edge:edges){
            adjList[edge[0]].push_back(edge[1]);
            adjList[edge[1]].push_back(edge[0]);
        }
        return adjList;
    }
};
```

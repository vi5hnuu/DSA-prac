https://www.geeksforgeeks.org/dsa/maximise-number-of-cuts-in-a-rod-if-it-can-be-cut-only-in-given-3-sizes/

```cpp
 #include<bits/stdc++.h>
 using namespace std;

class Solution {
  public:
    int cuttingRod(int rope, int c1,int c2,int c3) {
      if (rope == 0) return 0;  // No cuts needed for rope of length 0

       if(rope<0){
            return INT_MIN;
        }

        int c1Cuts=cuttingRod(rope-c1,c1,c2,c3);
        int c2Cuts=cuttingRod(rope-c2,c1,c2,c3);
        int c3Cuts=cuttingRod(rope-c3,c1,c2,c3);
        int maxCuts=max(c1Cuts,max(c2Cuts,c3Cuts));
        if(maxCuts<0){
            return INT_MIN;
        }
        return maxCuts+1;
    }
};

 int main(){
    Solution s1;
    cout<<s1.cuttingRod(5,2,5,1)<<endl;
    cout<<s1.cuttingRod(5,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,4)<<endl;
    cout<<s1.cuttingRod(10,2,5,6)<<endl;
    cout<<s1.cuttingRod(10,2,5,8)<<endl;
    cout<<s1.cuttingRod(10,2,5,9)<<endl;
  }
```

### OR

```cpp
 #include<bits/stdc++.h>
 using namespace std;

class Solution {
  public:
    int cuttingRod(int rope, int c1,int c2,int c3) {
      map<int,int> ropeMaxCuts;
      return cuttingRod(ropeMaxCuts,rope,c1,c2,c3);
    }
  private:
    int cuttingRod(map<int,int> &ropeMaxCuts,int rope, int c1,int c2,int c3) {
      if (rope == 0) return 0;  // No cuts needed for rope of length 0

       if(rope<0){
            return INT_MIN;
        }
        auto cache=ropeMaxCuts.find(rope);
        if(cache!=ropeMaxCuts.end()) return ropeMaxCuts[rope];

        int c1Cuts=cuttingRod(rope-c1,c1,c2,c3);
        int c2Cuts=cuttingRod(rope-c2,c1,c2,c3);
        int c3Cuts=cuttingRod(rope-c3,c1,c2,c3);
        int maxCuts=max(c1Cuts,max(c2Cuts,c3Cuts));
        if(maxCuts<0){
          return ropeMaxCuts[rope]=INT_MIN;
        }
        return ropeMaxCuts[rope]=maxCuts+1;
    }
};

 int main(){
    Solution s1;
    cout<<s1.cuttingRod(5,2,5,1)<<endl;
    cout<<s1.cuttingRod(5,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,4)<<endl;
    cout<<s1.cuttingRod(10,2,5,6)<<endl;
    cout<<s1.cuttingRod(10,2,5,8)<<endl;
    cout<<s1.cuttingRod(10,2,5,9)<<endl;
  }
```

```cpp
 #include<bits/stdc++.h>
 using namespace std;

class Solution {
  public:
    int cuttingRod(int rope, int c1,int c2,int c3) {
      vector<int> ropeMaxCuts(rope + 1, INT_MIN);
      ropeMaxCuts[0] = 0; // No cuts needed for rope of length 0
      for(int ropeLength=1;ropeLength<=rope;ropeLength++){
        if(ropeLength-c1>=0 && ropeMaxCuts[ropeLength-c1]!=INT_MIN){
            ropeMaxCuts[ropeLength]=max(ropeMaxCuts[ropeLength],ropeMaxCuts[ropeLength-c1]+1);
        }
        if(ropeLength-c2>=0 && ropeMaxCuts[ropeLength-c2]!=INT_MIN){
            ropeMaxCuts[ropeLength]=max(ropeMaxCuts[ropeLength],ropeMaxCuts[ropeLength-c2]+1);
        }
        if(ropeLength-c3>=0 && ropeMaxCuts[ropeLength-c3]!=INT_MIN){
            ropeMaxCuts[ropeLength]=max(ropeMaxCuts[ropeLength],ropeMaxCuts[ropeLength-c3]+1);
        }
      }
      if(ropeMaxCuts[rope]<0) return 0;
      return ropeMaxCuts[rope];
    }
};

 int main(){
    Solution s1;
    cout<<s1.cuttingRod(5,2,5,1)<<endl;
    cout<<s1.cuttingRod(5,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,3)<<endl;
    cout<<s1.cuttingRod(10,2,5,4)<<endl;
    cout<<s1.cuttingRod(10,2,5,6)<<endl;
    cout<<s1.cuttingRod(10,2,5,8)<<endl;
    cout<<s1.cuttingRod(10,2,5,9)<<endl;
  }
```

# Analyzing the Rod Cutting Solution

---

## **Part 1: Understanding the Problem**

**Problem:** Given a rod of length N and three allowed cut sizes (A, B, C), maximize the number of cuts such that the rod is completely used.

**Example:**

- Rod length = 5
- Cuts allowed = {2, 5, 1}
- Best solution: 5 cuts of size 1 each â†’ Total = 5

---

### **Correct Approach 1: Without Cuts Parameter**

```cpp
class Solution {
public:
    int cuttingRod(int rope, int c1, int c2, int c3) {
        // Base cases
        if (rope == 0) return 0;  // No cuts needed for rope of length 0
        if (rope < 0) return INT_MIN;  // Invalid configuration

        // Try all three cuts
        int cut1 = cuttingRod(rope - c1, c1, c2, c3);
        int cut2 = cuttingRod(rope - c2, c1, c2, c3);
        int cut3 = cuttingRod(rope - c3, c1, c2, c3);

        // Take the best valid option and add 1 for current cut
        int maxCuts = max({cut1, cut2, cut3});

        // If all paths are invalid, return invalid
        if (maxCuts < 0) return INT_MIN;

        return maxCuts + 1;
    }
};
```

### **Why This Works:**

1. **Base case `rope == 0`:** Return 0 (no more cuts needed)
2. **Base case `rope < 0`:** Return `INT_MIN` (invalid, not just -1)
3. **Recursive case:** Try all cuts, take max, add 1 for current cut
4. **Invalid check:** If all paths return `INT_MIN`, this path is also invalid

### **Trace Example: `cuttingRod(5, 2, 5, 1)`**

```
cuttingRod(5)
â”œâ”€ cuttingRod(3)  // 5-2
â”‚  â”œâ”€ cuttingRod(1)  // 3-2
â”‚  â”‚  â”œâ”€ cuttingRod(-1) â†’ INT_MIN
â”‚  â”‚  â”œâ”€ cuttingRod(-4) â†’ INT_MIN
â”‚  â”‚  â””â”€ cuttingRod(0) â†’ 0
â”‚  â”‚  max(INT_MIN, INT_MIN, 0) = 0
â”‚  â”‚  return 0 + 1 = 1
â”‚  â”œâ”€ cuttingRod(-2) â†’ INT_MIN
â”‚  â””â”€ cuttingRod(2)  // 3-1
â”‚     â”œâ”€ cuttingRod(0) â†’ 0, return 1
â”‚     â”œâ”€ cuttingRod(-3) â†’ INT_MIN
â”‚     â””â”€ cuttingRod(1)
â”‚        â””â”€ returns 1
â”‚     max(1, INT_MIN, 1) = 1, return 2
â”‚  max(1, INT_MIN, 2) = 2
â”‚  return 2 + 1 = 3
â”œâ”€ cuttingRod(0) â†’ 0, return 1
â””â”€ cuttingRod(4)  // 5-1
   â””â”€ ... similar recursion ... returns 4

max(3, 1, 4) = 4
return 4 + 1 = 5 âœ“
```

---

## **Part 5: Optimized Solution with Memoization**

```cpp
class Solution {
public:
    int cuttingRod(int rope, int c1, int c2, int c3) {
        vector<int> dp(rope + 1, -2);  // -2 means not computed
        int result = solve(rope, c1, c2, c3, dp);
        return result < 0 ? -1 : result;
    }

private:
    int solve(int rope, int c1, int c2, int c3, vector<int>& dp) {
        // Base cases
        if (rope == 0) return 0;
        if (rope < 0) return INT_MIN;

        // Check if already computed
        if (dp[rope] != -2) return dp[rope];

        // Try all three cuts
        int cut1 = solve(rope - c1, c1, c2, c3, dp);
        int cut2 = solve(rope - c2, c1, c2, c3, dp);
        int cut3 = solve(rope - c3, c1, c2, c3, dp);

        // Take the best valid option
        int maxCuts = max({cut1, cut2, cut3});

        // Store result
        if (maxCuts < 0) {
            dp[rope] = INT_MIN;
        } else {
            dp[rope] = maxCuts + 1;
        }

        return dp[rope];
    }
};
```

**Time Complexity:** O(n) where n is rope length
**Space Complexity:** O(n)

---

## **Part 6: Bottom-Up DP Solution (Most Efficient)**

```cpp
class Solution {
public:
    int cuttingRod(int n, int a, int b, int c) {
        vector<int> dp(n + 1, INT_MIN);
        dp[0] = 0;  // Base case: 0 length needs 0 cuts

        for (int i = 1; i <= n; i++) {
            // Try cut of size a
            if (i >= a && dp[i - a] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - a] + 1);
            }

            // Try cut of size b
            if (i >= b && dp[i - b] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - b] + 1);
            }

            // Try cut of size c
            if (i >= c && dp[i - c] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - c] + 1);
            }
        }

        return dp[n] < 0 ? -1 : dp[n];
    }
};
```

### **Trace Example: `cuttingRod(5, 2, 5, 1)`**

```
dp[0] = 0

i = 1:
  Can cut size 1: dp[1] = dp[0] + 1 = 1
  dp = [0, 1, INT_MIN, INT_MIN, INT_MIN, INT_MIN]

i = 2:
  Can cut size 2: dp[2] = dp[0] + 1 = 1
  Can cut size 1: dp[2] = max(1, dp[1] + 1) = 2
  dp = [0, 1, 2, INT_MIN, INT_MIN, INT_MIN]

i = 3:
  Can cut size 2: dp[3] = dp[1] + 1 = 2
  Can cut size 1: dp[3] = max(2, dp[2] + 1) = 3
  dp = [0, 1, 2, 3, INT_MIN, INT_MIN]

i = 4:
  Can cut size 2: dp[4] = dp[2] + 1 = 3
  Can cut size 1: dp[4] = max(3, dp[3] + 1) = 4
  dp = [0, 1, 2, 3, 4, INT_MIN]

i = 5:
  Can cut size 2: dp[5] = dp[3] + 1 = 4
  Can cut size 5: dp[5] = max(4, dp[0] + 1) = 4
  Can cut size 1: dp[5] = max(4, dp[4] + 1) = 5
  dp = [0, 1, 2, 3, 4, 5]

Answer: dp[5] = 5 âœ“
```

---

## **Part 7: Complete Test Suite**

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int cuttingRod(int n, int a, int b, int c) {
        vector<int> dp(n + 1, INT_MIN);
        dp[0] = 0;

        for (int i = 1; i <= n; i++) {
            if (i >= a && dp[i - a] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - a] + 1);
            }
            if (i >= b && dp[i - b] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - b] + 1);
            }
            if (i >= c && dp[i - c] != INT_MIN) {
                dp[i] = max(dp[i], dp[i - c] + 1);
            }
        }

        return dp[n] < 0 ? -1 : dp[n];
    }
};

int main() {
    Solution s1;

    cout << "Test 1: " << s1.cuttingRod(5, 2, 5, 1) << " (Expected: 5)\n";
    cout << "Test 2: " << s1.cuttingRod(5, 2, 5, 3) << " (Expected: 2)\n";
    cout << "Test 3: " << s1.cuttingRod(10, 2, 5, 3) << " (Expected: 5)\n";
    cout << "Test 4: " << s1.cuttingRod(10, 2, 5, 4) << " (Expected: 5)\n";
    cout << "Test 5: " << s1.cuttingRod(10, 2, 5, 6) << " (Expected: 5)\n";
    cout << "Test 6: " << s1.cuttingRod(10, 2, 5, 8) << " (Expected: 5)\n";
    cout << "Test 7: " << s1.cuttingRod(10, 2, 5, 9) << " (Expected: 5)\n";
    cout << "Test 8: " << s1.cuttingRod(7, 3, 5, 2) << " (Expected: -1)\n";

    return 0;
}
```

**Expected Output:**

```
Test 1: 5 (Expected: 5) âœ“
Test 2: 2 (Expected: 2) âœ“
Test 3: 5 (Expected: 5) âœ“
Test 4: 5 (Expected: 5) âœ“
Test 5: 5 (Expected: 5) âœ“
Test 6: 5 (Expected: 5) âœ“
Test 7: 5 (Expected: 5) âœ“
Test 8: -1 (Expected: -1) âœ“
```

---

**Recommendation:** Use the bottom-up DP solution I provided for correctness and efficiency! ðŸŽ¯

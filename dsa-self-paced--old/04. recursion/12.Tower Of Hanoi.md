https://www.geeksforgeeks.org/problems/tower-of-hanoi-1587115621/1

```cpp
class Solution {
  public:
    int towerOfHanoi(int n, int from, int to, int aux) {
        return (1<<n)-1;
    }
};
```

```cpp
class Solution {
  public:
    int towerOfHanoi(int n, int from, int to, int aux) {
        if(n==1) return 1;
        int movesAB=towerOfHanoi(n-1,from,aux,to);
        int movesAC=towerOfHanoi(n-1,aux,to,from);
        return movesAB+movesAC+1;
    }
};
```

# Tower of Hanoi - Complete Guide from Naive to Optimized

Let me take you through this classic problem step by step!

---

## **Part 1: Understanding the Problem**

### **The Setup:**

You have:

- **3 pegs (rods):** Source (A), Auxiliary (B), Destination (C)
- **N disks** of different sizes stacked on Source peg
- Disks are arranged in ascending order (smallest on top)

**Goal:** Move all disks from Source to Destination

### **Rules:**

1. ✅ Only **one disk** can be moved at a time
2. ✅ Only the **top disk** from any peg can be moved
3. ✅ A **larger disk cannot be placed on a smaller disk**

### **Visual Example (3 disks):**

```
Initial State:           Goal State:

    |                        |
   [1]                       |
  [2 2]                      |
 [3 3 3]                     |
---------               ---------
    A                        C

Source (A)              Destination (C)
```

---

## **Part 2: Building Intuition - Manual Solution for 3 Disks**

Let's solve it manually first to understand the pattern:

```
Step 0: Initial
    |           |           |
   [1]          |           |
  [2 2]         |           |
 [3 3 3]        |           |
---------   ---------   ---------
    A           B           C

Step 1: Move disk 1 from A to C
    |           |           |
    |           |          [1]
  [2 2]         |           |
 [3 3 3]        |           |
---------   ---------   ---------
    A           B           C

Step 2: Move disk 2 from A to B
    |           |           |
    |           |          [1]
    |         [2 2]         |
 [3 3 3]        |           |
---------   ---------   ---------
    A           B           C

Step 3: Move disk 1 from C to B
    |           |           |
    |          [1]          |
    |         [2 2]         |
 [3 3 3]        |           |
---------   ---------   ---------
    A           B           C

Step 4: Move disk 3 from A to C
    |           |           |
    |          [1]          |
    |         [2 2]         |
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C

Step 5: Move disk 1 from B to A
    |           |           |
   [1]          |           |
    |         [2 2]         |
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C

Step 6: Move disk 2 from B to C
    |           |           |
   [1]          |           |
    |           |         [2 2]
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C

Step 7: Move disk 1 from A to C (DONE!)
    |           |           |
    |           |          [1]
    |           |         [2 2]
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C
```

**Total moves: 7 = 2³ - 1**

---

## **Part 3: Discovering the Recursive Pattern**

### **Key Insight:**

To move N disks from A to C using B:

1. **Move (N-1) disks** from A to B (using C as auxiliary)
2. **Move the largest disk** from A to C
3. **Move (N-1) disks** from B to C (using A as auxiliary)

### **Why This Works:**

- To move the largest disk to C, all smaller disks must be out of the way
- We can temporarily store them on B
- Then move them back on top of the largest disk on C

### **Visual Breakdown for N=3:**

```
Goal: Move 3 disks from A → C

Step 1: Move 2 disks from A → B (using C)
    |           |           |
    |          [1]          |
    |         [2 2]         |
 [3 3 3]        |           |
---------   ---------   ---------
    A           B           C

Step 2: Move disk 3 from A → C
    |           |           |
    |          [1]          |
    |         [2 2]         |
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C

Step 3: Move 2 disks from B → C (using A)
    |           |           |
    |           |          [1]
    |           |         [2 2]
    |           |        [3 3 3]
---------   ---------   ---------
    A           B           C
```

---

## **Part 4: The Recursive Solution (Standard)**

### **Code:**

```cpp
#include <iostream>
using namespace std;

class TowerOfHanoi {
public:
    int moveCount = 0;

    void solve(int n, char source, char destination, char auxiliary) {
        // Base case: Only one disk
        if (n == 1) {
            cout << "Move disk 1 from " << source << " to " << destination << endl;
            moveCount++;
            return;
        }

        // Step 1: Move (n-1) disks from source to auxiliary using destination
        solve(n - 1, source, auxiliary, destination);

        // Step 2: Move the largest disk from source to destination
        cout << "Move disk " << n << " from " << source << " to " << destination << endl;
        moveCount++;

        // Step 3: Move (n-1) disks from auxiliary to destination using source
        solve(n - 1, auxiliary, destination, source);
    }

    void towersOfHanoi(int n) {
        moveCount = 0;
        solve(n, 'A', 'C', 'B');
        cout << "\nTotal moves: " << moveCount << endl;
    }
};

int main() {
    TowerOfHanoi toh;
    toh.towersOfHanoi(3);
    return 0;
}
```

### **Output for N=3:**

```
Move disk 1 from A to C
Move disk 2 from A to B
Move disk 1 from C to B
Move disk 3 from A to C
Move disk 1 from B to A
Move disk 2 from B to C
Move disk 1 from A to C

Total moves: 7
```

---

## **Part 5: Detailed Recursion Tree for N=3**

```
solve(3, A, C, B)
│
├─ solve(2, A, B, C)  ← Move 2 disks from A to B
│  │
│  ├─ solve(1, A, C, B)  ← Move 1 disk from A to C
│  │  └─ Print: "Move disk 1 from A to C"
│  │
│  ├─ Print: "Move disk 2 from A to B"  ← Move disk 2
│  │
│  └─ solve(1, C, B, A)  ← Move 1 disk from C to B
│     └─ Print: "Move disk 1 from C to B"
│
├─ Print: "Move disk 3 from A to C"  ← Move disk 3
│
└─ solve(2, B, C, A)  ← Move 2 disks from B to C
   │
   ├─ solve(1, B, A, C)  ← Move 1 disk from B to A
   │  └─ Print: "Move disk 1 from B to A"
   │
   ├─ Print: "Move disk 2 from B to C"  ← Move disk 2
   │
   └─ solve(1, A, C, B)  ← Move 1 disk from A to C
      └─ Print: "Move disk 1 from A to C"
```

### **Call Stack at Deepest Point:**

```
[solve(3, A, C, B)]
  [solve(2, A, B, C)]
    [solve(1, A, C, B)] ← Deepest recursion
```

**Maximum recursion depth:** O(N)

---

## **Part 6: Tracing for N=4 (First Few Steps)**

```
solve(4, A, C, B)
│
├─ solve(3, A, B, C)  ← Move 3 disks A→B (7 moves)
│  │
│  ├─ solve(2, A, C, B)  ← Move 2 disks A→C (3 moves)
│  │  ├─ solve(1, A, B, C): Print "Move disk 1 from A to B"
│  │  ├─ Print "Move disk 2 from A to C"
│  │  └─ solve(1, B, C, A): Print "Move disk 1 from B to C"
│  │
│  ├─ Print "Move disk 3 from A to B"
│  │
│  └─ solve(2, C, B, A)  ← Move 2 disks C→B (3 moves)
│     └─ ... (3 more moves)
│
├─ Print "Move disk 4 from A to C"  ← The big one!
│
└─ solve(3, B, C, A)  ← Move 3 disks B→C (7 moves)
   └─ ... (7 more moves)

Total: 7 + 1 + 7 = 15 moves
```

---

## **Part 7: Mathematical Analysis**

### **Recurrence Relation:**

```
T(n) = 2 × T(n-1) + 1

Where:
T(n) = number of moves to solve n disks
T(1) = 1 (base case)
```

**Derivation:**

- T(n-1) moves to transfer (n-1) disks from A to B
- 1 move to transfer the largest disk from A to C
- T(n-1) moves to transfer (n-1) disks from B to C

### **Solving the Recurrence:**

```
T(1) = 1
T(2) = 2×T(1) + 1 = 2×1 + 1 = 3
T(3) = 2×T(2) + 1 = 2×3 + 1 = 7
T(4) = 2×T(3) + 1 = 2×7 + 1 = 15
T(5) = 2×T(4) + 1 = 2×15 + 1 = 31

Pattern: T(n) = 2^n - 1
```

### **Proof by Induction:**

**Base case:** T(1) = 2¹ - 1 = 1 ✓

**Inductive step:**
Assume T(k) = 2^k - 1

```
T(k+1) = 2 × T(k) + 1
       = 2 × (2^k - 1) + 1
       = 2^(k+1) - 2 + 1
       = 2^(k+1) - 1 ✓
```

**Therefore: T(n) = 2^n - 1**

---

## **Part 8: Complexity Analysis**

### **Time Complexity:**

**O(2^n)**

For each disk, we make 2 recursive calls.

```
Tree structure:
                solve(n)
              /          \
        solve(n-1)      solve(n-1)
        /      \        /      \
    solve(n-2) ...  solve(n-2) ...

Total nodes = 2^n - 1
```

### **Space Complexity:**

**O(n)** - Recursion stack depth

Maximum depth of recursion = n

---

## **Part 9: Iterative Solution (Non-Recursive)**

### **Key Observations:**

1. For odd N: First move is always to destination
2. For even N: First move is always to auxiliary
3. After that, follow a cyclic pattern

### **Algorithm:**

```cpp
class TowerOfHanoiIterative {
public:
    void solve(int n) {
        char pegs[] = {'A', 'B', 'C'};
        int totalMoves = (1 << n) - 1;  // 2^n - 1

        // For odd n, swap auxiliary and destination
        if (n % 2 == 0) {
            swap(pegs[1], pegs[2]);
        }

        for (int move = 1; move <= totalMoves; move++) {
            // Calculate which peg to move from and to
            if (move % 3 == 1) {
                moveBetween(pegs[0], pegs[2], move);
            } else if (move % 3 == 2) {
                moveBetween(pegs[0], pegs[1], move);
            } else {
                moveBetween(pegs[1], pegs[2], move);
            }
        }
    }

private:
    void moveBetween(char from, char to, int moveNum) {
        cout << "Move " << moveNum << ": " << from << " → " << to << endl;
    }
};
```

**Note:** This is a simplified version. A complete iterative solution needs to track disk positions.

---

## **Part 10: Optimized Recursive with Memoization (For Variants)**

For the standard Tower of Hanoi, memoization doesn't help since we never solve the same subproblem twice. However, for variants (like counting solutions), it can be useful.

```cpp
class TowerOfHanoiMemo {
private:
    unordered_map<string, long long> memo;

    string makeKey(int n, char src, char dst, char aux) {
        return to_string(n) + src + dst + aux;
    }

public:
    long long countMoves(int n, char src = 'A', char dst = 'C', char aux = 'B') {
        if (n == 0) return 0;
        if (n == 1) return 1;

        string key = makeKey(n, src, dst, aux);
        if (memo.find(key) != memo.end()) {
            return memo[key];
        }

        long long moves =
            countMoves(n - 1, src, aux, dst) +  // Move n-1 to aux
            1 +                                   // Move largest
            countMoves(n - 1, aux, dst, src);    // Move n-1 to dst

        memo[key] = moves;
        return moves;
    }
};
```

---

## **Part 11: Complete Solution with State Tracking**

```cpp
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

class TowerOfHanoiComplete {
private:
    vector<stack<int>> pegs;
    int moveCount;

    void printState() {
        cout << "\nCurrent State:\n";
        for (int i = 0; i < 3; i++) {
            cout << "Peg " << char('A' + i) << ": ";
            stack<int> temp = pegs[i];
            vector<int> disks;
            while (!temp.empty()) {
                disks.push_back(temp.top());
                temp.pop();
            }
            for (int j = disks.size() - 1; j >= 0; j--) {
                cout << disks[j] << " ";
            }
            cout << endl;
        }
        cout << "-------------------\n";
    }

    void moveDisk(int from, int to) {
        if (pegs[from].empty()) {
            cout << "Error: No disk on peg " << char('A' + from) << endl;
            return;
        }

        int disk = pegs[from].top();
        pegs[from].pop();
        pegs[to].push(disk);

        moveCount++;
        cout << "Move " << moveCount << ": ";
        cout << "Disk " << disk << " from " << char('A' + from);
        cout << " to " << char('A' + to) << endl;

        printState();
    }

    void solve(int n, int source, int destination, int auxiliary) {
        if (n == 1) {
            moveDisk(source, destination);
            return;
        }

        solve(n - 1, source, auxiliary, destination);
        moveDisk(source, destination);
        solve(n - 1, auxiliary, destination, source);
    }

public:
    TowerOfHanoiComplete(int n) : pegs(3), moveCount(0) {
        // Initialize source peg with n disks
        for (int i = n; i >= 1; i--) {
            pegs[0].push(i);
        }
    }

    void solve(int n) {
        cout << "Initial State:";
        printState();
        solve(n, 0, 2, 1);  // 0=A, 1=B, 2=C
        cout << "\nTotal moves: " << moveCount << endl;
        cout << "Formula verification: 2^" << n << " - 1 = ";
        cout << ((1 << n) - 1) << endl;
    }
};

int main() {
    int n = 3;
    cout << "Tower of Hanoi for " << n << " disks:\n";
    cout << "========================================\n";

    TowerOfHanoiComplete toh(n);
    toh.solve(n);

    return 0;
}
```

### **Output for N=3:**

```
Tower of Hanoi for 3 disks:
========================================
Initial State:

Current State:
Peg A: 3 2 1
Peg B:
Peg C:
-------------------
Move 1: Disk 1 from A to C

Current State:
Peg A: 3 2
Peg B:
Peg C: 1
-------------------
Move 2: Disk 2 from A to B

Current State:
Peg A: 3
Peg B: 2
Peg C: 1
-------------------
... (continues)

Total moves: 7
Formula verification: 2^3 - 1 = 7
```

---

## **Part 12: Variants and Extensions**

### **Variant 1: 4 Pegs (Reve's Puzzle)**

With 4 pegs, the optimal number of moves is less than 2^n - 1.

**Formula:** T(n) ≈ O(2^(√(2n)))

### **Variant 2: Restricted Moves**

Only allow moves from A→B, B→C, C→A (cyclic).

### **Variant 3: Bi-directional Hanoi**

Move disks from both ends simultaneously.

---

## **Part 13: Performance Table**

| N Disks | Moves (2^n - 1) | Time at 1 move/sec | Recursion Depth |
| ------- | --------------- | ------------------ | --------------- |
| 1       | 1               | 1 second           | 1               |
| 3       | 7               | 7 seconds          | 3               |
| 5       | 31              | 31 seconds         | 5               |
| 10      | 1,023           | ~17 minutes        | 10              |
| 20      | 1,048,575       | ~12 days           | 20              |
| 30      | 1,073,741,823   | ~34 years          | 30              |
| 64      | 2^64 - 1        | ~585 billion years | 64              |

**Legend says:** 64 golden disks moved by monks → end of the world! 🌍

---

## **Part 14: Common Interview Questions**

### **Q1: Print only the number of moves**

```cpp
long long countMoves(int n) {
    return (1LL << n) - 1;  // 2^n - 1
}
```

### **Q2: Find the kth move**

```cpp
void findKthMove(int n, int k, char src, char dst, char aux) {
    if (n == 1) {
        cout << "Move disk from " << src << " to " << dst << endl;
        return;
    }

    int movesForNMinus1 = (1 << (n - 1)) - 1;

    if (k <= movesForNMinus1) {
        // kth move is in first half
        findKthMove(n - 1, k, src, aux, dst);
    } else if (k == movesForNMinus1 + 1) {
        // kth move is the middle move
        cout << "Move disk " << n << " from " << src << " to " << dst << endl;
    } else {
        // kth move is in second half
        findKthMove(n - 1, k - movesForNMinus1 - 1, aux, dst, src);
    }
}
```

### **Q3: Minimum moves to reach a specific configuration**

This becomes a graph search problem (BFS/DFS).

---

## **Summary: Comparison of Approaches**

| Approach                | Time   | Space | Complexity | Best For                 |
| ----------------------- | ------ | ----- | ---------- | ------------------------ |
| **Recursive**           | O(2^n) | O(n)  | Simple     | Understanding, Small n   |
| **Iterative**           | O(2^n) | O(1)  | Medium     | Space-constrained        |
| **With State Tracking** | O(2^n) | O(n)  | Complex    | Visualization, Debugging |
| **Formula Only**        | O(1)   | O(1)  | Trivial    | Counting moves           |

### **Key Takeaways:**

1. ✅ **Recursive solution is the most elegant** and natural
2. ✅ **Exponential time** - unavoidable for this problem
3. ✅ **Linear space** - due to recursion depth
4. ✅ **2^n - 1 moves** - mathematical certainty
5. ✅ **Beautiful example** of divide-and-conquer recursion

**This problem perfectly demonstrates why recursion exists!** 🗼

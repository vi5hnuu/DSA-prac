https://www.geeksforgeeks.org/problems/josephus-problem/1

```cpp
class Solution {
  public:
    int josephus(int n, int k) {
        if(k<=1) return n;

        vector<bool> persons(n,true);

        int aliveCount=n;
        int pistolAt=0;
        while(aliveCount>1){//as long a more than 1 person is alive kill others [each iteration kill a person]
            int killAtSteps=0;
            int fromPos=pistolAt;//this person has pistol now
            while(true){
                if(persons[fromPos]){//if alive count
                    killAtSteps++;
                }

                if(killAtSteps%k==0){//if at target shoot
                    persons[fromPos]=false;//is dead
                    while(!persons[fromPos]) fromPos=(fromPos+1)%n;//give pistol to next alive person
                    pistolAt=fromPos;//given pistol
                    aliveCount--;//reduce alive count
                    break;//let try to kill others if alive>1
                }
                fromPos=(fromPos+1)%n;//move to next person for counting
            }
        }

        int aliveAt=-1;
        for(int i=0;i<n;i++){
            if(persons[i]){
                aliveAt=i+1;
                break;
            }
        }
        return aliveAt;
    }
};
```

```cpp
class Solution {
  public:
    int josephus(int n, int k) {
        if(k<=1) return n;

        vector<bool> persons(n,true);

        int aliveCount=n;
        int pistolAt=0;

        int killAtSteps=0;
        int fromPos=pistolAt;//this person has pistol now
        while(aliveCount>1){
            if(persons[fromPos]){//if alive count
                killAtSteps++;
            }

            if(killAtSteps%k==0){//if at target shoot
                persons[fromPos]=false;//is dead
                while(!persons[fromPos]) fromPos=(fromPos+1)%n;//give pistol to next alive person
                pistolAt=fromPos;//given pistol
                aliveCount--;//reduce alive count
                killAtSteps=0;
                continue;
            }
            fromPos=(fromPos+1)%n;//move to next person for counting
        }

        int aliveAt=-1;
        for(int i=0;i<n;i++){
            if(persons[i]){
                aliveAt=i+1;
                break;
            }
        }
        return aliveAt;
    }
};
```

# Josephus Problem - Recursive and Iterative Solutions Explained

Let me explain both solutions from scratch with **correct** traces!

---

## **Part 1: The Problem Setup**

**Given:**

- N people standing in a circle (numbered 1 to N)
- Starting from person 1, count K people
- Kill the Kth person
- Continue from the next person
- Find the last survivor

**Example: N=5, K=2**

---

## **Part 2: Manual Solution for N=5, K=2**

Let me trace this **very carefully**:

```
Initial Circle: [1, 2, 3, 4, 5]
Positions:      [0, 1, 2, 3, 4] (0-indexed)

Round 1: Start at position 0
  Count 1: position 0 (person 1) âœ“
  Count 2: position 1 (person 2) âœ“ â† KILL
  Killed: Person 2

Circle: [1, X, 3, 4, 5]
Next start: position 2

Round 2: Start at position 2
  Count 1: position 2 (person 3) âœ“
  Count 2: position 3 (person 4) âœ“ â† KILL
  Killed: Person 4

Circle: [1, X, 3, X, 5]
Next start: position 4

Round 3: Start at position 4
  Count 1: position 4 (person 5) âœ“
  Count 2: position 0 (person 1) âœ“ â† KILL (wrapped around)
  Killed: Person 1

Circle: [X, X, 3, X, 5]
Next start: position 2

Round 4: Start at position 2
  Count 1: position 2 (person 3) âœ“
  Count 2: position 4 (person 5) âœ“ â† KILL
  Killed: Person 5

Circle: [X, X, 3, X, X]

Survivor: Person 3 (position 2 in 0-indexed)
```

**Answer: Position 2 (0-indexed) = Person 3 (1-indexed)**

---

## **Part 3: The Mathematical Pattern - The Key Insight**

### **The Relationship:**

After we kill the first person in a circle of N people:

- We have N-1 people left
- The counting continues from a **shifted position** (position K)

**Key Question:** If we know the survivor's position for N-1 people, can we find it for N people?

**Answer:** YES! With a simple formula.

---

## **Part 4: Understanding the Formula**

### **The Formula:**

```
J(n, k) = (J(n-1, k) + k) % n

Base case: J(1, k) = 0
```

Where:

- `J(n, k)` = survivor position for n people with step k (0-indexed)
- `n` = number of people
- `k` = counting step

---

### **Why This Works - Visual Explanation:**

When we have N people and kill the first one:

```
Before elimination:
Positions: [0, 1, 2, 3, ..., k-1, k, k+1, ..., n-1]
           â†‘                    â†‘   â†‘
           Start              Kill Next start

After elimination (N-1 people remain):
Alive: [0, 1, 2, ..., k-1, X, k+1, k+2, ..., n-1]

Renumbering from position k (the new start):
Old position:  k,   k+1, ..., n-1,  0,   1,  ..., k-2
New numbering: 0,   1,   ..., n-k-1, n-k, n-k+1,..., n-2
```

**The relationship between old and new positions:**

```
old_position = (new_position + k) % n
```

Therefore:

```
J(n, k) = (J(n-1, k) + k) % n
```

The survivor's position in the N-person game =
(survivor's position in the (N-1)-person game + shift of k) mod n

---

## **Part 5: Step-by-Step Example - Building J(5, 2)**

Let's calculate J(5, 2) from the ground up:

### **J(1, 2) - Base Case:**

```
Circle: [1]
Position: [0]

Only 1 person, they survive at position 0.

J(1, 2) = 0
```

---

### **J(2, 2):**

```
Circle: [1, 2]
Positions: [0, 1]

Count 1: position 0 âœ“
Count 2: position 1 âœ“ â† KILL
Survivor: position 0

Using formula:
J(2, 2) = (J(1, 2) + 2) % 2
        = (0 + 2) % 2
        = 0 âœ“
```

**Meaning:** In a 2-person game, survivor is at position 0.

---

### **J(3, 2):**

```
Circle: [1, 2, 3]
Positions: [0, 1, 2]

Let's trace manually:
Count 1,2: kill position 1 â†’ [0, X, 2]
Count 1,2 from pos 2: kill position 0 â†’ [X, X, 2]
Survivor: position 2

Using formula:
J(3, 2) = (J(2, 2) + 2) % 3
        = (0 + 2) % 3
        = 2 âœ“
```

**Meaning:** In a 3-person game, survivor is at position 2.

**Understanding the shift:**

- In 2-person subgame, survivor was at position 0
- After first kill in 3-person game, counting starts from position 2
- Survivor's actual position = (0 + 2) % 3 = 2

---

### **J(4, 2):**

```
Circle: [1, 2, 3, 4]
Positions: [0, 1, 2, 3]

Manual trace:
Kill 1 â†’ [0, X, 2, 3], start 2
Kill 3 â†’ [0, X, 2, X], start 0
Kill 2 â†’ [0, X, X, X], start 0
Survivor: position 0

Using formula:
J(4, 2) = (J(3, 2) + 2) % 4
        = (2 + 2) % 4
        = 0 âœ“
```

**Meaning:** In a 4-person game, survivor is at position 0.

**Understanding the shift:**

- In 3-person subgame, survivor was at position 2
- After first kill in 4-person game, counting starts from position 2
- Survivor's actual position = (2 + 2) % 4 = 0

---

### **J(5, 2):**

```
Circle: [1, 2, 3, 4, 5]
Positions: [0, 1, 2, 3, 4]

We already traced manually: survivor is at position 2

Using formula:
J(5, 2) = (J(4, 2) + 2) % 5
        = (0 + 2) % 5
        = 2 âœ“
```

**Meaning:** In a 5-person game, survivor is at position 2.

**Final Answer: Position 2 (0-indexed) = Person 3 (1-indexed)**

---

## **Part 6: Recursive Solution**

### **The Code:**

```cpp
class Solution {
public:
    int josephus(int n, int k) {
        // Call helper and convert to 1-indexed
        return josephusRecursive(n, k) + 1;
    }

private:
    // Returns survivor position in 0-indexed
    int josephusRecursive(int n, int k) {
        // Base case: only 1 person at position 0
        if (n == 1) {
            return 0;
        }

        // Recursive case:
        // Position = (position in smaller problem + shift) mod n
        return (josephusRecursive(n - 1, k) + k) % n;
    }
};
```

---

### **Complete Recursion Tree for J(5, 2):**

```
josephusRecursive(5, 2)
â”‚
â”œâ”€ Needs result from: josephusRecursive(4, 2)
â”‚  â”‚
â”‚  â”œâ”€ Needs result from: josephusRecursive(3, 2)
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ Needs result from: josephusRecursive(2, 2)
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”œâ”€ Needs result from: josephusRecursive(1, 2)
â”‚  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€ Base case reached!
â”‚  â”‚  â”‚  â”‚     Returns: 0
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€ Computes: (0 + 2) % 2 = 0
â”‚  â”‚  â”‚     Returns: 0
â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€ Computes: (0 + 2) % 3 = 2
â”‚  â”‚     Returns: 2
â”‚  â”‚
â”‚  â””â”€ Computes: (2 + 2) % 4 = 0
â”‚     Returns: 0
â”‚
â””â”€ Computes: (0 + 2) % 5 = 2
   Returns: 2

Final result: 2 (0-indexed) â†’ 3 (1-indexed)
```

---

### **Call Stack Visualization:**

```
Step 1: Call josephusRecursive(5, 2)
Stack: [J(5,2)]
Status: Waiting for J(4,2)

Step 2: Call josephusRecursive(4, 2)
Stack: [J(5,2), J(4,2)]
Status: Waiting for J(3,2)

Step 3: Call josephusRecursive(3, 2)
Stack: [J(5,2), J(4,2), J(3,2)]
Status: Waiting for J(2,2)

Step 4: Call josephusRecursive(2, 2)
Stack: [J(5,2), J(4,2), J(3,2), J(2,2)]
Status: Waiting for J(1,2)

Step 5: Call josephusRecursive(1, 2)
Stack: [J(5,2), J(4,2), J(3,2), J(2,2), J(1,2)]
Status: Base case! Returns 0

Step 6: J(1,2) returns 0
Stack: [J(5,2), J(4,2), J(3,2), J(2,2)]
J(2,2) computes: (0+2)%2 = 0, returns 0

Step 7: J(2,2) returns 0
Stack: [J(5,2), J(4,2), J(3,2)]
J(3,2) computes: (0+2)%3 = 2, returns 2

Step 8: J(3,2) returns 2
Stack: [J(5,2), J(4,2)]
J(4,2) computes: (2+2)%4 = 0, returns 0

Step 9: J(4,2) returns 0
Stack: [J(5,2)]
J(5,2) computes: (0+2)%5 = 2, returns 2

Step 10: J(5,2) returns 2
Stack: []
Final answer: 2 + 1 = 3 (convert to 1-indexed)
```

---

### **Recursive Solution Analysis:**

**Time Complexity:** O(n)

- We make n recursive calls (from n down to 1)
- Each call does O(1) work

**Space Complexity:** O(n)

- Maximum recursion depth is n
- Each call uses O(1) space on the stack

**Problem:** For very large n (e.g., n = 100,000), this might cause **stack overflow**!

---

## **Part 7: Iterative Solution (Optimized)**

### **The Idea:**

Instead of recursion (going n â†’ n-1 â†’ ... â†’ 1), we can **build up** from 1 â†’ 2 â†’ ... â†’ n.

**Why this works:**

- We start with J(1, k) = 0 (base case)
- Use the formula to compute J(2, k), J(3, k), ..., J(n, k)
- No recursion needed!

---

### **The Code:**

```cpp
class Solution {
public:
    int josephus(int n, int k) {
        int position = 0;  // J(1, k) = 0 (base case)

        // Build up from 2 people to n people
        for (int people = 2; people <= n; people++) {
            // J(people, k) = (J(people-1, k) + k) % people
            position = (position + k) % people;
        }

        return position + 1;  // Convert to 1-indexed
    }
};
```

---

### **Step-by-Step Trace for N=5, K=2:**

```
Initialization:
position = 0  â† This represents J(1, 2) = 0

Iteration 1: people = 2
  position = (0 + 2) % 2
           = 2 % 2
           = 0

  â† This represents J(2, 2) = 0
  Meaning: With 2 people, survivor is at position 0

Iteration 2: people = 3
  position = (0 + 2) % 3
           = 2 % 3
           = 2

  â† This represents J(3, 2) = 2
  Meaning: With 3 people, survivor is at position 2

Iteration 3: people = 4
  position = (2 + 2) % 4
           = 4 % 4
           = 0

  â† This represents J(4, 2) = 0
  Meaning: With 4 people, survivor is at position 0

Iteration 4: people = 5
  position = (0 + 2) % 5
           = 2 % 5
           = 2

  â† This represents J(5, 2) = 2
  Meaning: With 5 people, survivor is at position 2

Final Result:
position = 2 (0-indexed)
Return: 2 + 1 = 3 (1-indexed) âœ“
```

---

### **Visual State Evolution:**

```
State of 'position' variable:

Start:    position = 0                    [J(1,2)]
          "1 person: survivor at pos 0"

After p=2: position = (0+2)%2 = 0         [J(2,2)]
          "2 people: survivor at pos 0"

After p=3: position = (0+2)%3 = 2         [J(3,2)]
          "3 people: survivor at pos 2"

After p=4: position = (2+2)%4 = 0         [J(4,2)]
          "4 people: survivor at pos 0"

After p=5: position = (0+2)%5 = 2         [J(5,2)]
          "5 people: survivor at pos 2"

Answer: 3 (1-indexed)
```

---

### **Iterative Solution Analysis:**

**Time Complexity:** O(n)

- Single loop from 2 to n
- Each iteration does O(1) work

**Space Complexity:** O(1) âœ…

- Only uses a single variable `position`
- No recursion stack!

**Advantage:** Works perfectly even for n = 1,000,000!

---

## **Part 8: Complete Working Code with Both Solutions**

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    // Iterative solution (RECOMMENDED)
    int josephusIterative(int n, int k) {
        int position = 0;  // J(1, k) = 0

        for (int people = 2; people <= n; people++) {
            position = (position + k) % people;
        }

        return position + 1;  // Convert to 1-indexed
    }

    // Recursive solution (for understanding)
    int josephusRecursive(int n, int k) {
        return helper(n, k) + 1;  // +1 for 1-indexing
    }

private:
    int helper(int n, int k) {
        if (n == 1) return 0;  // Base case
        return (helper(n - 1, k) + k) % n;
    }
};

// Simulation to verify correctness
int josephusSimulation(int n, int k) {
    vector<int> circle;
    for (int i = 1; i <= n; i++) {
        circle.push_back(i);
    }

    int index = 0;
    while (circle.size() > 1) {
        // Count k people and eliminate the kth
        index = (index + k - 1) % circle.size();

        cout << "Killing person " << circle[index]
             << " at position " << index << endl;

        circle.erase(circle.begin() + index);

        // index already points to the next person
        // due to erase shifting elements
    }

    return circle[0];
}

int main() {
    Solution sol;

    int n = 5, k = 2;

    cout << "=== Josephus Problem: N=" << n << ", K=" << k << " ===\n\n";

    // Simulation
    cout << "Simulation trace:\n";
    int sim = josephusSimulation(n, k);
    cout << "Survivor: " << sim << "\n\n";

    // Iterative
    int iter = sol.josephusIterative(n, k);
    cout << "Iterative solution: " << iter << "\n";

    // Recursive
    int rec = sol.josephusRecursive(n, k);
    cout << "Recursive solution: " << rec << "\n";

    // Verify all match
    if (sim == iter && iter == rec) {
        cout << "\nâœ“ All solutions match!\n";
    } else {
        cout << "\nâœ— Solutions don't match!\n";
    }

    return 0;
}
```

---

### **Output:**

```
=== Josephus Problem: N=5, K=2 ===

Simulation trace:
Killing person 2 at position 1
Killing person 4 at position 2
Killing person 1 at position 2
Killing person 5 at position 1
Survivor: 3

Iterative solution: 3
Recursive solution: 3

âœ“ All solutions match!
```

---

## **Part 9: Comparison Table**

| Aspect                  | Recursive              | Iterative             |
| ----------------------- | ---------------------- | --------------------- |
| **Time Complexity**     | O(n)                   | O(n)                  |
| **Space Complexity**    | O(n)                   | O(1) âœ…               |
| **Stack Overflow Risk** | Yes (large n)          | No âœ…                 |
| **Code Clarity**        | Very clear             | Equally clear         |
| **Performance**         | Function call overhead | Direct computation âœ… |
| **Large N (100,000)**   | May fail               | Works perfectly âœ…    |

---

## **Part 10: Why the Iterative Solution is Better**

```cpp
// For n = 100,000
int result = sol.josephusIterative(100000, 7);
// âœ… Works perfectly, O(1) space

int result = sol.josephusRecursive(100000, 7);
// âŒ Stack overflow! 100,000 recursive calls
```

**Recommendation:** Always use the **iterative solution** in production code!

---

## **Summary**

### **The Formula:**

```
J(n, k) = (J(n-1, k) + k) % n
J(1, k) = 0
```

### **Recursive (Top-Down):**

- Start from J(n, k)
- Recursively compute J(n-1, k), J(n-2, k), ..., J(1, k)
- O(n) space due to call stack

### **Iterative (Bottom-Up):**

- Start from J(1, k) = 0
- Build up J(2, k), J(3, k), ..., J(n, k)
- O(1) space - just one variable!

**Use iterative for optimal performance!** ðŸŽ¯

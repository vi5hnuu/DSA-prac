https://www.geeksforgeeks.org/problems/articulation-point-1/1

```cpp
// User function Template for C++

class Solution {
  public:
    vector<int> articulationPoints(int V, vector<int> adj[]) {
        vector<int> articulations;

        for(int i=0;i<V;i++){
            if(connectedComponents(V,adj,i)>=2) articulations.push_back(i);
        }
        if(articulations.empty()){
            articulations.push_back(-1);
        }
        return articulations;
    }
  private:
    int connectedComponents(int v,vector<int> *adj,int src){
        vector<bool> visited(v,false);
        visited[src]=true;

        int connectedC=0;
        for(int i=0;i<v;i++){
            if(visited[i]) continue;
            connectedC++;
            dfs(adj,visited,i);
        }
        return connectedC;
    }
    void dfs(vector<int> *adj,vector<bool> &visited,int src){
        if(visited[src]) return;
        visited[src]=true;
        for(int neighbour:adj[src]){
            if(visited[neighbour]) continue;
            dfs(adj,visited,neighbour);
        }
    }
};
```

```cpp
//User function Template for C++

class Solution {
private:
    void dfs(int source,vector<int> *adj,vector<int> &low,vector<int> &disc,int &timer,int parent,vector<bool> &aps,vector<bool> &visited){
        visited[source]=true;
        low[source]=disc[source]=timer++;

        int children=0;
        for(auto &neighbour:adj[source]){
            if(neighbour==parent) continue;
            if(!visited[neighbour]){
                children++;
                dfs(neighbour,adj,low,disc,timer,source,aps,visited);
                low[source]=min(low[source],low[neighbour]);
                //check if this is articulation point
                if(low[neighbour]>=disc[source] && parent!=-1){//if its not root and the lowest ancestor it can reach it greater than or equal to this node then its articulation point
                    aps[source]=true;
                }

            }else{//back edge
                low[source]=min(low[source],disc[neighbour]);
            }
        }
        if(parent==-1 && children>1){//if its root and has two children its articulation point
            aps[source]=true;
        }
    }
public:
    vector<int> articulationPoints(int V, vector<int>adj[]) {
        vector<int> low(V,-1);
        vector<int> disc(V,-1);
        int parent=-1;
        int timer=0;

        vector<bool> isap(V,false);
        vector<bool> visited(V,false);
        for(int i=0;i<V;i++){
            if(!visited[i]){
                dfs(i,adj,low,disc,timer,parent,isap,visited);
            }
        }

        vector<int> ans;
        for(int i=0;i<V;i++){
            if(isap[i]){
                ans.push_back(i);
            }
        }
        if(ans.empty()){
            ans.push_back(-1);
        }
        return ans;
    }
};
```

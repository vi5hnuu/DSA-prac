https://www.geeksforgeeks.org/problems/strongly-connected-component-tarjanss-algo-1587115621/1

- **Back edge**: Edge to an ancestor currently on the recursion path ‚Üí part of a cycle
- **Cross edge**: Edge to a node visited but no longer on the path ‚Üí already in a different SCC

```txt
üß† Tarjan‚Äôs intent recap
pathStack[v] = true means ‚Äúv is on the DFS stack, still in play.‚Äù

We pop and clear that flag only when we finalize the SCC for v.
```

```cpp

// v=10
// edges=15
// 5 4
// 6 6
// 3 9
// 9 5
// 2 1
// 3 0
// 9 9
// 1 3
// 4 5
// 8 5
// 7 3
// 3 8
// 9 5
// 5 3
// 8 6

//User function template for C++

class Solution{
private:
    void dfs(int source,vector<int> *adj,int &timer,vector<int> &low,
    vector<int> &disc,stack<int> &stck,vector<vector<int>> &cmps,
    vector<bool> &pathStack){
        low[source]=disc[source]=timer++;
        stck.push(source);
        pathStack[source]=true;

        for(int neighbour:adj[source]){
            if(disc[neighbour]==-1){
                dfs(neighbour,adj,timer,low,disc,stck,cmps,pathStack);
                low[source]=min(low[source],low[neighbour]);

            }else{
                if(pathStack[neighbour]){//this is backedge
                    low[source]=min(low[source],disc[neighbour]);
                }
            }
        }

        //NOTE 1.1 -> we should only clear path stack when all coponent is collected as other dfs migh have backedge
        //and if backedge is cleared at end of dfs then it would give wrong result
        //walk through above example... for 3 4 5 9 8 as one component
        //had we cleared pathStack at end of dfs we would got 3 4 5 9 only as component and not 8


        /*
        3->9
        9->5
        5->4
        4->5
        5->3
        3->8
        8->5
        */
        if(low[source]==disc[source]){
            vector<int> cmp;
            while(stck.top()!=source){
                cmp.push_back(stck.top());
                pathStack[stck.top()]=false;//NOTE 1.1
                stck.pop();
            }
            cmp.push_back(stck.top());
            pathStack[stck.top()]=false;//NOTE 1.1
            stck.pop();
            sort(cmp.begin(),cmp.end());
            cmps.push_back(cmp);
        }
    }
public:
    //Function to return a list of lists of integers denoting the members
    //of strongly connected components in the given graph.
    vector<vector<int>> tarjans(int V, vector<int> adj[])
    {
        //using articulation point technique with modification [tarjans algo]
        vector<int> low(V,-1);
        vector<int> disc(V,-1);
        vector<bool> pathStack(V,false);
        int timer=0;
        vector<vector<int>> cmps;
        stack<int> stck;

        for(int i=0;i<V;i++){
            if(disc[i]==-1){
                dfs(i,adj,timer,low,disc,stck,cmps,pathStack);
            }
        }
        sort(cmps.begin(),cmps.end());
        return cmps;
    }
};
```

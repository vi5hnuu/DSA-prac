# Bellman-Ford Algorithm

The Bellman-Ford algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph. Unlike Dijkstra's algorithm, it can handle **negative edge weights** and detect **negative cycles**.

## How It Works

1. **Initialize**: Set distance to source as 0, all others as infinity
2. **Relax edges**: For each edge (u,v) with weight w, if `distance[u] + w < distance[v]`, update `distance[v]`
3. **Repeat**: Do step 2 exactly `(V-1)` times, where V is the number of vertices
4. **Check negative cycles**: Run one more iteration - if any distance can still be reduced, a negative cycle exists

The key insight: In a graph with V vertices, the shortest path between any two vertices has at most V-1 edges. So relaxing all edges V-1 times guarantees we find the shortest paths.

## Code Implementation

```cpp
#include <iostream>
#include <vector>
#include <limits>
#include <map>
using namespace std;

struct Edge {
    int u, v, weight;
    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
};

class Graph {
private:
    int V;
    vector<Edge> edges;

public:
    Graph(int vertices) : V(vertices) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }

    bool bellmanFord(int source, vector<int>& distance, vector<int>& predecessor) {
        // Step 1: Initialize distances
        distance.assign(V, INT_MAX);
        predecessor.assign(V, -1);
        distance[source] = 0;

        // Step 2: Relax all edges V-1 times
        for (int i = 0; i < V - 1; i++) {
            for (const Edge& edge : edges) {
                if (distance[edge.u] != INT_MAX &&
                    distance[edge.u] + edge.weight < distance[edge.v]) {
                    distance[edge.v] = distance[edge.u] + edge.weight;
                    predecessor[edge.v] = edge.u;
                }
            }
        }

        // Step 3: Check for negative cycles
        for (const Edge& edge : edges) {
            if (distance[edge.u] != INT_MAX &&
                distance[edge.u] + edge.weight < distance[edge.v]) {
                return false; // Negative cycle detected
            }
        }

        return true; // No negative cycle
    }

    void printPath(int vertex, const vector<int>& predecessor, const map<int, char>& nameMap) {
        if (predecessor[vertex] == -1) {
            cout << nameMap.at(vertex);
            return;
        }
        printPath(predecessor[vertex], predecessor, nameMap);
        cout << " -> " << nameMap.at(vertex);
    }

    void printSolution(int source, const vector<int>& distance,
                      const vector<int>& predecessor, const map<int, char>& nameMap) {
        cout << "\nShortest paths from vertex " << nameMap.at(source) << ":\n";
        cout << string(50, '-') << endl;
        cout << "Vertex\tDistance\tPath\n";
        cout << string(50, '-') << endl;

        for (int i = 0; i < V; i++) {
            cout << nameMap.at(i) << "\t";
            if (distance[i] == INT_MAX) {
                cout << "INF\t\tNo path\n";
            } else {
                cout << distance[i] << "\t\t";
                printPath(i, predecessor, nameMap);
                cout << endl;
            }
        }
    }
};

int main() {
    cout << string(50, '=') << endl;
    cout << "BELLMAN-FORD ALGORITHM - EXAMPLE" << endl;
    cout << string(50, '=') << endl;
    cout << "\nGiven Edges:" << endl;
    cout << "A -> B (weight: 1)" << endl;
    cout << "A -> C (weight: 4)" << endl;
    cout << "B -> C (weight: -3)" << endl;
    cout << "B -> D (weight: 2)" << endl;
    cout << "C -> D (weight: 3)" << endl;
    cout << "D -> E (weight: 5)" << endl;

    // Create graph with 5 vertices (A=0, B=1, C=2, D=3, E=4)
    Graph g(5);
    map<char, int> vertexMap = {{'A', 0}, {'B', 1}, {'C', 2}, {'D', 3}, {'E', 4}};
    map<int, char> nameMap = {{0, 'A'}, {1, 'B'}, {2, 'C'}, {3, 'D'}, {4, 'E'}};

    // Add edges
    g.addEdge(0, 1, 1);   // A -> B: 1
    g.addEdge(0, 2, 4);   // A -> C: 4
    g.addEdge(1, 2, -3);  // B -> C: -3
    g.addEdge(1, 3, 2);   // B -> D: 2
    g.addEdge(2, 3, 3);   // C -> D: 3
    g.addEdge(3, 4, 5);   // D -> E: 5

    // Run Bellman-Ford from source A (vertex 0)
    int source = 0;
    vector<int> distance, predecessor;

    bool noNegativeCycle = g.bellmanFord(source, distance, predecessor);

    if (!noNegativeCycle) {
        cout << "\nGraph contains negative weight cycle!" << endl;
    } else {
        g.printSolution(source, distance, predecessor, nameMap);
    }

    // Step-by-step demonstration
    cout << "\n" << string(50, '=') << endl;
    cout << "STEP-BY-STEP EXPLANATION" << endl;
    cout << string(50, '=') << endl;

    cout << "\nInitial State:" << endl;
    cout << "A=0, B=∞, C=∞, D=∞, E=∞" << endl;

    cout << "\nIteration 1 (Relax all edges):" << endl;
    cout << "  A->B: 0+1=1, so B=1" << endl;
    cout << "  A->C: 0+4=4, so C=4" << endl;
    cout << "  After: A=0, B=1, C=4, D=∞, E=∞" << endl;

    cout << "\nIteration 2:" << endl;
    cout << "  B->C: 1+(-3)=-2 < 4, so C=-2 (updated!)" << endl;
    cout << "  B->D: 1+2=3, so D=3" << endl;
    cout << "  After: A=0, B=1, C=-2, D=3, E=∞" << endl;

    cout << "\nIteration 3:" << endl;
    cout << "  C->D: -2+3=1 < 3, so D=1 (updated!)" << endl;
    cout << "  After: A=0, B=1, C=-2, D=1, E=∞" << endl;

    cout << "\nIteration 4:" << endl;
    cout << "  D->E: 1+5=6, so E=6" << endl;
    cout << "  Final: A=0, B=1, C=-2, D=1, E=6" << endl;

    cout << "\n" << string(50, '=') << endl;
    cout << "KEY INSIGHT:" << endl;
    cout << string(50, '=') << endl;
    cout << "Path A->C costs 4 directly, but" << endl;
    cout << "Path A->B->C costs 1+(-3)=-2 (shorter!)" << endl;
    cout << "The negative edge makes the indirect path better." << endl;

    return 0;
}
```

## Your Example Explained

Given graph:

- **A → B** (weight: 1)
- **A → C** (weight: 4)
- **B → C** (weight: -3)
- **B → D** (weight: 2)
- **C → D** (weight: 3)
- **D → E** (weight: 5)

Starting from **A**:

**Initial**: A=0, all others=∞

**After Iteration 1**: Relax all edges once

- A→B: distance to B = 0 + 1 = **1**
- A→C: distance to C = 0 + 4 = **4**

**After Iteration 2**: Relax again

- B→C: 1 + (-3) = **-2** (better than 4, so update C!)
- B→D: 1 + 2 = **3**

**After Iteration 3**:

- C→D: -2 + 3 = **1** (better than 3, so update D!)

**After Iteration 4**:

- D→E: 1 + 5 = **6**

**Final shortest paths from A**:

- **A → A**: 0 (path: A)
- **A → B**: 1 (path: A → B)
- **A → C**: -2 (path: A → B → C) - Notice the negative edge made this shorter!
- **A → D**: 1 (path: A → B → C → D)
- **A → E**: 6 (path: A → B → C → D → E)

The key observation: Even though A→C has weight 4, going A→B→C (1 + (-3) = -2) is actually shorter because of the negative edge!

```cpp
#include <iostream>
#include <vector>
#include <limits>
#include <map>
#include <iomanip>
using namespace std;

struct Edge {
    int u, v, weight;
    Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
};

class Graph {
private:
    int V;
    vector<Edge> edges;

public:
    Graph(int vertices) : V(vertices) {}

    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }

    bool bellmanFordWithTrace(int source, vector<int>& distance, vector<int>& predecessor,
                              const map<int, char>& nameMap) {
        // Step 1: Initialize distances
        distance.assign(V, INT_MAX);
        predecessor.assign(V, -1);
        distance[source] = 0;

        cout << "\n" << string(60, '=') << endl;
        cout << "DETAILED ITERATION-BY-ITERATION TRACE" << endl;
        cout << string(60, '=') << endl;

        // Print initial state
        cout << "\nInitial State:" << endl;
        printDistances(distance, nameMap);

        // Step 2: Relax all edges V-1 times
        for (int iteration = 1; iteration <= V - 1; iteration++) {
            cout << "\n" << string(60, '-') << endl;
            cout << "ITERATION " << iteration << ":" << endl;
            cout << string(60, '-') << endl;

            bool updated = false;

            for (size_t i = 0; i < edges.size(); i++) {
                const Edge& edge = edges[i];

                if (distance[edge.u] != INT_MAX) {
                    int newDist = distance[edge.u] + edge.weight;

                    cout << "\nProcessing edge: " << nameMap.at(edge.u) << " -> "
                         << nameMap.at(edge.v) << " (weight: " << edge.weight << ")" << endl;
                    cout << "  Current distance to " << nameMap.at(edge.v) << ": ";
                    if (distance[edge.v] == INT_MAX) cout << "∞";
                    else cout << distance[edge.v];

                    cout << "\n  Calculated: dist[" << nameMap.at(edge.u) << "] + weight = "
                         << distance[edge.u] << " + " << edge.weight << " = " << newDist << endl;

                    if (newDist < distance[edge.v]) {
                        cout << "  ✓ RELAXATION: " << nameMap.at(edge.v) << " updated from ";
                        if (distance[edge.v] == INT_MAX) cout << "∞";
                        else cout << distance[edge.v];
                        cout << " to " << newDist << endl;

                        distance[edge.v] = newDist;
                        predecessor[edge.v] = edge.u;
                        updated = true;
                    } else {
                        cout << "  ✗ No update (current distance is better or equal)" << endl;
                    }
                } else {
                    cout << "\nProcessing edge: " << nameMap.at(edge.u) << " -> "
                         << nameMap.at(edge.v) << " (weight: " << edge.weight << ")" << endl;
                    cout << "  Source " << nameMap.at(edge.u) << " is unreachable, skipping..." << endl;
                }
            }

            cout << "\nState after iteration " << iteration << ":" << endl;
            printDistances(distance, nameMap);

            if (!updated) {
                cout << "\n*** No updates in this iteration. Algorithm can terminate early! ***" << endl;
                break;
            }
        }

        // Step 3: Check for negative cycles
        cout << "\n" << string(60, '=') << endl;
        cout << "CHECKING FOR NEGATIVE CYCLES..." << endl;
        cout << string(60, '=') << endl;

        for (const Edge& edge : edges) {
            if (distance[edge.u] != INT_MAX &&
                distance[edge.u] + edge.weight < distance[edge.v]) {
                cout << "Negative cycle detected!" << endl;
                return false;
            }
        }

        cout << "No negative cycles found. ✓" << endl;
        return true;
    }

    void printDistances(const vector<int>& distance, const map<int, char>& nameMap) {
        cout << "  ";
        for (int i = 0; i < V; i++) {
            cout << nameMap.at(i) << "=";
            if (distance[i] == INT_MAX) cout << "∞";
            else cout << distance[i];
            if (i < V - 1) cout << ", ";
        }
        cout << endl;
    }

    void printPath(int vertex, const vector<int>& predecessor, const map<int, char>& nameMap) {
        if (predecessor[vertex] == -1) {
            cout << nameMap.at(vertex);
            return;
        }
        printPath(predecessor[vertex], predecessor, nameMap);
        cout << " -> " << nameMap.at(vertex);
    }

    void printSolution(int source, const vector<int>& distance,
                      const vector<int>& predecessor, const map<int, char>& nameMap) {
        cout << "\n" << string(60, '=') << endl;
        cout << "FINAL SHORTEST PATHS FROM " << nameMap.at(source) << endl;
        cout << string(60, '=') << endl;

        cout << "\n" << left << setw(10) << "Vertex"
             << setw(12) << "Distance" << "Path" << endl;
        cout << string(60, '-') << endl;

        for (int i = 0; i < V; i++) {
            cout << left << setw(10) << nameMap.at(i);
            if (distance[i] == INT_MAX) {
                cout << setw(12) << "INF" << "No path" << endl;
            } else {
                cout << setw(12) << distance[i];
                printPath(i, predecessor, nameMap);
                cout << endl;
            }
        }
    }
};

int main() {
    cout << string(60, '=') << endl;
    cout << "BELLMAN-FORD ALGORITHM - COMPLETE TRACE" << endl;
    cout << string(60, '=') << endl;
    cout << "\nGiven Edges (in this order):" << endl;
    cout << "1. A -> B (weight: 1)" << endl;
    cout << "2. A -> C (weight: 4)" << endl;
    cout << "3. B -> C (weight: -3)" << endl;
    cout << "4. B -> D (weight: 2)" << endl;
    cout << "5. C -> D (weight: 3)" << endl;
    cout << "6. D -> E (weight: 5)" << endl;

    // Create graph with 5 vertices (A=0, B=1, C=2, D=3, E=4)
    Graph g(5);
    map<char, int> vertexMap = {{'A', 0}, {'B', 1}, {'C', 2}, {'D', 3}, {'E', 4}};
    map<int, char> nameMap = {{0, 'A'}, {1, 'B'}, {2, 'C'}, {3, 'D'}, {4, 'E'}};

    // Add edges IN THE EXACT ORDER specified
    g.addEdge(0, 1, 1);   // A -> B: 1
    g.addEdge(0, 2, 4);   // A -> C: 4
    g.addEdge(1, 2, -3);  // B -> C: -3
    g.addEdge(1, 3, 2);   // B -> D: 2
    g.addEdge(2, 3, 3);   // C -> D: 3
    g.addEdge(3, 4, 5);   // D -> E: 5

    // Run Bellman-Ford from source A (vertex 0)
    int source = 0;
    vector<int> distance, predecessor;

    bool noNegativeCycle = g.bellmanFordWithTrace(source, distance, predecessor, nameMap);

    if (!noNegativeCycle) {
        cout << "\nGraph contains negative weight cycle!" << endl;
    } else {
        g.printSolution(source, distance, predecessor, nameMap);
    }

    cout << "\n" << string(60, '=') << endl;
    cout << "KEY OBSERVATIONS:" << endl;
    cout << string(60, '=') << endl;
    cout << "1. In Iteration 1, edge B->C updates C from 4 to -2" << endl;
    cout << "2. In the SAME iteration, edge C->D can then use the" << endl;
    cout << "   updated value -2 to set D to 1" << endl;
    cout << "3. In the SAME iteration, edge D->E can then use D=1" << endl;
    cout << "   to set E to 6" << endl;
    cout << "4. All shortest paths found in just 1 iteration!" << endl;
    cout << "5. But algorithm runs V-1 times to guarantee correctness" << endl;
    cout << "   regardless of edge ordering" << endl;

    return 0;
}
```

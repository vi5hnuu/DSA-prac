https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Graph/problem/articulation-point2616

```cpp
class Solution {
  public:
    vector<int> articulationPoints(int v, vector<vector<int>>& edges) {
        map<int,vector<int>> adjList=createAdjList(edges);
        vector<bool> visited=vector<bool>(v,false);
        vector<int> discoveryTime=vector<int>(v,-1);
        vector<int> lowestReachTime=vector<int>(v,-1);
        vector<bool> ap=vector<bool>(v,false);
        int parent=-1;
        int timer=0;
        for(int i=0;i<v;i++){
            if(!visited[i]) tarjansAlgo(adjList,visited,discoveryTime,lowestReachTime,ap,parent,i,timer);
        }

        vector<int> articulationPoints;
        for(int i=0;i<v;i++){
            if(ap[i]) articulationPoints.push_back(i);
        }

        if(!articulationPoints.size()) articulationPoints.push_back(-1);
        return articulationPoints;
    }
  private:
    void tarjansAlgo(map<int,vector<int>> &adjList,
                    vector<bool> &visited,
                    vector<int> &discoveryTime,
                    vector<int> &lowestReachTime,
                    vector<bool> &articulationPoints,int parent,int node,int &timer){
        if(visited[node]) return;
        visited[node]=true;
        discoveryTime[node] = lowestReachTime[node] = timer++;

        int independentChilds=0;
        for(const auto &neighbour:adjList[node]){
            if(neighbour==parent) continue;
            if(visited[neighbour]){//backedge [cannot be bridge/articulation point]
                lowestReachTime[node]=min(lowestReachTime[node],discoveryTime[neighbour]);
            }else{
                independentChilds++;
                tarjansAlgo(adjList,visited,discoveryTime,lowestReachTime,articulationPoints,node,neighbour,timer);
                lowestReachTime[node]=min(lowestReachTime[node],lowestReachTime[neighbour]);

                //check if it is a articulation point
                if(lowestReachTime[neighbour]>=discoveryTime[node] && parent!=-1){//is bridge
                    articulationPoints[node]=true;
                }
            }
        }
        //
        if(parent==-1 && independentChilds>=2) articulationPoints[node]=true;
    }
    map<int,vector<int>> createAdjList(vector<vector<int>> &edges){
        map<int,vector<int>> adjList;

        for(const auto&edge:edges){
            adjList[edge[0]].push_back(edge[1]);
            adjList[edge[1]].push_back(edge[0]);
        }
        return adjList;
    }
};
```

https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Graph/problem/distance-of-nearest-cell-having-1-1587115620

```cpp
class Solution {
  public:
    vector<vector<int>> nearest(vector<vector<int>>& grid) {
        int rows=grid.size();
        if(!rows) return {};
        int cols=grid[0].size();

        vector<vector<int>> nearestOne(rows,vector<int>(cols,0));
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(grid[i][j]) continue;
                nearestOne[i][j]=bfsNearestOne(rows,cols,grid,i,j);
            }
        }
        return nearestOne;
    }
  private:
    int bfsNearestOne(int r,int c,vector<vector<int>>& grid,int i,int j){
        if(grid[i][j]) return 0;

        queue<pair<int,int>> nodes;
        nodes.push({i,j});

        vector<bool> visited(r*c,false);
        visited[i*c+j]=true;
        int level=0;
        while(!nodes.empty()){
          int sz=nodes.size();
          while(sz--){
              auto node=nodes.front();
              nodes.pop();
              int i=node.first;
              int j=node.second;

              int dx[]={1,-1,0,0};
              int dy[]={0,0,1,-1};
              for(int k=0;k<4;k++){
                  int ix=i+dx[k];
                  int jy=j+dy[k];
                  if(inRange(r,c,ix,jy) && !visited[ix*c+jy]){
                        if(grid[ix][jy]) return level+1;
                        visited[ix*c+jy]=true;
                        nodes.push({ix,jy});
                  }
              }
          }
          level++;
        }
        return -1;
    }
  private:
    bool inRange(int r,int c,int i,int j){
        return i>=0 && j>=0 && i<r && j<c;
    }
};
```

```cpp
class Solution
{
    public:
    //Function to find distance of nearest 1 in the grid for each cell.
	vector<vector<int>>nearest(vector<vector<int>>grid)
	{
	    int rows=grid.size();
	    int cols=grid[0].size();

	    vector<vector<bool>> visited(rows,vector<bool>(cols,false));
	    vector<vector<int>> distance(rows,vector<int>(cols,0));

	    queue<pair<int,int>> que;
	    for(int i=0;i<rows;i++){
	        for(int j=0;j<cols;j++){
	            if(grid[i][j]==1){
	                que.push({i,j});
	                visited[i][j]=true;
	            }
	        }
	    }
	    //for all initial ones there is zero in distacnce matrix already
	    int step=1;
	    while(!que.empty()){
	        int sz=que.size();
	        while(sz>0){
	            sz--;
	            auto pos=que.front();
	            que.pop();
	            int ai[4]={0,0,1,-1};
	            int aj[4]={1,-1,0,0};
	            for(int j=0;j<4;j++){
	                int x=pos.first+ai[j];
	                int y=pos.second+aj[j];
	                if(x>=0 && x<rows && y>=0 && y<cols && !visited[x][y]){
    	                distance[x][y]=step;
    	                visited[x][y]=true;
    	                que.push({x,y});
	                }
	            }
	        }
	        step++;
	    }
	    return distance;
	}
};
```

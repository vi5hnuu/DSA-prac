https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Graph/problem/steps-by-knight5927

### though used visited and making false at end, but next dfs might travel similar path just the start would be different....

## TLE

```cpp
class Solution {
private:
    int getMin(initializer_list<int> nums){
        int mn=INT_MAX;
        for(int n:nums){
            mn=min(mn,n);
        }
        return mn;
    }
    int minStepToReachTarget(vector<vector<bool>> &visited,vector<int>&targetPos,int N,int i,int j){
	    if(i<=0 || j<=0 || i>N || j>N || visited[i][j]){
	        return INT_MAX;
	    }
	    if(i==targetPos[0] && j==targetPos[1]){
	        return 0;
	    }
	    visited[i][j]=true;
	    int a=minStepToReachTarget(visited,targetPos,N,i+1,j+2);
	    int b=minStepToReachTarget(visited,targetPos,N,i+1,j-2);
	    int c=minStepToReachTarget(visited,targetPos,N,i-1,j+2);
	    int d=minStepToReachTarget(visited,targetPos,N,i-1,j-2);
	    int e=minStepToReachTarget(visited,targetPos,N,i+2,j+1);
	    int f=minStepToReachTarget(visited,targetPos,N,i+2,j-1);
	    int g=minStepToReachTarget(visited,targetPos,N,i-2,j+1);
	    int h=minStepToReachTarget(visited,targetPos,N,i-2,j-1);
	    int mn=getMin({a,b,c,d,e,f,g,h});
	    visited[i][j]=false;
	    return mn==INT_MAX ? INT_MAX : mn+1;
	}
public:
    //Function to find out minimum steps Knight needs to reach target position.
	int minStepToReachTarget(vector<int>&KnightPos,vector<int>&TargetPos,int N){
	    vector<vector<bool>> visited(N+1,vector<bool>(N+1,false));
	    int ans=minStepToReachTarget(visited,TargetPos,N,KnightPos[0],KnightPos[1]);
	    return ans==INT_MAX ? -1 : ans;
	}
};
```

### TLE

```cpp
class Solution {
private:
    int getMin(initializer_list<int> nums){
        int mn=INT_MAX;
        for(int n:nums){
            mn=min(mn,n);
        }
        return mn;
    }
    int minStepToReachTarget(vector<int>&targetPos,int N,int i,int j,vector<vector<bool>> &visited,map<int,int> &mp){
	    if(i<=0 || j<=0 || i>N || j>N || visited[i][j]){
	        return INT_MAX;
	    }
	    if(i==targetPos[0] && j==targetPos[1]){
	        return 0;
	    }
	    if(mp[i*N+j]>0){
	        return mp[i*N+j];
	    }
	    visited[i][j]=true;
	    int a=minStepToReachTarget(targetPos,N,i+1,j+2,visited,mp);
	    int b=minStepToReachTarget(targetPos,N,i+1,j-2,visited,mp);
	    int c=minStepToReachTarget(targetPos,N,i-1,j+2,visited,mp);
	    int d=minStepToReachTarget(targetPos,N,i-1,j-2,visited,mp);
	    int e=minStepToReachTarget(targetPos,N,i+2,j+1,visited,mp);
	    int f=minStepToReachTarget(targetPos,N,i+2,j-1,visited,mp);
	    int g=minStepToReachTarget(targetPos,N,i-2,j+1,visited,mp);
	    int h=minStepToReachTarget(targetPos,N,i-2,j-1,visited,mp);
	    int mn=getMin({a,b,c,d,e,f,g,h});
	    visited[i][j]=false;
	    return mp[i*N+j]=(mn==INT_MAX ? INT_MAX : mn+1);
	}
public:
    //Function to find out minimum steps Knight needs to reach target position.
	int minStepToReachTarget(vector<int>&KnightPos,vector<int>&TargetPos,int N){
	    vector<vector<bool>> visited(N+1,vector<bool>(N+1,false));
	    map<int,int> mp;
	    int ans=minStepToReachTarget(TargetPos,N,KnightPos[0],KnightPos[1],visited,mp);
	    return ans==INT_MAX ? -1 : ans;
	}
};
```

```cpp
class Solution {
  public:
    int minStepToReachTarget(vector<int>& knightPos, vector<int>& targetPos, int n) {
        if(knightPos[0]==targetPos[0] && knightPos[1]==targetPos[1]) return 0;
        queue<pair<int,int>> position;
        position.push({knightPos[0]-1,knightPos[1]-1});

        vector<vector<bool>> visited(n,vector<bool>(n,false));
        visited[knightPos[0]-1][knightPos[1]-1]=true;

        int step=0;
        while(!position.empty()){
            int sz=position.size();
            while(sz--){
                auto [i,j]=position.front();
                position.pop();

                int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2};
                int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1};
                for(int k=0;k<8;k++){
                    int x=i+dx[k];
                    int y=j+dy[k];
                    if(x<n && x>=0 && y>=0 && y<n && !visited[x][y]){
                        if(targetPos[0]-1==x && targetPos[1]-1==y) return step+1;
                        position.push({x,y});
                        visited[x][y]=true;
                    }
                }
            }
            step++;
        }
        return -1;
    }
};
```

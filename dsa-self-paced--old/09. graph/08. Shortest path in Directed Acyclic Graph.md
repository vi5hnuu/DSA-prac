https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph/1

V=6
E=10
0 1 2
1 3 2
3 4 4
4 2 3
2 5 5
0 5 20
0 2 10
10 9 5
9 0 8
0 12 2

### TLE

```cpp
// User function Template for C++
class Solution {
  public:
    vector<int> shortestPath(int V, int E, vector<vector<int>>& edges) {
        vector<vector<pair<int,int>>> adj(V,vector<pair<int,int>>());

        for(auto edge:edges){
            int u=edge[0];
            int v=edge[1];
            int w=edge[2];
            adj[u].push_back(make_pair(v,w));
        }
        vector<int> shortestPaths(V,INT_MAX);
        vector<bool> visited(V,false);
        shortestPaths[0]=0;
        visited[0]=true;

        queue<int> nodes;
        nodes.push(0);

        while(!nodes.empty()){
            int sz=nodes.size();
            while(sz--){
                int node=nodes.front();
                nodes.pop();

                for(auto [neighbour,weight]:adj[node]){
                    shortestPaths[neighbour]=min(shortestPaths[neighbour],shortestPaths[node]+weight);
                    nodes.push(neighbour);//since there is no cycle...nodes will be empty at one point
                }
            }
        }

        for(int i=0;i<V;i++){
            if(shortestPaths[i]==INT_MAX) shortestPaths[i]=-1;
        }
        return shortestPaths;
    }
};
```

### TLE

```cpp
class Solution{
	public:
     vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
        vector<pair<int,int>> adj[N];
        for(auto &edge:edges){
            adj[edge[0]].push_back({edge[1],edge[2]});//u->{v,w}
        }
        vector<int> dis(N, INT_MAX);
        queue<int> q;
        int src = 0;
        q.push(src);
        dis[src] = 0;

        //BFS
        while(!q.empty()){
            int u = q.front();
            q.pop();

            for(auto it:adj[u]){
                int v = it.first;
                int weightuv = it.second;
                if(dis[v]>dis[u] + weightuv)
                    dis[v]=dis[u] + weightuv;
                q.push(v);
            }
        }

        for(int i = 0; i < dis.size(); i++){
            if(dis[i] == INT_MAX) dis[i] = -1;
        }
        return dis;
    }
};
```

```cpp
class Solution{
private:
    vector<int> topoBfs(vector<pair<int,int>> *adj,int V){
        vector<int> ind(V,0);
        for(int i=0;i<V;i++){
            for(auto &ad:adj[i]){
                ind[ad.first]++;
            }
        }
        queue<int> nodes;
        for(int i=0;i<V;i++){
            if(ind[i]==0){
                nodes.push(i);
            }
        }

        vector<int> topoOrder;
        while(!nodes.empty()){
            int node=nodes.front();
            nodes.pop();
            topoOrder.push_back(node);
            for(auto &neigh:adj[node]){
                ind[neigh.first]--;
                if(ind[neigh.first]==0){
                    nodes.push(neigh.first);
                }
            }
        }
        return topoOrder;
    }
public:
     vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
        vector<pair<int,int>> adj[N];
        for(auto &edge:edges){
            adj[edge[0]].push_back({edge[1],edge[2]});//u->{v,w}
        }
        vector<int> topoOrder=topoBfs(adj,N);
        vector<int> dis(N, INT_MAX);
        dis[0]=0;

        int i=0;
        while(i<N){
            int u=topoOrder[i++];
            if(dis[u]==INT_MAX) continue;
            for(auto &neigh:adj[u]){
                int wuv=neigh.second;
                int v=neigh.first;
                dis[v]=min(dis[u]+wuv,dis[v]);
            }
        }

        for(int i=0;i<N;i++){
            if(dis[i]==INT_MAX) dis[i]=-1;
        }
        return dis;
    }
};
```

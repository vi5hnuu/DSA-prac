http://geeksforgeeks.org/problems/minimum-spanning-tree/1

```cpp
class Solution {
  public:
    int spanningTree(int V, vector<vector<int>>& edges) {
        vector<vector<int>> adj(V,vector<int>(V,0));

        for(auto &edge:edges){
            int  u=edge[0];
            int  v=edge[1];
            int  w=edge[2];
            adj[u][v]=w;
            adj[v][u]=w;
        }

        //
        vector<bool> inMst(V,false);
        vector<int> minActiveAdjacentWeight(V,INT_MAX);
        minActiveAdjacentWeight[0]=0;

        int totalWeight=0;
        for(int i=0;i<V;i++){//pick all vertices
            int chosenVertex=-1;
            for(int i=0;i<V;i++){
                if(!inMst[i] && (chosenVertex==-1 || minActiveAdjacentWeight[i]<minActiveAdjacentWeight[chosenVertex])){
                    chosenVertex=i;
                }
            }
            inMst[chosenVertex]=true;
            totalWeight+=minActiveAdjacentWeight[chosenVertex];
            //activate new adjacents [as new vertex is added]
            for(int i=0;i<V;i++){
                const bool hasEdge=adj[chosenVertex][i];
                if(!hasEdge || inMst[i]) continue;
                minActiveAdjacentWeight[i]=min(minActiveAdjacentWeight[i],adj[chosenVertex][i]);
                //why used min fn
                //becase in next turn we have to chose a vertex and this vertext can have multiple edges with vertexes in mst
                //all we have to do is...can we chose this as next vertex[in next loop]...
                //so since new vertext is added 'chosenvertex' and this chosen vertex might also has edge to ith vertex.. and old mst might also had edges with ith vertex so we have to give this ith vertex min weight from all edges to it...
            }
        }
        return totalWeight;
    }
};
```

```cpp
class Comparator{
  public:
    bool operator()(pair<int,int> &a,pair<int,int> &b){
        return a.second>b.second;
    }
};
class Solution
{
	public:
	//Function to find sum of weights of edges of the Minimum Spanning Tree.
    int spanningTree(int V, vector<vector<int>> &edges){
        vector<vector<pair<int,int>>> adj(V,vector<pair<int,int>>());

        for(auto &edge:edges){
            int  u=edge[0];
            int  v=edge[1];
            int  w=edge[2];
            adj[u].push_back(make_pair(v,w));
            adj[v].push_back(make_pair(u,w));
        }

        priority_queue<pair<int,int>,vector<pair<int,int>>,Comparator> pq;
        pq.push({0,0});

        int ans=0;
        vector<bool> inMST(V,false);
        while(!pq.empty()){
            auto node=pq.top();
            pq.pop();

            if(inMST[node.first]){
                continue;
            }
            ans+=node.second;
            inMST[node.first]=true;
            for(auto &ad:adj[node.first]){
                if(inMST[ad.first]) continue;
                pq.push(ad);
            }
        }
        return ans;
    }
};
```

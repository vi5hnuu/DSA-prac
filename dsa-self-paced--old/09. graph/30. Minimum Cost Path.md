https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Graph/problem/minimum-cost-path3833

```cpp
class Solution {
  public:
    // Function to return the minimum cost to react at bottom
    // right cell from top left cell.
    int minimumCostPath(vector<vector<int>> &grid) {
        int r=grid.size();
        int c=grid[0].size();

        return minPath(r,c,grid,0,0);
    }
  private:
    int minPath(int r,int c,vector<vector<int>> &grid,int i,int j){
        if(i<0 || j<0 || i>=r || j>=c || grid[i][j]==-1) return INT_MAX;
        int data=grid[i][j];
        if(i==r-1 && j==c-1) return data;
        grid[i][j]=-1;

        int dx[]={0,0,1,-1};
        int dy[]={1,-1,0,0};
        int mnPath=INT_MAX;
        for(int k=0;k<4;k++){
            int x=i+dx[k];
            int y=j+dy[k];
            mnPath=min(mnPath,minPath(r,c,grid,x,y));
        }
        grid[i][j]=data;
        return mnPath==INT_MAX ? INT_MAX : data+mnPath;
    }
};
```

### why is this wrong

> because let say i traverse a path and i get min path as X
> now i traverse other independent path and at point where both path intercept i go to know that below point of intercept i will get b (X=a(before intercept)+b[from intercept to end]) min path
> now the problem is the 'b' which is from intercept to end might be crossing the second path to reach end which is wrong

```cpp
class Solution {
  public:
    // Function to return the minimum cost to react at bottom
    // right cell from top left cell.
    int minimumCostPath(vector<vector<int>> &grid) {
        int r=grid.size();
        int c=grid[0].size();
        unordered_map<int,int> memo;
        return minPath(r,c,grid,memo,0,0);
    }
  private:
    int minPath(int r,int c,vector<vector<int>> &grid,unordered_map<int,int> &memo,int i,int j){
        if(i<0 || j<0 || i>=r || j>=c || grid[i][j]==-1) return INT_MAX;
        int data=grid[i][j];
        if(i==r-1 && j==c-1) return data;

        auto cache=memo.find(i*c+j);
        if(cache!=memo.end()) return cache->second;

        grid[i][j]=-1;

        int dx[]={0,0,1,-1};
        int dy[]={1,-1,0,0};
        int mnPath=INT_MAX;
        for(int k=0;k<4;k++){
            int x=i+dx[k];
            int y=j+dy[k];
            mnPath=min(mnPath,minPath(r,c,grid,memo,x,y));
        }
        grid[i][j]=data;
        return memo[i*c+j]=(mnPath==INT_MAX ? INT_MAX : data+mnPath);
    }
};
```

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minimumCostPath(vector<vector<int>>& grid) {
        int n = grid.size();
        if (n == 0) return 0;
        int N = n * n;
        const int INF = INT_MAX;
        vector<int> dist(N, INF);
        vector<bool> finalized(n * n, false);

        auto idx = [n](int i, int j){ return i*n + j; };

        // min-heap of (cost, index)
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        dist[0] = grid[0][0];
        pq.push({dist[0], 0});

        int dx[4] = {0, 0, -1, 1};
        int dy[4] = {1, -1, 0, 0};

        while (!pq.empty()) {
            auto [cost, id] = pq.top(); pq.pop();
            if (finalized[id]) continue;  // ✅ Skip if already processed
            finalized[id] = true;         // ✅ Mark as finalized

            int i = id / n, j = id % n;
            if (i == n-1 && j == n-1) return cost; // early exit

            for (int k = 0; k < 4; ++k) {
                int ni = i + dx[k], nj = j + dy[k];
                if (ni < 0 || nj < 0 || ni >= n || nj >= n) continue;
                int nid = idx(ni, nj);
                if (finalized[nid]) continue;  // ✅ Skip finalized neighbors
                int nc = cost + grid[ni][nj];
                if (nc < dist[nid]) {
                    dist[nid] = nc;
                    pq.push({nc, nid});
                }
            }
        }
        return dist[n*n - 1];
    }
};
```

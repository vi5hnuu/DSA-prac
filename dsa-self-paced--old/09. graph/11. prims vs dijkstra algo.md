# Dijkstra's Algorithm Explained

Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative edge weights.

## How It Works

The algorithm maintains a set of vertices whose shortest distance from the source is known. It repeatedly selects the unvisited vertex with the smallest tentative distance, updates the distances to its neighbors, and marks it as visited.

**Key Steps:**

1. Initialize distances: source = 0, all others = infinity
2. Select the unvisited vertex with minimum distance
3. Update distances to all its unvisited neighbors
4. Mark the vertex as visited
5. Repeat until all vertices are visited

## Time Complexity

- With adjacency list and priority queue: O((V + E) log V)
- With adjacency matrix: O(V²)

## Complete C++ Implementation## Scenarios Covered

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <algorithm>
using namespace std;

class Graph {
    int V; // Number of vertices
    vector<vector<pair<int, int>>> adj; // Adjacency list: {neighbor, weight}

public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight}); // For undirected graph
    }

    void addDirectedEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight}); // For directed graph
    }

    // Dijkstra's algorithm with path reconstruction
    void dijkstra(int src, int dest = -1) {
        // Priority queue: {distance, vertex}
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

        vector<int> dist(V, INT_MAX); // Distance array
        vector<int> parent(V, -1);     // To reconstruct path
        vector<bool> visited(V, false); // Visited array

        dist[src] = 0;
        pq.push({0, src});

        while (!pq.empty()) {
            int u = pq.top().second;
            int d = pq.top().first;
            pq.pop();

            // Skip if already visited
            if (visited[u]) continue;
            visited[u] = true;

            // Early termination if destination is reached
            if (dest != -1 && u == dest) break;

            // Explore neighbors
            for (auto& edge : adj[u]) {
                int v = edge.first;
                int weight = edge.second;

                // Relaxation step
                if (!visited[v] && dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    parent[v] = u;
                    pq.push({dist[v], v});
                }
            }
        }

        // Print results
        printResults(src, dist, parent, dest);
    }

    void printResults(int src, vector<int>& dist, vector<int>& parent, int dest) {
        cout << "\nShortest distances from vertex " << src << ":\n";
        cout << "Vertex\t\tDistance\tPath\n";

        for (int i = 0; i < V; i++) {
            cout << src << " -> " << i << "\t\t";

            if (dist[i] == INT_MAX) {
                cout << "INF\t\tNo path\n";
            } else {
                cout << dist[i] << "\t\t";
                printPath(parent, i);
                cout << "\n";
            }
        }

        // If specific destination was requested
        if (dest != -1 && dest < V) {
            cout << "\n=== Specific Path to Vertex " << dest << " ===\n";
            if (dist[dest] == INT_MAX) {
                cout << "No path exists!\n";
            } else {
                cout << "Distance: " << dist[dest] << "\n";
                cout << "Path: ";
                printPath(parent, dest);
                cout << "\n";
            }
        }
    }

    void printPath(vector<int>& parent, int dest) {
        if (parent[dest] == -1) {
            cout << dest;
            return;
        }
        printPath(parent, parent[dest]);
        cout << " -> " << dest;
    }

    void printGraph() {
        cout << "\nGraph Structure:\n";
        for (int i = 0; i < V; i++) {
            cout << "Vertex " << i << ": ";
            for (auto& edge : adj[i]) {
                cout << "(" << edge.first << ", w:" << edge.second << ") ";
            }
            cout << "\n";
        }
    }
};

// Scenario 1: Simple connected graph
void scenario1() {
    cout << "\n========== SCENARIO 1: Simple Connected Graph ==========\n";
    Graph g(5);
    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 1);
    g.addEdge(1, 3, 1);
    g.addEdge(2, 1, 2);
    g.addEdge(2, 3, 5);
    g.addEdge(3, 4, 3);

    g.printGraph();
    g.dijkstra(0);
}

// Scenario 2: Disconnected graph
void scenario2() {
    cout << "\n========== SCENARIO 2: Disconnected Graph ==========\n";
    Graph g(6);
    g.addEdge(0, 1, 2);
    g.addEdge(1, 2, 3);
    // Vertices 3, 4, 5 are disconnected
    g.addEdge(3, 4, 1);
    g.addEdge(4, 5, 2);

    g.printGraph();
    g.dijkstra(0);
}

// Scenario 3: Dense graph with multiple paths
void scenario3() {
    cout << "\n========== SCENARIO 3: Dense Graph (Multiple Paths) ==========\n";
    Graph g(6);
    g.addEdge(0, 1, 7);
    g.addEdge(0, 2, 9);
    g.addEdge(0, 5, 14);
    g.addEdge(1, 2, 10);
    g.addEdge(1, 3, 15);
    g.addEdge(2, 3, 11);
    g.addEdge(2, 5, 2);
    g.addEdge(3, 4, 6);
    g.addEdge(4, 5, 9);

    g.printGraph();
    g.dijkstra(0);
}

// Scenario 4: Directed graph
void scenario4() {
    cout << "\n========== SCENARIO 4: Directed Graph ==========\n";
    Graph g(4);
    g.addDirectedEdge(0, 1, 1);
    g.addDirectedEdge(0, 2, 4);
    g.addDirectedEdge(1, 2, 2);
    g.addDirectedEdge(1, 3, 6);
    g.addDirectedEdge(2, 3, 3);

    g.printGraph();
    g.dijkstra(0);
}

// Scenario 5: Single vertex graph
void scenario5() {
    cout << "\n========== SCENARIO 5: Single Vertex ==========\n";
    Graph g(1);
    g.printGraph();
    g.dijkstra(0);
}

// Scenario 6: Graph with self-loop (should be ignored)
void scenario6() {
    cout << "\n========== SCENARIO 6: With Equal Weight Paths ==========\n";
    Graph g(4);
    g.addEdge(0, 1, 1);
    g.addEdge(0, 2, 1);
    g.addEdge(1, 3, 1);
    g.addEdge(2, 3, 1);

    g.printGraph();
    g.dijkstra(0, 3); // Find path from 0 to 3
}

// Scenario 7: Linear chain
void scenario7() {
    cout << "\n========== SCENARIO 7: Linear Chain ==========\n";
    Graph g(5);
    g.addEdge(0, 1, 2);
    g.addEdge(1, 2, 3);
    g.addEdge(2, 3, 1);
    g.addEdge(3, 4, 4);

    g.printGraph();
    g.dijkstra(0);
}

int main() {
    cout << "=================================================\n";
    cout << "    DIJKSTRA'S ALGORITHM - ALL SCENARIOS\n";
    cout << "=================================================\n";

    scenario1(); // Simple connected graph
    scenario2(); // Disconnected graph
    scenario3(); // Dense graph with multiple paths
    scenario4(); // Directed graph
    scenario5(); // Single vertex
    scenario6(); // Equal weight paths
    scenario7(); // Linear chain

    return 0;
}
```

**Scenario 1: Simple Connected Graph** - Basic weighted graph where all vertices are reachable from the source.

**Scenario 2: Disconnected Graph** - Demonstrates how unreachable vertices are handled with infinite distance.

**Scenario 3: Dense Graph** - Multiple paths between vertices, algorithm finds the optimal one.

**Scenario 4: Directed Graph** - Shows that the algorithm works for directed edges where paths may not be bidirectional.

**Scenario 5: Single Vertex** - Edge case with only one vertex.

**Scenario 6: Equal Weight Paths** - When multiple paths have the same cost, showing early termination to a destination.

**Scenario 7: Linear Chain** - Sequential path where each vertex connects to the next.

## Key Implementation Details

**Priority Queue**: Uses min-heap to efficiently select the vertex with minimum distance (O(log V) per operation).

**Visited Array**: Prevents reprocessing vertices, ensuring each vertex is processed only once.

**Path Reconstruction**: Parent array tracks the previous vertex in the shortest path, allowing full path reconstruction.

**Early Termination**: Can stop once the destination is reached if you're only interested in a single target.

**Handling Disconnected Vertices**: Unreachable vertices maintain their infinite distance value.

The code is ready to compile and run, demonstrating all common scenarios you'll encounter with Dijkstra's algorithm!

# Dijkstra's vs Prim's Algorithm - Key Differences

Both algorithms use similar greedy approaches with priority queues, but they solve **completely different problems**:

## Core Difference

| Aspect           | Dijkstra's Algorithm                             | Prim's Algorithm                                            |
| ---------------- | ------------------------------------------------ | ----------------------------------------------------------- |
| **Purpose**      | Finds shortest paths from source to all vertices | Finds Minimum Spanning Tree (MST)                           |
| **Output**       | Shortest path distances + paths                  | Tree connecting all vertices with minimum total edge weight |
| **Problem Type** | Single-source shortest path                      | Minimum spanning tree                                       |
| **Goal**         | Minimize path length from source                 | Minimize total tree weight                                  |

## Detailed Comparison

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class Graph {
    int V;
    vector<vector<pair<int, int>>> adj;

public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    void addEdge(int u, int v, int weight) {
        adj[u].push_back({v, weight});
        adj[v].push_back({u, weight});
    }

    // DIJKSTRA'S ALGORITHM
    // Goal: Find shortest path from source to all vertices
    // Key: Distance is CUMULATIVE (sum from source)
    void dijkstra(int src) {
        cout << "\n=== DIJKSTRA'S ALGORITHM (Shortest Path) ===\n";

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<int> dist(V, INT_MAX);
        vector<int> parent(V, -1);
        vector<bool> visited(V, false);

        dist[src] = 0;
        pq.push({0, src});

        cout << "\nStep-by-step process:\n";

        while (!pq.empty()) {
            int u = pq.top().second;
            int d = pq.top().first;
            pq.pop();

            if (visited[u]) continue;
            visited[u] = true;

            cout << "Selected vertex " << u << " with distance " << d << "\n";

            // CRITICAL DIFFERENCE: We check dist[u] + weight
            // This is CUMULATIVE distance from source
            for (auto& edge : adj[u]) {
                int v = edge.first;
                int weight = edge.second;

                if (!visited[v] && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight; // Cumulative!
                    parent[v] = u;
                    pq.push({dist[v], v});
                    cout << "  Updated vertex " << v << ": distance = " << dist[v]
                         << " (path distance from source)\n";
                }
            }
        }

        cout << "\nResult - Shortest Paths from vertex " << src << ":\n";
        cout << "Vertex\tDistance\tParent\n";
        for (int i = 0; i < V; i++) {
            cout << i << "\t" << (dist[i] == INT_MAX ? -1 : dist[i])
                 << "\t\t" << parent[i] << "\n";
        }

        int totalPathLength = 0;
        for (int i = 0; i < V; i++) {
            if (dist[i] != INT_MAX) totalPathLength += dist[i];
        }
        cout << "Sum of all shortest paths: " << totalPathLength << "\n";
    }

    // PRIM'S ALGORITHM
    // Goal: Find Minimum Spanning Tree
    // Key: We only care about EDGE WEIGHT (not cumulative)
    void prim(int src) {
        cout << "\n=== PRIM'S ALGORITHM (Minimum Spanning Tree) ===\n";

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<int> key(V, INT_MAX);
        vector<int> parent(V, -1);
        vector<bool> inMST(V, false);

        key[src] = 0;
        pq.push({0, src});

        cout << "\nStep-by-step process:\n";

        while (!pq.empty()) {
            int u = pq.top().second;
            int edgeWeight = pq.top().first;
            pq.pop();

            if (inMST[u]) continue;
            inMST[u] = true;

            cout << "Added vertex " << u << " to MST";
            if (parent[u] != -1) {
                cout << " via edge (" << parent[u] << "->" << u << ") weight=" << edgeWeight;
            }
            cout << "\n";

            // CRITICAL DIFFERENCE: We check only edge weight
            // NOT cumulative distance
            for (auto& edge : adj[u]) {
                int v = edge.first;
                int weight = edge.second;

                if (!inMST[v] && weight < key[v]) {
                    key[v] = weight; // Only edge weight!
                    parent[v] = u;
                    pq.push({key[v], v});
                    cout << "  Updated vertex " << v << ": key = " << key[v]
                         << " (edge weight only)\n";
                }
            }
        }

        cout << "\nResult - Minimum Spanning Tree:\n";
        cout << "Edge\t\tWeight\n";
        int totalWeight = 0;
        for (int i = 1; i < V; i++) {
            if (parent[i] != -1) {
                cout << parent[i] << " - " << i << "\t\t";
                for (auto& edge : adj[parent[i]]) {
                    if (edge.first == i) {
                        cout << edge.second << "\n";
                        totalWeight += edge.second;
                        break;
                    }
                }
            }
        }
        cout << "Total MST weight: " << totalWeight << "\n";
    }

    void printGraph() {
        cout << "\nGraph Structure:\n";
        for (int i = 0; i < V; i++) {
            cout << "Vertex " << i << ": ";
            for (auto& edge : adj[i]) {
                cout << "(" << edge.first << ", w:" << edge.second << ") ";
            }
            cout << "\n";
        }
    }
};

// Example demonstrating the key difference
void demonstrateKeyDifference() {
    cout << "\n================================================\n";
    cout << "EXAMPLE: Shows Critical Difference\n";
    cout << "================================================\n";

    Graph g(4);
    g.addEdge(0, 1, 1);
    g.addEdge(0, 2, 4);
    g.addEdge(1, 2, 2);
    g.addEdge(1, 3, 5);
    g.addEdge(2, 3, 1);

    g.printGraph();

    cout << "\n--- DIJKSTRA: Minimizes TOTAL PATH LENGTH from source ---";
    g.dijkstra(0);

    cout << "\n--- PRIM: Minimizes TOTAL TREE WEIGHT ---";
    g.prim(0);

    cout << "\n\nKEY OBSERVATION:";
    cout << "\n• Dijkstra found path 0->1->2->3 (distance: 1+2+1=4 from source)";
    cout << "\n• Prim might include edge 0->2 (weight 4) directly in MST";
    cout << "\n• Different goals = different selections!\n";
}

// Example showing they can produce different trees
void demonstrateDifferentResults() {
    cout << "\n================================================\n";
    cout << "EXAMPLE 2: Different Tree Structures\n";
    cout << "================================================\n";

    Graph g(5);
    g.addEdge(0, 1, 2);
    g.addEdge(0, 3, 6);
    g.addEdge(1, 2, 3);
    g.addEdge(1, 3, 8);
    g.addEdge(1, 4, 5);
    g.addEdge(2, 4, 7);
    g.addEdge(3, 4, 9);

    g.printGraph();

    g.dijkstra(0);
    g.prim(0);

    cout << "\n\nNOTICE:";
    cout << "\n• Dijkstra: Parent relationships form shortest path tree";
    cout << "\n• Prim: Parent relationships form minimum spanning tree";
    cout << "\n• Same graph, different parent arrays!\n";
}

int main() {
    cout << "========================================================\n";
    cout << "  DIJKSTRA'S vs PRIM'S - THE CRITICAL DIFFERENCE\n";
    cout << "========================================================\n";

    cout << "\n╔════════════════════════════════════════════════════╗";
    cout << "\n║ DIJKSTRA: dist[v] = dist[u] + weight (CUMULATIVE) ║";
    cout << "\n║ PRIM:     key[v]  = weight        (EDGE ONLY)     ║";
    cout << "\n╚════════════════════════════════════════════════════╝\n";

    demonstrateKeyDifference();
    demonstrateDifferentResults();

    cout << "\n\n=== SUMMARY ===\n";
    cout << "┌─────────────────────────────────────────────────────┐\n";
    cout << "│ DIJKSTRA'S                 │ PRIM'S                 │\n";
    cout << "├────────────────────────────┼────────────────────────┤\n";
    cout << "│ Shortest paths from source │ Minimum spanning tree  │\n";
    cout << "│ Cumulative distance        │ Individual edge weight │\n";
    cout << "│ dist[u] + weight < dist[v] │ weight < key[v]        │\n";
    cout << "│ Different paths/distances  │ One connected tree     │\n";
    cout << "│ Directed or undirected     │ Undirected only        │\n";
    cout << "└────────────────────────────┴────────────────────────┘\n";

    return 0;
}
```

## The Critical Difference (The Heart of It)

### **Dijkstra's Algorithm**

```cpp
if (dist[u] + weight < dist[v]) {
    dist[v] = dist[u] + weight;  // CUMULATIVE from source
}
```

- Tracks **cumulative distance** from source
- Finds shortest path: "What's the cheapest way to get from A to B?"

### **Prim's Algorithm**

```cpp
if (weight < key[v]) {
    key[v] = weight;  // Just the EDGE weight
}
```

- Only cares about **individual edge weight**
- Finds MST: "Connect all vertices with minimum total wire"

## Visual Example

Consider this graph:

```
    (1)
 0 ----- 1
 |       |
(4)     (2)
 |       |
 2 ----- 3
    (1)
```

**Dijkstra from vertex 0:**

- Path to vertex 3: 0→1→2→3 (total distance = 1+2+1 = **4**)
- Chooses longer edge (4) later because cumulative path is shorter

**Prim from vertex 0:**

- MST includes edge 0-2 directly (weight **4**)
- Doesn't care about cumulative; just wants minimum total tree weight

## When to Use Which?

**Use Dijkstra when:**

- Finding GPS routes (shortest path)
- Network routing (least cost path)
- Game AI pathfinding

**Use Prim when:**

- Laying cables/pipes (connect all with minimum material)
- Network design (connect all nodes cheaply)
- Clustering algorithms

The similarity in code structure can be confusing, but remembering **cumulative vs. edge-only** is the key!

https://www.geeksforgeeks.org/problems/lru-cache/1

```cpp
class DLNode{
    public:
        int key;
        int data;
        DLNode *prev;
        DLNode *next;
    DLNode(int key,int data,DLNode *prev,DLNode *next){
        this->data=data;
        this->key=key;
        this->prev=prev;
        this->next=next;
    }
};

class LRUCache {
    int cap;
    unordered_map<int,DLNode*> lookup;
    DLNode *head=nullptr,*tail=nullptr;
  public:
    LRUCache(int cap) {
        this->cap=cap;
    }
    ~LRUCache(){
        while(head){
            DLNode *nxt=head->next;
            delete head;
            head=nxt;
        }
    }

    int get(int key) {
        auto i=lookup.find(key);
        if(i==lookup.end()) return -1;

        DLNode *n=i->second;

        moveNodeToEnd(n);

        return n->data;
    }


    void put(int key, int value) {
        if(update(key,value)) return;

        if(lookup.size()>=cap) removeFirst();

        DLNode *n=new DLNode(key,value,tail,nullptr);
        lookup[key]=n;
        if(!head) head=tail=n;
        else tail=tail->next=n;
    }

  private:
    DLNode* update(int key,int v){
        auto i=lookup.find(key);
        if(i==lookup.end()) return nullptr;
        DLNode *n=i->second;
        n->data=v;

        moveNodeToEnd(n);
        return n;
    }
    void moveNodeToEnd(DLNode *n){
        if(!n || !n->next) return;

        if(!n->prev){
            head=n->next;
            head->prev=nullptr;
        }else{
            n->prev->next=n->next;
            n->next->prev=n->prev;
        }
        n->prev=tail;
        n->next=nullptr;
        tail=tail->next=n;
    }
    void removeFirst(){
        if(!lookup.size()) return;
        DLNode *nxt=head->next;
        lookup.erase(head->key);
        delete head;
        head=nxt;
        if(head) head->prev=nullptr;
        else tail=nullptr;
    }
};
```

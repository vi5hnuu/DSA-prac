https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-LinkedList/problem/merge-k-sorted-linked-lists

```cpp
/*
class Node {
  public:
    int data;
    Node* next;

    Node(int x){
        data = x;
        next = NULL;
    }
};
*/

class Solution {
  public:
    Node* mergeKLists(vector<Node*>& arr) {
        Node *merged=nullptr;
        for(auto &ll:arr){
            merged=mergeSortedLL(merged,ll);
        }
        return merged;
    }
  private:
    Node* mergeSortedLL(Node* x,Node* y){
        if(!x || !y) return x ? x : y;

        Node *m=nullptr,*mt=nullptr;

        while(x || y){
            Node *node=(x && y) ? (x->data<y->data ? x : y):(x ? x : y);
            if(node==x) x=x->next;
            else y=y->next;

            if(!mt) m=mt=node;
            else mt=mt->next=node;
        }
        return m;
    }
};
```

```cpp
/*
class Node {
  public:
    int data;
    Node* next;

    Node(int x){
        data = x;
        next = NULL;
    }
};
*/

class MinNodeCmp {
public:
    bool operator()(Node* x, Node* y) {
        return x->data > y->data; // note: for min-heap in priority_queue, you reverse the comparison
    }
};

class Solution {
  public:
    Node* mergeKLists(vector<Node*>& arr) {
        priority_queue<Node*, vector<Node*>, MinNodeCmp> heads(arr.begin(), arr.end());

        Node *nHead=nullptr,*tail=nullptr;
        while(!heads.empty()){
            Node *sm=heads.top();
            heads.pop();
            if(!tail) tail=nHead=sm;
            else tail=tail->next=sm;
            if(sm->next) heads.push(sm->next);
        }
        return nHead;
    }
};
```

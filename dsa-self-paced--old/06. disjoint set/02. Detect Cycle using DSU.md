https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-DisjointSet/problem/detect-cycle-using-dsu

```cpp
class DS{
  private:
    int n;
    vector<int> par;
    vector<int> rank;
  public:
    DS(int n){
        this->n=n;
        rank.resize(n,0);
        par.resize(n,-1);
        for(int i=0;i<n;i++) par[i]=i;
    }

    int find(int x){
        if(x>=n) throw "invalid value";
        if(par[x]==x) return x;
        return (par[x]=find(par[x]));
    }

    bool allInSet(initializer_list<int> vals){
        int par=-1;
        for(auto x:vals){
            int px=find(x);
            if(par!=-1 && par!=px) return false;
            par=px;
        }
        return true;
    }

    void unionn(int x,int y){
        if(x>=n || y>=n) throw "invalid value";
        int px=find(x);
        int py=find(y);
        if(px==py) return;

        if (rank[px] < rank[py]) {
            par[px] = py;
        } else if (rank[px] > rank[py]) {
            par[py] = px;
        } else {
            par[py] = px;
            rank[px]++;
        }
    }
};
class Solution {
  public:
    // Function to detect cycle using DSU in an undirected graph.
    int detectCycle(int V, vector<int> adj[]) {
        DS ds(V);
        vector<vector<bool>> visited(V,vector<bool>(V,false));
        for(int i=0;i<V;i++){
            for(int neighbour:adj[i]){
                if(visited[i][neighbour]) continue;
                visited[neighbour][i]=visited[i][neighbour]=true;
                if(ds.allInSet({i,neighbour})) return true;
                else ds.unionn(i,neighbour);
            }
        }
        return false;
    }
};
```

```cpp
class DS{
  private:
    int n;
    vector<int> par;
    vector<int> rank;
  public:
    DS(int n){
        this->n=n;
        rank.resize(n,0);
        par.resize(n,-1);
        for(int i=0;i<n;i++) par[i]=i;
    }

    int find(int x){
        if(x>=n) throw "invalid value";
        if(par[x]==x) return x;
        return (par[x]=find(par[x]));
    }

    bool allInSet(initializer_list<int> vals){
        int par=-1;
        for(auto x:vals){
            int px=find(x);
            if(par!=-1 && par!=px) return false;
            par=px;
        }
        return true;
    }

    void unionn(int x,int y){
        if(x>=n || y>=n) throw "invalid value";
        int px=find(x);
        int py=find(y);
        if(px==py) return;

        if (rank[px] < rank[py]) {
            par[px] = py;
        } else if (rank[px] > rank[py]) {
            par[py] = px;
        } else {
            par[py] = px;
            rank[px]++;
        }
    }
};
class Solution {
  public:
    // Function to detect cycle using DSU in an undirected graph.
    int detectCycle(int V, vector<int> adj[]) {
        DS ds(V);
        for(int i=0;i<V;i++){
            for(int neighbour:adj[i]){
                if(i>neighbour) continue;
                if(ds.allInSet({i,neighbour})) return true;
                else ds.unionn(i,neighbour);
            }
        }
        return false;
    }
};
```

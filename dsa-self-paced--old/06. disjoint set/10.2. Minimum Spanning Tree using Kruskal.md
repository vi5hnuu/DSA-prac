https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-DisjointSet/problem/minimum-spanning-tree3233

```cpp
// User function Template for C++

/**
 *  ith value in adj vector contains information between the node connected to it and
 * weight between them. Example. for a value 2 3 1, Node 2 and Node 3 has weight 1.
 * adj[2] = {3,1} and adj[3] = {2,1}. n -> number of nodes m -> total number of edges
 *  return the mst value
 */

// Function to find the minimum spanning tree value using Kruskal.
class DisjointSet{
    private:
        vector<int> rank;
        vector<int> parent;
    public:
        DisjointSet(int n){
            rank.resize(n,0);
            parent.resize(n);

            // Initially, each element is representative of its own set
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }
        int find(int x){
            if(parent[x]==x) return x;
            //compression of nodes
            return (parent[x]=find(parent[x]));
        }
        void unite(int x,int y){
            int px=find(x);
            int py=find(y);
            if(px==py) return;

            //compression by rank
            if(rank[px]<rank[py]){
                parent[px]=py;
            }else if(rank[px]>rank[py]){
                parent[py]=px;
            }else{
                parent[px]=py;
                rank[px]++;
            }
        }
};
class WeighAscCmp{
    public:
        bool operator()(const tuple<int,int,long long> &edgex,const tuple<int,int,long long> &edgey) const{
            return get<2>(edgex) < get<2>(edgey);
        }
};
long long int kruskalDSU(vector<pair<int, long long int>> adj[], int n, int m) {
    vector<tuple<int,int,long long>> edges;
    for(int i=0;i<n;i++){
        for(auto neighbour:adj[i]){
            if(i>=neighbour.first) continue;
            edges.push_back({i,neighbour.first,neighbour.second});
        }
    }

    sort(edges.begin(),edges.end(),WeighAscCmp());

    DisjointSet ds(n+1);
    int pickCount=0;
    long long int mstW=0;
    for(auto edge:edges){
        int u=get<0>(edge);
        int v=get<1>(edge);
        int w=get<2>(edge);
        if(u>=v) continue;
        int px=ds.find(u);
        int py=ds.find(v);
        if(px==py) continue;
        pickCount++;
        ds.unite(px,py);
        mstW+=w;
        if(pickCount==n-1) break;
    }
    return mstW;
}
```

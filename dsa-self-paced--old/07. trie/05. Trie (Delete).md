https://www.geeksforgeeks.org/problems/trie-delete/1

```cpp
/*Complete the function below
Node is as follows:
struct trie_node
{
    int value; // non zero if leaf
    trie_node_t *children[ALPHABET_SIZE];
};*/
class Solution {
  public:
    void deleteKey(trie_node_t *root, char key[]) {
       deleteWord(root,key,strlen(key));
    }
  private:
    bool deleteWord(trie_node_t *root, char key[],int sz,int i=0){
        if(i>=sz) return false;
        int idx=key[i]-'a';
        trie_node_t* node=root->children[idx];
        if(!node) return false;
        if(i==sz-1){
            if(node->value){
                if(hasChilds(node)){
                    node->value=0;
                }else{
                    delete node;
                    root->children[idx]=nullptr;
                    return true;
                }
            }
            return false;//not a word
        }

        if(deleteWord(node,key,sz,i+1)){//bottom call said i deleted the node now u also try to delete if possible
            if(node->value  || hasChilds(node)){//forms new word or has another word go through it
                return false;
            }
            delete node;
            root->children[idx]=nullptr;
            return true;
        }
        return false;
    }
    bool hasChilds(trie_node_t *root){
        for(int i=0;i<26;i++){
            if(root->children[i]!=nullptr) return true;
        }
        return false;
    }
};
```

```cpp
/*Complete the function below
Node is as follows:
struct trie_node
{
    int value; // non zero if leaf
    trie_node_t *children[ALPHABET_SIZE];
};*/
class Solution {
  public:
    void deleteKey(trie_node_t *root, char key[]) {
        int sz=strlen(key);
        if(!sz) return;

        int idx=key[0]-'a';
        root->children[idx]=deleteWord(root->children[idx],key,sz);
    }
  private:
    trie_node_t* deleteWord(trie_node_t *root, char key[],int sz,int i=0){
        if(i>=sz || !root) return root;
        if(i==sz-1){
            if(root->value){//is word
                if(hasChilds(root)){//but has childs
                    root->value=0;
                    return root;
                }else{
                    delete root;
                    return nullptr;
                }
            }
            return root;//is not a word
        }

        int idx=key[i+1]-'a';
        root->children[idx]=deleteWord(root->children[idx],key,sz,i+1);
        if(!root->children[idx]){
            if(root->value  || hasChilds(root)){//forms new word or has another word go through it
                return root;
            }
            delete root;
            return nullptr;
        }
        return root;
    }
    bool hasChilds(trie_node_t *root){
        for(int i=0;i<26;i++){
            if(root->children[i]!=nullptr) return true;
        }
        return false;
    }
};
```

https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Trie/problem/camel-case04234120

```cpp
// User function template for C++
#include<bits/stdc++.h>;
using namespace std;

class TrieNode{
  public:
    bool isCaps;
    vector<string> abbr;//duplication eg. HelloWorld HelloWorld HelloWorld HelloWorld HelloGreat -> HW,HW,HW,HW,HG <- 4 HW,HG at this node
    vector<TrieNode*> *childs;

    TrieNode(){
        this->isCaps=false;
        this->abbr=vector<string>();
        childs=new vector<TrieNode*>(26,nullptr);
    }

    ~TrieNode(){
        delete childs;
    }
};
class Trie {
  TrieNode *root;
  size_t  maxWordLen=0;
  public:

    Trie() {
        root=new TrieNode();
    }

    ~Trie(){
        burnTrie(root);
    }

    void insert(string &word) {
        maxWordLen=max(maxWordLen,word.length());

        int sz=word.length();
        int i=0;
        if(i>=sz) return;
        TrieNode* rt=root;
        string abbriviation="";
        while(i<sz){
            const bool isCaps=word[i]>='A' && word[i]<='Z';
            if(isCaps) abbriviation+=word[i];
            char ch=word[i]-(isCaps ? 'A':'a');
            if(((*rt->childs)[ch])!=NULL){
                rt=(*rt->childs)[ch];
            }else{
                rt=(*rt->childs)[ch]=new TrieNode();
            }
            rt->isCaps=isCaps;
            i++;
        }
        rt->abbr.push_back(abbriviation);//means this is a word
    }

    void fillPattern(vector<pair<string,string>> &patternMatch,string &word){
        int sz=word.length();
        if(sz>maxWordLen) return;

        string s;
        s.reserve(maxWordLen);
        fillPattern(root,patternMatch,word,s,0);
    }

  private:
    bool startsWith(string s,string prefix){
        return s.length() >= prefix.length() && s.substr(0, prefix.length()) == prefix;
    }
    void fillPattern(TrieNode *root,vector<pair<string,string>> &patternMatch,string &word,string &match,int i=0){
        if(!root) return;
        int sz=word.length();

        for(int k=0;k<26;k++){
            auto child=(*root->childs)[k];
            if(!child) continue;
            char ch=(child->isCaps) ? k+'A':k+'a';
            if(i<sz && ch!=word[i] && child->isCaps) continue;//skip this branch
            match.push_back(ch);
            fillPattern(child,patternMatch,word,match,i<sz && ch==word[i] ? i+1:i);
            match.pop_back();
        }
        for(auto abbr:root->abbr){
            if(startsWith(abbr,word)) patternMatch.push_back({abbr,match});
        }
    }
    void burnTrie(TrieNode *root){
        if(!root) return;
        for(TrieNode* child:*root->childs){
            if(child) burnTrie(child);
        }
        delete root;
    }
};

// dict : given set of strings
// pattern : given pattern
class Solution {
  public:
    // Function to print all words in the CamelCase dictionary
    // that matches with a given pattern.
    void findAllWords(vector<string> dict, string pattern) {

        Trie tr;
        for(auto n:dict) tr.insert(n);
        vector<pair<string,string>> patternMatch;
        tr.fillPattern(patternMatch,pattern);
        sort(patternMatch.begin(),patternMatch.end());
        if(patternMatch.empty()) cout<<"No match found";

        for(auto match:patternMatch) cout<<match.second<<" ";
    }
};
```

```cpp
// User function template for C++
#include<bits/stdc++.h>;
using namespace std;

class TrieNode{
  public:
    bool isCaps;
    vector<string> abbr;
    TrieNode* childs[26]={nullptr};

    TrieNode(){
        this->isCaps=false;
        this->abbr=vector<string>();
    }
};
class Trie {
  TrieNode *root;
  size_t  maxWordLen=0;
  public:

    Trie() {
        root=new TrieNode();
    }

    ~Trie(){
        burnTrie(root);
    }

    void insert(string &word) {
        maxWordLen=max(maxWordLen,word.length());

        int sz=word.length();
        int i=0;
        if(i>=sz) return;
        TrieNode* rt=root;
        string abbriviation="";
        while(i<sz){
            const bool isCaps=word[i]>='A' && word[i]<='Z';
            if(isCaps) abbriviation+=word[i];
            char ch=word[i]-(isCaps ? 'A':'a');
            if(((rt->childs)[ch])!=NULL){
                rt=(rt->childs)[ch];
            }else{
                rt=(rt->childs)[ch]=new TrieNode();
            }
            rt->isCaps=isCaps;
            i++;
        }
        rt->abbr.push_back(abbriviation);//means this is a word
    }

    void fillPattern(vector<pair<string,string>> &patternMatch,string &word){
        int sz=word.length();
        if(sz>maxWordLen) return;

        string s;
        s.reserve(maxWordLen);
        fillPattern(root,patternMatch,word,s,0);
    }

  private:
    bool startsWith(string s,string prefix){
        return s.length() >= prefix.length() && s.substr(0, prefix.length()) == prefix;
    }
    void fillPattern(TrieNode *root,vector<pair<string,string>> &patternMatch,string &word,string &match,int i=0){
        if(!root) return;
        int sz=word.length();

        for(int k=0;k<26;k++){
            auto child=(root->childs)[k];
            if(!child) continue;
            char ch=(child->isCaps) ? k+'A':k+'a';
            if(i<sz && ch!=word[i] && child->isCaps) continue;//skip this branch
            match.push_back(ch);
            fillPattern(child,patternMatch,word,match,i<sz && ch==word[i] ? i+1:i);
            match.pop_back();
        }
        for(auto abbr:root->abbr){
            if(startsWith(abbr,word)) patternMatch.push_back({abbr,match});
        }
    }
    void burnTrie(TrieNode *root){
        if(!root) return;
        for(int i=0;i<26;i++){
            auto child=(root->childs)[i];
            if(child) burnTrie(child);
        }
        delete root;
    }
};

// dict : given set of strings
// pattern : given pattern
class Solution {
  public:
    // Function to print all words in the CamelCase dictionary
    // that matches with a given pattern.
    void findAllWords(vector<string> dict, string pattern) {

        Trie tr;
        for(auto n:dict) tr.insert(n);
        vector<pair<string,string>> patternMatch;
        tr.fillPattern(patternMatch,pattern);
        sort(patternMatch.begin(),patternMatch.end());
        if(patternMatch.empty()) cout<<"No match found";

        for(auto match:patternMatch) cout<<match.second<<" ";
    }
};
```

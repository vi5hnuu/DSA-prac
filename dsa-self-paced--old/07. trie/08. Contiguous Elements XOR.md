https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Trie/problem/contiguous-elements-xor4151

### TLE [how to improve : can we reduce the prefixXor checks]

```cpp
// User function template for C++

// arr : given array
// n : size of the given array

class Solution {
  public:
    // Function to return maximum XOR value.
    int maxSubarrayXOR(int arr[], int n) {
        vector<int> prefixXor(n,0);

        for(int i=0;i<n;i++){
            prefixXor[i]= (i>0 ? prefixXor[i-1]:0)^arr[i];
        }

        int mxXor=0;
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int cXor=prefixXor[j] ^ (i>0 ? prefixXor[i-1]:0);
                mxXor=max(mxXor,cXor);
            }
        }
        return mxXor;
    }
};
```

```cpp
// User function template for C++

// arr : given array
// n : size of the given array
class TrieNode{
  public:
    TrieNode* childs[2]={nullptr};
    TrieNode(){}
};

class Trie {
  TrieNode *root;
  public:

    Trie() {
        root=new TrieNode();
    }

    ~Trie(){
        burnTrie(root);
    }

    void insert(int n) {
        TrieNode* rt=root;
        for(int i=31;i>=0;i--){
            int bit=(n>>i)&1;
            if(rt->childs[bit]) rt=rt->childs[bit];
            else rt=rt->childs[bit]=new TrieNode();
        }
    }
    int maxXor(int n) {
        TrieNode* rt=root;
        int mxX=0;
        for(int i=31;i>=0;i--){
            int bit=(n>>i)&1;
            int oppsiteBit=bit^1;

            if(rt->childs[oppsiteBit]){
                rt=rt->childs[oppsiteBit];
                mxX|=(1<<i);//opposite bit...make it 1
            }else{
                rt=rt->childs[bit];
            }
        }
        return mxX;
    }
  private:
    void burnTrie(TrieNode *root){
        if(!root) return;
        for(int i=0;i<2;i++) burnTrie(root->childs[i]);
        delete root;
    }
};
class Solution {
  public:
    // Function to return maximum XOR value.
    int maxSubarrayXOR(int arr[], int n) {
        Trie trie;
        trie.insert(0);

        int prefixXor=0;
        int mxXor=0;

        for(int i=0;i<n;i++){
            prefixXor^=arr[i];
            mxXor=max(mxXor,trie.maxXor(prefixXor));//trie has all previous prefix xors, find one that gives max xor with prefixXor
            trie.insert(prefixXor);
        }
        return mxXor;
    }
};
```

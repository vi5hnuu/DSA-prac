https://www.geeksforgeeks.org/problems/gcd-of-two-numbers3459/1

### TLE

```cpp
// User function Template for C++
class Solution {
  public:
    int trailingZeroes(int n) {
        int total5s=0;
        for(int i=5;i<=n;i*=5){
            total5s+=n/i;
        }
        return total5s;
    }
};
```

### OR

```cpp
class Solution {
  public:
    int gcd(int a, int b) {
        while(a && b){
            if(a<=b) b=b%a;
            else a=a%b;
        }
        return max(a,b);
    }
};
```

### OR

```cpp
class Solution {
  public:
    int gcd(int a, int b) {
        if(!a || !b) return max(a,b);
        if(a>b) swap(a,b);
        return gcd(a,b%a);
    }
};
```

### OR

```cpp
class Solution {
  public:
    int gcd(int a, int b) {
        if(!a || !b) return max(a,b);
        return gcd(b%a,a);
    }
};
```

### OR

```cpp
class Solution {
  public:
    int gcd(int a, int b) {
        if(!a || !b) return max(a,b);
        return a>b ? gcd(a-b,b) : gcd(b-a,a);
    }
};
```

# Euclidean Algorithm Explained

The Euclidean algorithm is an efficient method for finding the **greatest common divisor (GCD)** of two numbers. Let me walk you through it with a concrete example.

## The Key Idea

The algorithm is based on this principle: **GCD(a, b) = GCD(b, a mod b)**

In other words, the GCD of two numbers is the same as the GCD of the smaller number and the remainder when dividing the larger by the smaller.

## Example: Find GCD(48, 18)

Let me show you step by step:

**Step 1:** Start with 48 and 18

- Divide: 48 ÷ 18 = 2 remainder 12
- So: 48 = 18 × 2 + 12
- Therefore: GCD(48, 18) = GCD(18, 12)

**Step 2:** Now work with 18 and 12

- Divide: 18 ÷ 12 = 1 remainder 6
- So: 18 = 12 × 1 + 6
- Therefore: GCD(18, 12) = GCD(12, 6)

**Step 3:** Now work with 12 and 6

- Divide: 12 ÷ 6 = 2 remainder 0
- So: 12 = 6 × 2 + 0
- Therefore: GCD(12, 6) = GCD(6, 0)

**Step 4:** When we reach 0, we stop

- GCD(6, 0) = **6**

So **GCD(48, 18) = 6**

## Why This Works

At each step, any number that divides both a and b must also divide the remainder (a mod b). By repeatedly replacing the larger number with the remainder, we eventually reach 0, and the last non-zero remainder is the GCD.

## The Algorithm in Simple Terms

1. Divide the larger number by the smaller number
2. Replace the larger number with the smaller number
3. Replace the smaller number with the remainder
4. Repeat until the remainder is 0
5. The last non-zero remainder is your GCD

This is remarkably efficient—even for very large numbers, it finds the GCD quickly!

Let me prove **why GCD(a, b) = GCD(b, a mod b)**.

## The Core Proof

Let's say we have two numbers **a** and **b** where a ≥ b.

When we divide a by b, we can write:
**a = bq + r**

where:

- q is the quotient
- r is the remainder (this is "a mod b")
- 0 ≤ r < b

Now I need to prove that **GCD(a, b) = GCD(b, r)**

## Proof in Two Directions

### Direction 1: Any common divisor of (a, b) is also a common divisor of (b, r)

Let's say **d** divides both **a** and **b**.

This means:

- a = d × m (for some integer m)
- b = d × n (for some integer n)

Now look at the remainder r:

- r = a - bq
- r = (d × m) - (d × n) × q
- r = d × (m - nq)

This shows **d divides r** too! So any common divisor of (a, b) is also a common divisor of (b, r).

### Direction 2: Any common divisor of (b, r) is also a common divisor of (a, b)

Let's say **d** divides both **b** and **r**.

This means:

- b = d × n (for some integer n)
- r = d × k (for some integer k)

Now look at a:

- a = bq + r
- a = (d × n) × q + (d × k)
- a = d × (nq + k)

This shows **d divides a** too! So any common divisor of (b, r) is also a common divisor of (a, b).

## Conclusion

Since (a, b) and (b, r) have **exactly the same set of common divisors**, they must have the same **greatest** common divisor!

Therefore: **GCD(a, b) = GCD(b, r) = GCD(b, a mod b)** ✓

## Intuitive Understanding

Think of it this way: when you write a = bq + r, you're just rearranging the same "building blocks." Any number that evenly divides into a and b must also divide into what's "left over" (the remainder r), and vice versa. The GCD is just asking "what's the biggest building block?" - and that doesn't change when we rearrange the equation.

### Another variant of the Euclidean algorithm, often called the **subtraction-based Euclidean algorithm**.

## The Claim

**GCD(a, b) = GCD(b - a, a)** where b > a

## Why This Is True

Let me prove it using the same approach as before.

### Direction 1: Any common divisor of (a, b) divides (b - a, a)

Let's say **d** divides both **a** and **b**.

This means:

- a = d × m (for some integer m)
- b = d × n (for some integer n)

Now look at (b - a):

- b - a = (d × n) - (d × m)
- b - a = d × (n - m)

So **d divides (b - a)** too! Any common divisor of (a, b) is also a common divisor of (b - a, a).

### Direction 2: Any common divisor of (b - a, a) divides (a, b)

Let's say **d** divides both **(b - a)** and **a**.

This means:

- a = d × m (for some integer m)
- b - a = d × k (for some integer k)

Now look at b:

- b = a + (b - a)
- b = (d × m) + (d × k)
- b = d × (m + k)

So **d divides b** too! Any common divisor of (b - a, a) is also a common divisor of (a, b).

## Conclusion

Since (a, b) and (b - a, a) have the same set of common divisors, they have the same GCD!

**GCD(a, b) = GCD(b - a, a)** ✓

## Example: GCD(48, 18) using subtraction

- GCD(48, 18) = GCD(30, 18) [48 - 18 = 30]
- GCD(30, 18) = GCD(12, 18) [30 - 18 = 12]
- GCD(18, 12) = GCD(6, 12) [18 - 12 = 6]
- GCD(12, 6) = GCD(6, 6) [12 - 6 = 6]
- GCD(6, 6) = GCD(0, 6) = **6**

## Comparison: Subtraction vs Division (Modulo)

- **Subtraction method**: Simpler to understand, but slower (takes more steps)
- **Division method**: More efficient (fewer steps), which is why it's more commonly used

The division-based algorithm is essentially doing multiple subtractions at once! When we compute 48 mod 18, we're really doing 48 - 18 - 18 = 12 in one step instead of two.

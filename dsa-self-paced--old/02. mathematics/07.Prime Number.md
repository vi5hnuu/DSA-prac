https://www.geeksforgeeks.org/problems/prime-number2314/1

```cpp
class Solution {
  public:
    bool isPrime(int n) {
        if(n<=1) return false;
        if(n==2 || n==3) return true;
        for(int i=2;i<n;i++){
            if(n%i==0) return false;
        }
        return true;
    }
};
```

### OR

```cpp
class Solution {
  public:
    bool isPrime(int n) {
        if(n<=1) return false;
        if(n==2 || n==3) return true;
        for(int i=2;i*i<=n;i++){
            if(n%i==0) return false;
        }
        return true;
    }
};
```

### OR

```cpp
class Solution {
  public:
    bool isPrime(int n) {
        if(n<=1) return false;
        if(n==2 || n==3) return true;
        if(n%2==0 || n%3==0) return false;

        for(int i=5;i*i<=n;i+=6){
            if(n%i==0 || n%(i+2)==0) return false;
        }
        return true;
    }
};
```

## Let's break down each solution and explain the logic and optimizations.

## Solution 1: Brute Force

```cpp
for(int i=2;i<n;i++){
    if(n%i==0) return false;
}
```

### Logic

- Checks **every number** from 2 to n-1
- If any number divides n evenly, n is not prime

### Time Complexity: **O(n)**

### Why it works

A prime number has no divisors except 1 and itself. So we check all possible divisors.

### Problem

Very slow! For n = 1,000,000, we check 999,998 numbers. Wasteful!

---

## Solution 2: Square Root Optimization

```cpp
for(int i=2;i*i<=n;i++){
    if(n%i==0) return false;
}
```

### Logic

- Only checks divisors up to **√n**
- Much faster than checking all the way to n

### Time Complexity: **O(√n)**

### Why This Works - The Key Insight!

**If n has a divisor greater than √n, it must also have a corresponding divisor less than √n.**

Let me prove this:

- Suppose n = a × b where a > √n
- Then b = n/a
- Since a > √n, we have: b = n/a < n/√n = √n
- So b < √n

**Example:** n = 36

- Divisor pairs: (2, 18), (3, 12), (4, 9), (6, 6)
- √36 = 6
- Notice: in each pair, one number ≤ 6 and one ≥ 6
- If we check up to 6, we'll find all divisors!

So we only need to check up to √n. If there's no divisor ≤ √n, there's no divisor at all!

---

## Solution 3: The 6k ± 1 Optimization

```cpp
if(n%2==0 || n%3==0) return false;
for(int i=5;i*i<=n;i+=6){
    if(n%i==0 || n%(i+2)==0) return false;
}
```

### Logic

This uses a **mathematical pattern**: all primes > 3 are of the form **6k ± 1**

### Time Complexity: **O(√n/3)** - About 3× faster than Solution 2!

### Why This Works - The Pattern Discovery!

Let's look at any integer modulo 6. It can only be:

- 6k + 0 = divisible by 6 (divisible by 2 and 3) ❌
- 6k + 1 = might be prime ✓
- 6k + 2 = divisible by 2 ❌
- 6k + 3 = divisible by 3 ❌
- 6k + 4 = divisible by 2 ❌
- 6k + 5 = 6k + (6-1) = 6(k+1) - 1 = might be prime ✓

**All primes except 2 and 3 must be of the form 6k±1!**

### Step-by-Step Breakdown

**Step 1:** Handle 2 and 3 explicitly

```cpp
if(n%2==0 || n%3==0) return false;
```

Now we know n is not divisible by 2 or 3.

**Step 2:** Check only 6k±1 candidates

```cpp
for(int i=5;i*i<=n;i+=6){
    if(n%i==0 || n%(i+2)==0) return false;
}
```

Starting from i=5:

- i=5 checks **5** (which is 6×1-1) and **7** (which is 6×1+1)
- i=11 checks **11** (which is 6×2-1) and **13** (which is 6×2+1)
- i=17 checks **17** (which is 6×3-1) and **19** (which is 6×3+1)
- i=23 checks **23** (which is 6×4-1) and **25** (which is 6×4+1)

We skip 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24... because they're all divisible by 2 or 3!

---

## Visual Comparison

For **n = 100**:

| Solution   | Iterations | Numbers Checked                   |
| ---------- | ---------- | --------------------------------- |
| Solution 1 | 98         | 2,3,4,5,...,99                    |
| Solution 2 | 9          | 2,3,4,5,6,7,8,9,10                |
| Solution 3 | 3          | 5,7,11,13,17,19 (but stops early) |

---

## Example Walkthrough: Is 97 prime?

### Solution 1

Check: 2,3,4,5,...,96 → **95 checks** → Prime!

### Solution 2

Check: 2,3,4,5,6,7,8,9 → **8 checks** (√97 ≈ 9.8) → Prime!

### Solution 3

- Check 2: 97%2 ≠ 0 ✓
- Check 3: 97%3 ≠ 0 ✓
- Loop: i=5: 97%5≠0, 97%7≠0 ✓
- Loop: i=11: 11² = 121 > 97, stop!
- **Only 4 checks** → Prime!

---

## Summary

1. **Solution 1**: Check everything - simple but slow
2. **Solution 2**: Check up to √n - uses the divisor pair insight
3. **Solution 3**: Check only 6k±1 candidates up to √n - uses number theory to skip most checks

Each solution builds on mathematical insights to eliminate unnecessary work!

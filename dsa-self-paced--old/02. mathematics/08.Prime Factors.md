https://www.geeksforgeeks.org/problems/prime-factors5052/1

```cpp
class Solution {
  public:
    vector<int> primeFac(int n) {
        vector<int> primeFactors;

        for(int i=2;i<=n;i++){
            if(n%i==0 && isPrime(i)) primeFactors.push_back(i);
        }
        return primeFactors;
    }
    bool isPrime(int n) {
        if(n<=1) return false;
        if(n==2 || n==3) return true;
        if(n%2==0 || n%3==0) return false;

        for(int i=5;i*i<=n;i+=6){
            if(n%i==0 || n%(i+2)==0) return false;
        }
        return true;
    }
};
```

### OR

```cpp
class Solution {
  public:
    vector<int> primeFac(int n) {
        vector<bool> primes(n+1,true);
        primes[0]=primes[1]=false;
        for(int i=2;i*i<=n;i++){
            if(!primes[i]) continue;
            for(int j=i*i;j<=n;j+=i) primes[j]=false;
        }
        ///////////////////////////////

        vector<int> primeFactors;

        for(int i=2;i<=n;i++){
            if(n%i==0 && primes[i]) primeFactors.push_back(i);
        }
        return primeFactors;
    }
};
```

# Sieve of Eratosthenes

The **Sieve of Eratosthenes** is an ancient algorithm (from 200 BC!) for finding **all prime numbers** up to a given limit **n**. It's much more efficient than checking each number individually.

## The Core Idea

Instead of checking if each number is prime, we **eliminate all composite numbers** by marking multiples of known primes.

Think of it like a filtering process - we "sieve out" the composites, and what remains are the primes!

## The Algorithm Step-by-Step

Let's find all primes up to **n = 30**:

### Step 1: Create a list of numbers from 2 to n

```
2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
```

Assume all are prime initially.

### Step 2: Start with the first number (2)

- 2 is prime! ✓
- Mark all **multiples of 2** (except 2 itself) as composite:

```
2  3  ✗  5  ✗  7  ✗  9  ✗  11 ✗  13 ✗  15 ✗  17 ✗  19 ✗  21 ✗  23 ✗  25 ✗  27 ✗  29 ✗
   (4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30 are eliminated)
```

### Step 3: Move to next unmarked number (3)

- 3 is prime! ✓
- Mark all **multiples of 3** (except 3 itself) as composite:

```
2  3  ✗  5  ✗  7  ✗  ✗  ✗  11 ✗  13 ✗  ✗  ✗  17 ✗  19 ✗  ✗  ✗  23 ✗  25 ✗  ✗  ✗  29 ✗
   (9, 15, 21, 27 newly eliminated - others already marked)
```

### Step 4: Move to next unmarked number (5)

- 5 is prime! ✓
- Mark all **multiples of 5** (except 5 itself) as composite:

```
2  3  ✗  5  ✗  7  ✗  ✗  ✗  11 ✗  13 ✗  ✗  ✗  17 ✗  19 ✗  ✗  ✗  23 ✗  ✗  ✗  ✗  ✗  29 ✗
   (25 newly eliminated - others already marked)
```

### Step 5: Move to next unmarked number (7)

- 7 is prime! ✓
- Mark multiples of 7... but wait! 7×2=14, 7×3=21, 7×4=28 are already marked
- Actually, we can **stop here** because 7² = 49 > 30

### Result: All unmarked numbers are prime!

```
Primes: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29
```

---

## Why Stop at √n?

**Key Insight:** We only need to sieve with primes up to √n.

**Why?** If a number k ≤ n is composite, it must have a prime factor p ≤ √k ≤ √n.

So by the time we've sieved with all primes up to √n, all composites have already been marked!

---

## C++ Implementation

```cpp
class Solution {
public:
    vector<int> sieveOfEratosthenes(int n) {
        // Step 1: Create boolean array, assume all are prime
        vector<bool> isPrime(n + 1, true);
        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime

        // Step 2: Sieve process
        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                // Mark all multiples of i as composite
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // Step 3: Collect all primes
        vector<int> primes;
        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) {
                primes.push_back(i);
            }
        }

        return primes;
    }
};
```

---

## Important Optimizations in the Code

### Optimization 1: Start from i²

```cpp
for (int j = i * i; j <= n; j += i)
```

**Why start from i²?**

- All smaller multiples (2i, 3i, ..., (i-1)i) have already been marked by smaller primes!
- Example: When i=5, we start from 25, not 10
  - 10 = 2×5 (already marked by 2)
  - 15 = 3×5 (already marked by 3)
  - 20 = 4×5 (already marked by 2)
  - 25 = 5×5 (first unmarked multiple!)

### Optimization 2: Only check up to √n

```cpp
for (int i = 2; i * i <= n; i++)
```

## Visual Example: Finding Primes up to 50

```
Initial: 2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50

After 2: 2  3  ✗  5  ✗  7  ✗  9  ✗  11 ✗  13 ✗  15 ✗  17 ✗  19 ✗  21 ✗  23 ✗  25 ✗  27 ✗  29 ✗  31 ✗  33 ✗  35 ✗  37 ✗  39 ✗  41 ✗  43 ✗  45 ✗  47 ✗  49 ✗

After 3: 2  3  ✗  5  ✗  7  ✗  ✗  ✗  11 ✗  13 ✗  ✗  ✗  17 ✗  19 ✗  ✗  ✗  23 ✗  25 ✗  ✗  ✗  29 ✗  31 ✗  ✗  ✗  35 ✗  37 ✗  ✗  ✗  41 ✗  43 ✗  ✗  ✗  47 ✗  49 ✗

After 5: 2  3  ✗  5  ✗  7  ✗  ✗  ✗  11 ✗  13 ✗  ✗  ✗  17 ✗  19 ✗  ✗  ✗  23 ✗  ✗  ✗  ✗  ✗  29 ✗  31 ✗  ✗  ✗  ✗  ✗  37 ✗  ✗  ✗  41 ✗  43 ✗  ✗  ✗  47 ✗  ✗  ✗

After 7: 2  3  ✗  5  ✗  7  ✗  ✗  ✗  11 ✗  13 ✗  ✗  ✗  17 ✗  19 ✗  ✗  ✗  23 ✗  ✗  ✗  ✗  ✗  29 ✗  31 ✗  ✗  ✗  ✗  ✗  37 ✗  ✗  ✗  41 ✗  43 ✗  ✗  ✗  47 ✗  ✗  ✗

Stop! (7² = 49 ≤ 50, but next prime 11² = 121 > 50)

Primes: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47
```

---

## Time Complexity Analysis

**Time Complexity: O(n log log n)**

This is **much faster** than checking each number individually:

- Individual checks: O(n√n)
- Sieve: O(n log log n)

For n = 1,000,000:

- Individual: ~1 billion operations
- Sieve: ~15 million operations

**That's about 60× faster!**

---

## Space Complexity

**O(n)** - We need an array of size n to track which numbers are prime.

---

## When to Use Sieve

✅ **Use Sieve when:**

- You need **multiple primes** or **all primes up to n**
- You need to check primality of many numbers in a range
- Example: "Find all primes between 1 and 1,000,000"

❌ **Don't use Sieve when:**

- You only need to check if **one or two numbers** are prime
- Memory is limited (Sieve uses O(n) space)
- Example: "Is 1,000,000,007 prime?" - use optimized primality test instead

---

## Summary

The Sieve of Eratosthenes is brilliant because:

1. **Simple concept**: Mark multiples, what remains is prime
2. **Very efficient**: O(n log log n) for finding all primes up to n
3. **Ancient wisdom**: Still one of the best algorithms 2000+ years later!

It's like a factory assembly line - instead of individually inspecting each product, you remove all the defective ones in batches!

### OR

```cpp
class Solution {
  public:
    vector<int> primeFac(int n) {
        vector<int> primeFactors;

        if(n<=1) return primeFactors;
        for(int i=2;i<=n;i++){
            if(n%i!=0) continue;
            primeFactors.push_back(i);
            while(n%i==0) n=n/i;
        }
        return primeFactors;
    }
};
```

### OR

```cpp
class Solution {
  public:
    vector<int> primeFac(int n) {
        vector<int> primeFactors;

        if(n<=1) return primeFactors;
        for(int i=2;i*i<=n;i++){
            if(n%i!=0) continue;
            primeFactors.push_back(i);
            while(n%i==0) n=n/i;
        }
        if(n>1) primeFactors.push_back(n);
        return primeFactors;
    }
};
```

## The Algorithm Step-by-Step

```cpp
for(int i=2;i*i<=n;i++){
    if(n%i!=0) continue;           // Skip if i doesn't divide n
    primeFactors.push_back(i);     // Add i as a prime factor
    while(n%i==0) n=n/i;           // Remove all occurrences of i
}
if(n>1) primeFactors.push_back(n); // Handle remaining prime
```

---

## Why It Works: The Key Insights

### Insight 1: **We only encounter prime numbers**

When we iterate `i = 2, 3, 4, 5, 6, 7, 8, 9, 10, ...`, **composite numbers can never divide n at the time we check them**.

**Why?** Because we've already divided out all their prime factors!

**Example with n = 60:**

```
Initial: n = 60 = 2² × 3 × 5

i = 2:
  - 60 % 2 == 0 ✓
  - Add 2 to result
  - Divide out: 60 → 30 → 15
  - Now n = 15 (all 2's removed!)

i = 3:
  - 15 % 3 == 0 ✓
  - Add 3 to result
  - Divide out: 15 → 5
  - Now n = 5 (all 3's removed!)

i = 4:
  - 5 % 4 != 0 ✗
  - Skip! (4 = 2×2, but we already removed all 2's)

i = 5:
  - Can't check because 5² = 25 > 5
  - Loop ends

Remaining: n = 5 > 1
  - Add 5 to result

Result: [2, 3, 5] ✓
```

**The magic:** By the time we check composite number 4 (which is 2×2), we've already removed all factors of 2 from n, so 4 can't possibly divide n!

---

### Insight 2: **The `while` loop removes ALL occurrences**

```cpp
while(n%i==0) n=n/i;
```

This ensures we completely remove the prime factor, so we never encounter it again.

**Example with n = 72 = 2³ × 3²:**

```
i = 2:
  - Found 2 divides 72
  - Add 2 once
  - while loop: 72 → 36 → 18 → 9 (divided by 2 three times)
  - Now n = 9, all 2's gone!

i = 3:
  - Found 3 divides 9
  - Add 3 once
  - while loop: 9 → 3 → 1 (divided by 3 twice)
  - Now n = 1, all 3's gone!

Result: [2, 3] ✓ (unique prime factors)
```

Without the `while` loop, we'd add 2 three times and 3 twice!

---

### Insight 3: **Why check only up to √n?**

```cpp
for(int i=2;i*i<=n;i++)
```

After checking all primes up to √n, **at most one prime factor > √n can remain**.

**Why?** If two prime factors were both > √n, their product would be > n (impossible!).

**Example with n = 35 = 5 × 7:**

```
√35 ≈ 5.9

i = 2: 35 % 2 != 0, skip
i = 3: 35 % 3 != 0, skip
i = 4: 35 % 4 != 0, skip
i = 5: 35 % 5 == 0 ✓
  - Add 5
  - Divide: 35 → 7
  - Now n = 7

Loop stops (6² = 36 > 7)

Remaining: n = 7 > 1
  - Add 7

Result: [5, 7] ✓
```

---

### Insight 4: **The final check `if(n>1)`**

```cpp
if(n>1) primeFactors.push_back(n);
```

After the loop:

- If `n == 1`: All prime factors found ✓
- If `n > 1`: There's one large prime factor remaining

**Case 1: n becomes 1 (all factors ≤ √n)**

```
n = 12 = 2² × 3
After loop: n = 1
No need to add anything
Result: [2, 3] ✓
```

**Case 2: n > 1 (one large prime remains)**

```
n = 14 = 2 × 7
After checking up to √14 ≈ 3:
  - Found and removed 2, n = 7
  - 3 doesn't divide 7
  - n = 7 > 1 (this is a prime!)
Add 7
Result: [2, 7] ✓
```

---

## Complete Example: n = 84

```
84 = 2² × 3 × 7

Step-by-step execution:

i = 2:
  84 % 2 == 0 ✓
  Add 2 → [2]
  while: 84 → 42 → 21
  n = 21

i = 3:
  21 % 3 == 0 ✓
  Add 3 → [2, 3]
  while: 21 → 7
  n = 7

i = 4:
  √7 ≈ 2.6, so 4² = 16 > 7
  Loop ends!

Final check:
  n = 7 > 1
  Add 7 → [2, 3, 7]

Result: [2, 3, 7] ✓
```

---

## Why This Guarantees Uniqueness

1. **Each prime is added only once**: The `primeFactors.push_back(i)` happens outside the while loop
2. **Each prime is fully removed**: The while loop eliminates all powers
3. **We process in order**: From smallest to largest, ensuring no duplicates
4. **Only primes can divide n**: Composites are already factored out

---

## Comparison with a Wrong Approach

**Wrong: Adding inside the while loop**

```cpp
// ❌ WRONG - gives duplicates
while(n%i==0) {
    primeFactors.push_back(i);  // Adds multiple times!
    n = n/i;
}
```

For n = 12:

- Would give [2, 2, 3] instead of [2, 3]

**Correct: Add once, remove all**

```cpp
// ✓ CORRECT - unique factors
primeFactors.push_back(i);      // Add once
while(n%i==0) n=n/i;            // Remove all
```

For n = 12:

- Gives [2, 3] ✓

---

## Time Complexity

**O(√n)** in the worst case

- Best case: O(log n) when n has small prime factors
- Worst case: O(√n) when n is prime (we check all numbers up to √n)

---

## Summary

The algorithm works because:

1. **Sequential elimination**: We check numbers in order (2, 3, 4, 5, ...)
2. **Complete removal**: The while loop removes ALL occurrences of each prime
3. **Only primes divide**: By the time we check a composite, its factors are gone
4. **Add once**: We add each prime factor only once, outside the while loop
5. **Handle large primes**: The final `if(n>1)` catches any remaining large prime

It's elegant because it naturally filters out composites without needing to check if a number is prime!

### OR

```cpp
class Solution {
  public:
    vector<int> primeFac(int n) {
        vector<int> primeFactors;

        if(n<=1) return primeFactors;

        if(n%2==0){
            primeFactors.push_back(2);
            while(n%2==0) n=n/2;
        }
        if(n%3==0){
            primeFactors.push_back(3);
            while(n%3==0) n=n/3;
        }

        for(int i=5;i*i<=n;i+=6){
            if(n%i==0){
                primeFactors.push_back(i);
                while(n%i==0) n=n/i;
            }
            if(n%(i+2)==0){
                primeFactors.push_back(i+2);
                while(n%(i+2)==0) n=n/(i+2);
            }
        }
        if(n>3) primeFactors.push_back(n);
        return primeFactors;
    }
};
```

## Complete Walkthrough

### The Algorithm's Strategy

The algorithm finds **unique prime factors** by:

1. Checking potential divisors in order
2. Completely removing each divisor found
3. Using the 6k±1 pattern to skip most numbers

---

## Part 1: Why Handle 2 and 3 Separately?

```cpp
if(n%2==0){
    primeFactors.push_back(2);
    while(n%2==0) n=n/2;
}
```

**Purpose:** Remove all factors of 2 from n.

**Example: n = 24 = 2³ × 3**

```
Check: 24 % 2 == 0? Yes!
Add 2 to result: [2]
Remove all 2's: 24 → 12 → 6 → 3
Now n = 3 (completely odd)
```

**Why separate?** After this, n is odd, so we never need to check even numbers again!

---

```cpp
if(n%3==0){
    primeFactors.push_back(3);
    while(n%3==0) n=n/3;
}
```

**Purpose:** Remove all factors of 3 from n.

**Example: n = 3 (from previous step)**

```
Check: 3 % 3 == 0? Yes!
Add 3 to result: [2, 3]
Remove all 3's: 3 → 1
Now n = 1
```

**Why separate?** After this, n has no factors of 2 or 3, so we can skip all multiples of 2 and 3!

---

## Part 2: The 6k±1 Loop - The Core Logic

```cpp
for(int i=5;i*i<=n;i+=6){
    if(n%i==0){                      // Check 6k-1
        primeFactors.push_back(i);
        while(n%i==0) n=n/i;
    }
    if(n%(i+2)==0){                  // Check 6k+1
        primeFactors.push_back(i+2);
        while(n%(i+2)==0) n=n/(i+2);
    }
}
```

### What Numbers Does This Check?

| i   | i (6k-1) | i+2 (6k+1) |
| --- | -------- | ---------- |
| 5   | 5        | 7          |
| 11  | 11       | 13         |
| 17  | 17       | 19         |
| 23  | 23       | 25         |
| 29  | 29       | 31         |

**Pattern:** We're checking 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, ...

### What Numbers Does This SKIP?

- 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, ... (even numbers)
- 9, 15, 21, 27, 33, ... (multiples of 3)

All these are **guaranteed composite** (not prime).

---

## YOUR KEY QUESTION: Why Don't We Check if i or i+2 Are Prime?

### The Beautiful Answer: We Don't Need To!

**Critical Insight:** By the time we check a composite number, its prime factors have already been removed from n, so it can't possibly divide n!

Let me prove this with examples:

---

### Example 1: Why 25 (composite) doesn't cause problems

**n = 100 = 2² × 5²**

```
Step 1: Remove 2
  100 % 2 == 0
  Add 2 → [2]
  Remove: 100 → 50 → 25
  n = 25

Step 2: Check 3
  25 % 3 != 0
  Skip

Step 3: Loop i=5
  25 % 5 == 0 ✓
  Add 5 → [2, 5]
  Remove: 25 → 5 → 1
  n = 1

Step 4: Loop i=11
  Wait! 11² = 121 > 1, loop ends

Step 5: n = 1 ≤ 3, don't add anything

Result: [2, 5] ✓
```

**Now, what if we continued to i=23?**

```
We would check i+2 = 25
But n = 1 now!
1 % 25 != 0
25 doesn't divide 1, so it's harmless!
```

**Key point:** Even though 25 is composite (5×5), by the time we check it, we've already removed all 5's from n, so 25 can't divide n.

---

### Example 2: More complex case

**n = 450 = 2 × 3² × 5²**

```
Step 1: Remove 2
  450 → 225
  Add 2 → [2]
  n = 225

Step 2: Remove 3
  225 % 3 == 0
  Add 3 → [2, 3]
  Remove: 225 → 75 → 25
  n = 25

Step 3: Loop i=5
  25 % 5 == 0
  Add 5 → [2, 3, 5]
  Remove: 25 → 5 → 1
  n = 1

Done! Result: [2, 3, 5] ✓
```

**What about composite numbers like 9, 15, 21, 25?**

- **9 = 3²**: Already removed all 3's, so 9 can't divide n
- **15 = 3×5**: Already removed all 3's, so 15 can't divide n
- **21 = 3×7**: Already removed all 3's, so 21 can't divide n
- **25 = 5²**: Already removed all 5's, so 25 can't divide n

---

### Example 3: When we DO check a composite (25)

**n = 525 = 3 × 5² × 7**

```
Step 1: Check 2
  525 % 2 != 0
  Skip

Step 2: Remove 3
  525 % 3 == 0
  Add 3 → [3]
  Remove: 525 → 175
  n = 175

Step 3: Loop i=5
  175 % 5 == 0
  Add 5 → [3, 5]
  Remove: 175 → 35 → 7
  n = 7

Step 4: Loop i=11
  7 % 11 != 0
  7 % 13 != 0
  Loop stops (17² = 289 > 7)

Step 5: Final
  n = 7 > 3
  Add 7 → [3, 5, 7]

Result: [3, 5, 7] ✓
```

**Did we check 25 (composite)?**
Technically we would check `i+2 = 25` when i=23, but:

- Loop condition: `i*i <= n`
- When i=23: 23² = 529 > 7
- Loop already stopped before reaching i=23!

And even if we did check: 7 % 25 != 0, so it wouldn't matter.

---

## The Mathematical Proof

**Claim:** If a composite number c divides n at the point we check it, then we would have already found its prime factors.

**Proof:**

1. Any composite c can be written as c = p₁ × p₂ × ... where p₁, p₂, ... are primes
2. The smallest prime factor of c is ≤ √c
3. We check numbers in increasing order: 2, 3, 5, 7, 11, 13, ...
4. Before we reach c, we've already checked all numbers < c
5. If c divides n, then p₁ divides n
6. When we checked p₁, we removed **all** occurrences of p₁ from n
7. Therefore, c = p₁ × ... cannot divide the new n anymore!

**Conclusion:** By the time we check any composite number, its prime factors have been removed, so it's harmless to check!

---

## Visual Example: n = 60

```
60 = 2² × 3 × 5

Numbers we could check: 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...
Our algorithm checks:    2, 3,    5, 7,       11, ...
                              ↑
                         Skip 4, 6, 8, 9, 10 using 6k±1 pattern

Step by step:

Initial: n = 60

Check 2: ✓ divides
  Add 2 → [2]
  Remove: 60 → 30 → 15
  n = 15

Check 3: ✓ divides
  Add 3 → [2, 3]
  Remove: 15 → 5
  n = 5

Check 5: ✓ divides
  Add 5 → [2, 3, 5]
  Remove: 5 → 1
  n = 1

Check 7: Stop! (7² = 49 > 1)

Result: [2, 3, 5] ✓
```

**What if we checked 4, 6, 9?**

- After removing 2: n = 15 (odd), so 4 can't divide
- After removing 2: n = 15, 6 = 2×3, but 2 is gone, so 6 can't divide
- After removing 3: n = 5, so 9 = 3² can't divide

**They're all harmless!**

---

## Why the 6k±1 Optimization Still Works

Even though we might check composite numbers like 25, 35, 49, etc.:

1. **Most composites are skipped** (all multiples of 2 and 3)
2. **Remaining composites are harmless** (their factors already removed)
3. **We still find all primes** (because all primes > 3 are in form 6k±1)

**The efficiency comes from:**

- Skipping ~67% of numbers (multiples of 2 and 3)
- Not from checking if numbers are prime

---

## Summary

### Why don't we check if i or i+2 are prime?

**Because we don't need to!**

1. **If i is prime** and divides n → We add it ✓
2. **If i is composite** and divides n → Impossible! Its prime factors were already removed
3. **If i doesn't divide n** → We skip it regardless of whether it's prime or composite

The algorithm is **self-correcting**: by removing factors as we find them, composite numbers become unable to divide n, making primality checks unnecessary!

**The genius:** We're not trying to find primes. We're finding divisors, and those divisors are automatically prime because their factors have already been removed!

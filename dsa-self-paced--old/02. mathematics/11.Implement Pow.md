https://www.geeksforgeeks.org/problems/powx-n/1

```cpp
class Solution {
  public:
    double power(double b, int e) {
        if(e==0) return 1;
        if(b==0) return 0;
        double p=1;
        for(int i=1;i<=abs(e);i++){
            if(e<0) p=p*1.0/b;
            else p=p*b;
        }
        return p;
    }
};
```

```cpp
class Solution {
  public:
    double power(double b, int e) {
        if(e<0){
            b=1.0/b;
            e=-e;
        }

        if(e==0) return 1.0;
        if(b==0 || e==1) return b;

        double p=power(b,e/2);
        return p*p*(e&1 ? b:1);
    }
};
```

```cpp
class Solution {
  public:
    double power(double b, int e) {
        if(e<0){
            b=1.0/b;
            e=-e;
        }

        if(e==0) return 1.0;
        if(b==0 || e==1) return b;

        double rnPow=b;
        double ans=1;
        while(e){
            if(e&1) ans*=rnPow;
            rnPow*=rnPow;
            e>>=1;
        }
        return ans;
    }
};
```

This is a clever implementation of **exponentiation by squaring** (also called binary exponentiation). Let me break down why it works:

## The Key Insight

The algorithm exploits the binary representation of the exponent `y`(in x^y). Any number can be expressed as a sum of powers of 2.

For example: `y = 13 = 1101₂ = 8 + 4 + 1 = 2³ + 2² + 2⁰`

So: `x¹³ = x⁽⁸⁺⁴⁺¹⁾ = x⁸ × x⁴ × x¹`

## How It Works

The algorithm processes `y` bit by bit from right to left (least significant to most significant):

1. **Check if current bit is 1**: `if (y & 1)` checks if the rightmost bit is 1 (i.e., if y is odd)
   - If yes, multiply the current value of `x` into `res`
2. **Shift to next bit**: `y = y >> 1` divides y by 2 (shifts right by 1 bit)

3. **Square x**: `x = x * x` prepares x for the next bit position

## Example Walkthrough: Calculate 3¹³

Let's trace through `power(3, 13)` where `13 = 1101₂`:

```
Initial: res = 1, x = 3, y = 13 (1101₂)

Iteration 1: y = 13 (1101₂)
  - y & 1 = 1 (odd) → res = 1 × 3 = 3
  - y = 13 >> 1 = 6 (110₂)
  - x = 3 × 3 = 9

Iteration 2: y = 6 (110₂)
  - y & 1 = 0 (even) → res stays 3
  - y = 6 >> 1 = 3 (11₂)
  - x = 9 × 9 = 81

Iteration 3: y = 3 (11₂)
  - y & 1 = 1 (odd) → res = 3 × 81 = 243
  - y = 3 >> 1 = 1 (1₂)
  - x = 81 × 81 = 6561

Iteration 4: y = 1 (1₂)
  - y & 1 = 1 (odd) → res = 243 × 6561 = 1594323
  - y = 1 >> 1 = 0
  - Loop ends

Result: 1594323 = 3¹³ ✓
```

## Why O(log y)?

The number of iterations equals the number of bits in `y`, which is approximately log₂(y). Each iteration does constant work, giving **O(log y)** time complexity.

This is much faster than the naive approach of multiplying x by itself y times, which would be O(y).

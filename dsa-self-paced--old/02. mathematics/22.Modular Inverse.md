https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-Mathematics/problem/modular-multiplicative-inverse-1587115620

https://www.geeksforgeeks.org/dsa/multiplicative-inverse-under-modulo-m/

```cpp
class Solution {
  public:
    int modInverse(int n, int m) {
        for(int i=1;i<m;i++){
            if(((n%m)*(i%m))%m==1) return i;
        }
        return -1;
    }
};
```

# Modular Multiplicative Inverse: From Basics to Advanced

Let me build this up systematically with clear reasoning at each step.

## **Part 1: The Basics - What is it?**

### Understanding Modular Arithmetic First

Before we tackle the inverse, let's understand modular arithmetic (also called "clock arithmetic").

**Example:** 15 mod 7 = 1

Why? Because 15 = 7 √ó 2 + 1. We divide 15 by 7 and take the remainder.

Think of a 7-hour clock: if it's 15 hours from now, that's really just 1 hour on our clock (after going around twice).

### What is a Multiplicative Inverse?

In regular arithmetic, the multiplicative inverse of a number `a` is `1/a`, because:

- a √ó (1/a) = 1

**Example:** The inverse of 5 is 1/5, because 5 √ó (1/5) = 1

### Modular Multiplicative Inverse

The **modular multiplicative inverse** of `a` modulo `m` is a number `x` such that:

**a √ó x ‚â° 1 (mod m)**

This means: when you multiply `a` by `x` and divide by `m`, the remainder is 1.

---

## **Part 2: First Example - Building Intuition**

**Problem:** Find the modular multiplicative inverse of 3 modulo 7.

**What we're looking for:** A number `x` such that (3 √ó x) mod 7 = 1

**Brute Force Approach** (good for understanding):

Let's try different values of x:

- x = 1: (3 √ó 1) mod 7 = 3 mod 7 = 3 ‚ùå
- x = 2: (3 √ó 2) mod 7 = 6 mod 7 = 6 ‚ùå
- x = 3: (3 √ó 3) mod 7 = 9 mod 7 = 2 ‚ùå
- x = 4: (3 √ó 4) mod 7 = 12 mod 7 = 5 ‚ùå
- x = 5: (3 √ó 5) mod 7 = 15 mod 7 = 1 ‚úÖ

**Answer:** The modular multiplicative inverse of 3 mod 7 is **5**.

**Verification:** 3 √ó 5 = 15 = 7 √ó 2 + 1, so (3 √ó 5) mod 7 = 1 ‚úì

---

## **Part 3: When Does an Inverse Exist?**

**Critical Theorem:** The modular multiplicative inverse of `a` modulo `m` exists **if and only if** `gcd(a, m) = 1`.

(gcd = greatest common divisor)

**Why?** If `a` and `m` share a common factor > 1, then `a √ó x` will always be a multiple of that factor, so it can never leave remainder 1 when divided by `m`.

**Example of NO inverse:**

- Find inverse of 6 mod 9
- gcd(6, 9) = 3 ‚â† 1
- No inverse exists!

Let's verify:

- 6√ó1 = 6 mod 9 = 6
- 6√ó2 = 12 mod 9 = 3
- 6√ó3 = 18 mod 9 = 0
- 6√ó4 = 24 mod 9 = 6
- Pattern repeats: {6, 3, 0, 6, 3, 0, ...} - never equals 1!

---

## **Part 4: Extended Euclidean Algorithm (The Powerful Method)**

For larger numbers, brute force is impractical. The Extended Euclidean Algorithm is the standard method.

### The Theory

The Extended Euclidean Algorithm finds integers `x` and `y` such that:

**a √ó x + m √ó y = gcd(a, m)**

If gcd(a, m) = 1, then:

- a √ó x + m √ó y = 1
- Taking both sides mod m: a √ó x ‚â° 1 (mod m)
- So `x` is our inverse!

### Example 1: Find inverse of 3 mod 11

**Step 1:** Apply Euclidean Algorithm to find gcd(3, 11)

```
11 = 3 √ó 3 + 2
3 = 2 √ó 1 + 1
2 = 1 √ó 2 + 0
```

gcd(3, 11) = 1 ‚úì (inverse exists!)

**Step 2:** Work backwards to express 1 as a combination of 3 and 11

From second equation: 1 = 3 - 2 √ó 1

Substitute 2 from first equation: 2 = 11 - 3 √ó 3

So: 1 = 3 - (11 - 3 √ó 3) √ó 1
= 3 - 11 + 3 √ó 3
= 3 √ó 4 - 11 √ó 1

**Result:** 3 √ó 4 + 11 √ó (-1) = 1

Therefore, 3 √ó 4 ‚â° 1 (mod 11)

**Answer:** The inverse of 3 mod 11 is **4**.

**Verification:** 3 √ó 4 = 12 = 11 √ó 1 + 1, so (3 √ó 4) mod 11 = 1 ‚úì

---

### Example 2: Find inverse of 7 mod 26 (More Complex)

**Step 1:** Euclidean Algorithm

```
26 = 7 √ó 3 + 5   ... (equation 1)
7 = 5 √ó 1 + 2    ... (equation 2)
5 = 2 √ó 2 + 1    ... (equation 3)
2 = 1 √ó 2 + 0
```

gcd(7, 26) = 1 ‚úì

**Step 2:** Extended Euclidean (working backwards)

From equation 3:
**1 = 5 - 2 √ó 2**

Substitute 2 from equation 2: 2 = 7 - 5 √ó 1

1 = 5 - (7 - 5 √ó 1) √ó 2
= 5 - 7 √ó 2 + 5 √ó 2
= 5 √ó 3 - 7 √ó 2

Substitute 5 from equation 1: 5 = 26 - 7 √ó 3

1 = (26 - 7 √ó 3) √ó 3 - 7 √ó 2
= 26 √ó 3 - 7 √ó 9 - 7 √ó 2
= 26 √ó 3 - 7 √ó 11

**Result:** 7 √ó (-11) + 26 √ó 3 = 1

Since we need a positive answer: -11 mod 26 = 26 - 11 = 15

**Answer:** The inverse of 7 mod 26 is **15**.

**Verification:** 7 √ó 15 = 105 = 26 √ó 4 + 1, so (7 √ó 15) mod 26 = 1 ‚úì

---

## **Part 5: Advanced Applications**

### 1. **Solving Linear Congruences**

**Problem:** Solve 7x ‚â° 3 (mod 26)

**Solution:**

- Find inverse of 7 mod 26 (we found it's 15)
- Multiply both sides by 15:
  - 15 √ó 7x ‚â° 15 √ó 3 (mod 26)
  - x ‚â° 45 (mod 26)
  - x ‚â° 19 (mod 26)

**Answer:** x = 19

**Verification:** 7 √ó 19 = 133 = 26 √ó 5 + 3, so 7 √ó 19 ‚â° 3 (mod 26) ‚úì

### 2. **Cryptography: RSA Algorithm**

In RSA encryption, modular multiplicative inverses are crucial:

- Choose primes p and q, compute n = p √ó q
- Choose e (public exponent)
- Find d ‚â° e‚Åª¬π (mod œÜ(n)), where œÜ(n) = (p-1)(q-1)
- d is the private key!

**Simplified Example:**

- p = 3, q = 11, so n = 33, œÜ(n) = 2 √ó 10 = 20
- Choose e = 3
- Find d such that 3d ‚â° 1 (mod 20)
- Testing: 3 √ó 7 = 21 ‚â° 1 (mod 20) ‚úì
- Private key d = 7

### 3. **Modular Division**

Want to compute (a/b) mod m?

- This equals (a √ó b‚Åª¬π) mod m
- Find the inverse of b mod m, then multiply by a

**Example:** Compute (10/3) mod 7

- Inverse of 3 mod 7 is 5 (we found earlier)
- (10/3) mod 7 = (10 √ó 5) mod 7 = 50 mod 7 = 1

---

## **Part 6: Key Properties & Theorems**

### **Fermat's Little Theorem (Alternative Method)**

If `p` is prime and gcd(a, p) = 1, then:

**a^(p-1) ‚â° 1 (mod p)**

Therefore: **a^(p-2) ‚â° a‚Åª¬π (mod p)**

**Example:** Find inverse of 3 mod 7 using Fermat

- 3‚Åª¬π ‚â° 3^(7-2) ‚â° 3^5 (mod 7)
- 3^5 = 243 = 7 √ó 34 + 5
- Inverse is **5** ‚úì (matches our earlier result!)

This method is especially useful when m is prime and a is large.

### **Uniqueness**

The modular multiplicative inverse is **unique** modulo m.

If both x‚ÇÅ and x‚ÇÇ are inverses of a mod m:

- a √ó x‚ÇÅ ‚â° 1 (mod m)
- a √ó x‚ÇÇ ‚â° 1 (mod m)
- Therefore: x‚ÇÅ ‚â° x‚ÇÇ (mod m)

---

## **Summary Table**

| Method                  | When to Use             | Complexity |
| ----------------------- | ----------------------- | ---------- |
| Brute Force             | Small modulus, learning | O(m)       |
| Extended Euclidean      | General case, any size  | O(log m)   |
| Fermat's Little Theorem | Prime modulus only      | O(log p)   |

**Key Takeaway:** Modular multiplicative inverse is the foundation of solving modular equations and is essential in modern cryptography!

```cpp
class Solution {
  public:
    int modInverse(int n, int m) {
        int x,y;
        const int gcd=gcdExtended(n,m,&x,&y);
        if(gcd!=1) return -1;

        return (x % m + m) % m;
    }
    int gcdExtended(int a,int b,int *x,int *y){
        if(a==0){
            *x=0,*y=1;
            return b;
        }

        int x1,y1;
        int gcd=gcdExtended(b%a,a,&x1,&y1);

        *x=y1-(b/a)*x1;
        *y=x1;
        return gcd;
    }

};
```

## **What are x and y?**

**x** and **y** are coefficients that satisfy this equation:

### **A √ó x + M √ó y = gcd(A, M)**

This is called **B√©zout's identity** or the **Extended Euclidean Algorithm result**.

---

## **Understanding Through Our Example**

For **A = 3, M = 11**:

The algorithm finds: **3 √ó x + 11 √ó y = gcd(3, 11)**

After execution, we get:

- **x = 4**
- **y = -1**
- **gcd = 1**

Let's verify: **3 √ó 4 + 11 √ó (-1) = 12 - 11 = 1** ‚úì

---

## **Why Do We Care About x?**

Here's the key insight:

**3 √ó 4 + 11 √ó (-1) = 1**

Now, let's take both sides **modulo 11**:

**(3 √ó 4 + 11 √ó (-1)) mod 11 = 1 mod 11**

Since **11 √ó (-1)** is a multiple of 11, it disappears when we take mod 11:

**3 √ó 4 ‚â° 1 (mod 11)**

This means **x = 4** is the modular multiplicative inverse of 3 modulo 11! üéØ

---

## **Why Do We Ignore y?**

**y is just a byproduct** of the Extended Euclidean Algorithm. We don't need it for finding the inverse.

Here's why y doesn't matter for our purpose:

- We have: A √ó x + M √ó y = 1
- Taking mod M: (A √ó x + M √ó y) mod M = 1 mod M
- The term M √ó y vanishes: A √ó x mod M = 1
- **We only need x!**

**y** is useful in other contexts (like solving Diophantine equations), but for modular inverse, we only care about **x**.

---

## **Visualizing the Role of x and y**

Let me trace through the recursion again, showing what x and y mean at each level:

### **For A = 3, M = 11:**

```
Level 4 (Base): gcdExtended(0, 1)
Equation: 0√óx + 1√óy = 1
Solution: x=0, y=1
Meaning: 0√ó0 + 1√ó1 = 1 ‚úì
```

```
Level 3: gcdExtended(1, 2)
Equation: 1√óx + 2√óy = 1
Solution: x=1, y=0
Meaning: 1√ó1 + 2√ó0 = 1 ‚úì
```

```
Level 2: gcdExtended(2, 3)
Equation: 2√óx + 3√óy = 1
Solution: x=-1, y=1
Meaning: 2√ó(-1) + 3√ó1 = -2 + 3 = 1 ‚úì
```

```
Level 1: gcdExtended(3, 11)
Equation: 3√óx + 11√óy = 1
Solution: x=4, y=-1
Meaning: 3√ó4 + 11√ó(-1) = 12 - 11 = 1 ‚úì
```

At each level, x and y are coefficients that express gcd as a linear combination of the two numbers.

---

## **Another Example: A = 7, M = 26**

Let's trace what x and y would be for finding the inverse of 7 mod 26:

```
Euclidean Algorithm:
26 = 7 √ó 3 + 5
7 = 5 √ó 1 + 2
5 = 2 √ó 2 + 1
2 = 1 √ó 2 + 0
```

After running the Extended Euclidean Algorithm:

- **x = 15** (or could be -11, which is 15 mod 26)
- **y = -4**
- **gcd = 1**

**Verification:** 7 √ó 15 + 26 √ó (-4) = 105 - 104 = 1 ‚úì

Taking mod 26: **7 √ó 15 ‚â° 1 (mod 26)**

So the inverse of 7 mod 26 is **15**.

Again, **y = -4** was computed but we don't use it for the inverse.

---

## **In the Code - Where x and y are Used**

```cpp
int gcdExtended(int a, int b, int* x, int* y) {
    if (a == 0) {
        *x = 0, *y = 1;  // ‚Üê Set base case values
        return b;
    }

    int x1, y1;
    int gcd = gcdExtended(b % a, a, &x1, &y1);  // ‚Üê Get x1, y1 from recursion

    *x = y1 - (b / a) * x1;  // ‚Üê Compute x for this level
    *y = x1;                  // ‚Üê Compute y for this level

    return gcd;
}
```

**At each recursion level:**

- We receive **x1** and **y1** from the recursive call
- We compute **x** and **y** for the current level using the formula
- These satisfy: **a √ó x + b √ó y = gcd(a, b)**

---

## **Question 1: Why is `*y = 1` and not `*y = b`?**

You're thinking logically, but let me show you why `*y = 1` is correct.

### **What equation are we solving?**

When `a = 0`, we need to find x and y such that:

**a √ó x + b √ó y = gcd(a, b)**

Substituting a = 0:

**0 √ó x + b √ó y = gcd(0, b)**

Since gcd(0, b) = b, we get:

**0 √ó x + b √ó y = b**

### **Solving for x and y:**

From **b √ó y = b**, we get **y = 1** (dividing both sides by b)

And x can be anything (since it's multiplied by 0), so we set **x = 0**

### **Verification:**

```
a = 0, b = 5 (example)
Equation: 0√óx + 5√óy = gcd(0, 5) = 5

With x=0, y=1:
0√ó0 + 5√ó1 = 5 ‚úì Correct!

If we used y=b=5:
0√ó0 + 5√ó5 = 25 ‚úó Wrong! (We need result to be 5, not 25)
```

**So `*y = 1` is correct, not `*y = b`!**

---

## **Question 2: How are the new x and y calculated?**

This is the heart of the algorithm! Let me explain step by step.

### **The Mathematical Derivation**

Suppose we have two consecutive steps in the Euclidean algorithm:

**Step 1:** `b = a √ó q + r` (where q = b/a and r = b%a)

**Step 2:** From the recursive call, we know:

```
r √ó x1 + a √ó y1 = gcd(a, b)
```

**Our goal:** Express gcd(a,b) in terms of a and b (not r).

### **The Substitution:**

Since `r = b - a √ó q`, we substitute:

```
(b - a√óq) √ó x1 + a √ó y1 = gcd(a, b)

Expanding:
b√óx1 - a√óq√óx1 + a√óy1 = gcd(a, b)

Rearranging (group the 'a' terms):
a√ó(y1 - q√óx1) + b√óx1 = gcd(a, b)
```

Now we have it in the form: **a √ó x + b √ó y = gcd(a, b)**

Where:

- **x = y1 - q √ó x1** = **y1 - (b/a) √ó x1**
- **y = x1**

---

## **Step-by-Step Example: A=3, M=11**

Let me trace through showing exactly how x and y are calculated at each step.

### **Building the recursion (going down):**

```
Call 1: gcdExtended(3, 11)
‚îú‚îÄ a=3, b=11, q=11/3=3, r=11%3=2
‚îî‚îÄ Recurse: gcdExtended(2, 3)

Call 2: gcdExtended(2, 3)
‚îú‚îÄ a=2, b=3, q=3/2=1, r=3%2=1
‚îî‚îÄ Recurse: gcdExtended(1, 2)

Call 3: gcdExtended(1, 2)
‚îú‚îÄ a=1, b=2, q=2/1=2, r=2%1=0
‚îî‚îÄ Recurse: gcdExtended(0, 1)

Call 4: gcdExtended(0, 1) ‚Üê BASE CASE
‚îú‚îÄ a=0, b=1
‚îú‚îÄ x=0, y=1
‚îî‚îÄ Return gcd=1
```

**Base case equation:** 0√ó0 + 1√ó1 = 1 ‚úì

---

### **Unwinding the recursion (going up):**

**Returning to Call 3:** gcdExtended(1, 2)

```
We know from recursive call:
  x1 = 0, y1 = 1 (from base case)
  Equation was: 0√ó0 + 1√ó1 = 1

Now calculate x and y for: 1√óx + 2√óy = 1

Using formulas:
  q = b/a = 2/1 = 2
  x = y1 - (b/a)√óx1 = 1 - 2√ó0 = 1 - 0 = 1
  y = x1 = 0

Result: x=1, y=0
```

**Verify:** 1√ó1 + 2√ó0 = 1 ‚úì

---

**Returning to Call 2:** gcdExtended(2, 3)

```
We know from recursive call:
  x1 = 1, y1 = 0
  Equation was: 1√ó1 + 2√ó0 = 1

Now calculate x and y for: 2√óx + 3√óy = 1

Using formulas:
  q = b/a = 3/2 = 1
  x = y1 - (b/a)√óx1 = 0 - 1√ó1 = -1
  y = x1 = 1

Result: x=-1, y=1
```

**Verify:** 2√ó(-1) + 3√ó1 = -2 + 3 = 1 ‚úì

---

**Returning to Call 1:** gcdExtended(3, 11)

```
We know from recursive call:
  x1 = -1, y1 = 1
  Equation was: 2√ó(-1) + 3√ó1 = 1

Now calculate x and y for: 3√óx + 11√óy = 1

Using formulas:
  q = b/a = 11/3 = 3
  x = y1 - (b/a)√óx1 = 1 - 3√ó(-1) = 1 + 3 = 4
  y = x1 = -1

Result: x=4, y=-1
```

**Verify:** 3√ó4 + 11√ó(-1) = 12 - 11 = 1 ‚úì

**Final Answer:** The inverse of 3 mod 11 is **4**

---

## **Visual Summary of the Calculation**

```
Level   | a  | b  | q | From recursive call | Calculate new x and y
--------|----|----|---|---------------------|------------------------
Base    | 0  | 1  | - | -                   | x=0, y=1
Level 3 | 1  | 2  | 2 | x1=0, y1=1          | x = 1-2√ó0 = 1, y = 0
Level 2 | 2  | 3  | 1 | x1=1, y1=0          | x = 0-1√ó1 = -1, y = 1
Level 1 | 3  | 11 | 3 | x1=-1, y1=1         | x = 1-3√ó(-1) = 4, y = -1
```

---

## **Why does `y = x1`?**

This might seem mysterious, but look at our derivation again:

```
Original equation: r √ó x1 + a √ó y1 = gcd
After substitution: a √ó (y1 - q√óx1) + b √ó x1 = gcd
```

Comparing with: **a √ó x + b √ó y = gcd**

We see:

- Coefficient of **a** is `(y1 - q√óx1)`, so **x = y1 - q√óx1**
- Coefficient of **b** is `x1`, so **y = x1**

It's not arbitrary‚Äîit comes directly from the algebraic manipulation!

---

## **Summary**

1. **Base case:** When `a = 0`, we set `x = 0` and `y = 1` because `0√ó0 + b√ó1 = b = gcd(0, b)`

2. **Recursive formula:**
   - **x = y1 - (b/a) √ó x1** (where x1, y1 come from the recursive call)
   - **y = x1**
3. **Why it works:** These formulas come from substituting `r = b - a√óq` into the equation from the recursive call and rearranging terms.

The beauty is that each level "builds up" the solution from the base case, ensuring that at every level, the equation `a√óx + b√óy = gcd(a,b)` holds true!

https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-BitMagic/problem/gray-to-binary-equivalent-1587115620

```cpp
class Solution {
  public:
    int grayToBinary(int n) {
        int res=n;

        while(n){
            res=res^(res>>1);
            n>>=1;
        }
        return res;
    }
};
```

# Gray to Binary Conversion - Complete Explanation

Let me explain this brilliant algorithm in detail!

---

## **Part 1: Understanding Gray Code**

### **What is Gray Code?**

Gray code (also called reflected binary code) is a binary numbering system where **consecutive numbers differ by only ONE bit**.

**Example: 0 to 7**

```
Decimal | Binary | Gray Code
--------|--------|----------
   0    |  000   |   000
   1    |  001   |   001
   2    |  010   |   011
   3    |  011   |   010
   4    |  100   |   110
   5    |  101   |   111
   6    |  110   |   101
   7    |  111   |   100
```

**Notice:** Each Gray code differs from the previous by exactly 1 bit!

```
000 → 001 (changed bit 0)
001 → 011 (changed bit 1)
011 → 010 (changed bit 0)
010 → 110 (changed bit 2)
...
```

---

## **Part 2: Binary to Gray Conversion (Foundation)**

Before understanding Gray to Binary, let's understand **Binary to Gray**:

### **Formula: Gray = Binary XOR (Binary >> 1)**

```cpp
int binaryToGray(int n) {
    return n ^ (n >> 1);
}
```

### **Example: Binary 5 (101) to Gray**

```
Binary: 101
Shift:  010  (101 >> 1)
XOR:    111  (101 ^ 010)

Gray code of 5 = 111
```

**Bit-by-bit:**

```
Position 2: 1 ^ 0 = 1
Position 1: 0 ^ 1 = 1
Position 0: 1 ^ 0 = 1

Result: 111
```

### **Why This Works (Binary to Gray):**

Each bit in Gray code is the XOR of:

- Current bit in binary
- Previous (left) bit in binary

```
Gray[i] = Binary[i] ^ Binary[i+1]
```

---

## **Part 3: Gray to Binary - The Mathematical Relationship**

### **Key Observation:**

If we know:

```
Gray[i] = Binary[i] ^ Binary[i+1]
```

We can derive:

```
Binary[i] = Gray[i] ^ Binary[i+1]
```

This means: **Each binary bit is the XOR of the current gray bit and the next binary bit!**

### **Recursive Formula:**

```
Binary[MSB] = Gray[MSB]  (MSB has no previous bit)
Binary[i] = Gray[i] ^ Binary[i+1]  (for other bits)
```

### **Example: Gray 111 to Binary**

```
Gray: 111

Step 1: MSB stays same
Binary[2] = Gray[2] = 1

Step 2: Next bit
Binary[1] = Gray[1] ^ Binary[2]
          = 1 ^ 1
          = 0

Step 3: Last bit
Binary[0] = Gray[0] ^ Binary[1]
          = 1 ^ 0
          = 1

Result: Binary = 101 = 5 ✓
```

---

## **Part 4: Understanding the Algorithm**

### **The Code:**

```cpp
int grayToBinary(int n) {
    int res = n;           // Start with Gray code itself
    while (n) {            // Continue until n becomes 0
        res = res ^ (res >> 1);  // XOR res with right-shifted res
        n >>= 1;           // Right shift n
    }
    return res;
}
```

### **Why This Works:**

The algorithm **progressively XORs** each bit position with all higher bit positions.

**Key Insight:**

```
Binary[i] = Gray[i] ^ Gray[i+1] ^ Gray[i+2] ^ ... ^ Gray[MSB]
```

> Each binary bit is the XOR of the current gray bit and ALL gray bits to its left!

---

## **Part 5: Detailed Example - Gray 6 (110) to Binary**

### **Setup:**

```
Gray code: 110 (decimal 6)
n = 110
res = 110
```

### **Iteration 1:**

```
Before:
res = 110
n = 110

Operation:
res >> 1 = 011
res = res ^ (res >> 1)
    = 110 ^ 011
    = 101

After:
res = 101
n = n >> 1 = 011
```

**What happened?**

```
Position 2: 1 ^ 0 = 1  (kept)
Position 1: 1 ^ 1 = 0  (XORed with bit 2)
Position 0: 0 ^ 1 = 1  (XORed with bit 1)

Intermediate result: 101
```

### **Iteration 2:**

```
Before:
res = 101
n = 011

Operation:
res >> 1 = 010
res = res ^ (res >> 1)
    = 101 ^ 010
    = 111

After:
res = 111
n = n >> 1 = 001
```

**What happened?**

```
Now we're XORing with bits shifted by 2 positions:

Position 2: 1 ^ 0 = 1
Position 1: 0 ^ 1 = 1  (now XORed with bit 2 of original Gray)
Position 0: 1 ^ 0 = 1

Intermediate result: 111
```

### **Iteration 3:**

```
Before:
res = 111
n = 001

Operation:
res >> 1 = 011
res = res ^ (res >> 1)
    = 111 ^ 011
    = 100

After:
res = 100
n = n >> 1 = 000
```

**What happened?**

```
Now XORing with bits shifted by 3 positions:

Position 2: 1 ^ 0 = 1
Position 1: 1 ^ 1 = 0  (XORed with bit 2 again)
Position 0: 1 ^ 1 = 0

Final result: 100 = 4 (binary)
```

### **Iteration 4:**

```
n = 000, loop exits
```

**Final Answer: 100 = 4**

### **Verification:**

```
Gray 110 should give Binary 100 (4)

Let's check using Binary to Gray:
Binary 100 → Gray = 100 ^ 010 = 110 ✓

So Gray 110 → Binary 100 ✓
```

---

## **Part 6: Visual Trace - Gray 111 (7) to Binary 101 (5)**

```
Initial:
Gray:    111
res:     111
n:       111

Iteration 1:
res >> 1:  011
res ^ (res>>1): 111 ^ 011 = 100
n >>= 1:   011

Current state:
res: 100
n:   011

Iteration 2:
res >> 1:  010
res ^ (res>>1): 100 ^ 010 = 110
n >>= 1:   001

Current state:
res: 110
n:   001

Iteration 3:
res >> 1:  011
res ^ (res>>1): 110 ^ 011 = 101
n >>= 1:   000

Current state:
res: 101  ← Final answer
n:   000  ← Loop exits

Result: 101 = 5
```

**Verification:**

```
Binary 5 (101) to Gray:
101 ^ 010 = 111 ✓

So Gray 111 → Binary 101 ✓
```

---

## **Part 7: Mathematical Proof - Why This Works**

### **Binary Bit Formula:**

```
Binary[i] = Gray[i] ⊕ Gray[i+1] ⊕ Gray[i+2] ⊕ ... ⊕ Gray[MSB]
```

Where ⊕ is XOR.

### **What the Algorithm Does:**

Starting with `res = Gray`:

**Iteration 1:** `res = res ^ (res >> 1)`

```
res[i] = Gray[i] ^ Gray[i+1]
```

**Iteration 2:** `res = res ^ (res >> 2)` (effectively)

```
res[i] = Gray[i] ^ Gray[i+1] ^ Gray[i+2]
```

**Iteration 3:** `res = res ^ (res >> 4)` (effectively)

```
res[i] = Gray[i] ^ Gray[i+1] ^ Gray[i+2] ^ Gray[i+3]
```

And so on...

### **Example with 4 bits:**

```
Gray = g3 g2 g1 g0

After iteration 1:
b3 = g3
b2 = g3 ^ g2
b1 = g2 ^ g1
b0 = g1 ^ g0

After iteration 2:
b3 = g3
b2 = g3 ^ g2
b1 = g3 ^ g2 ^ g1
b0 = g2 ^ g1 ^ g0

After iteration 3:
b3 = g3
b2 = g3 ^ g2
b1 = g3 ^ g2 ^ g1
b0 = g3 ^ g2 ^ g1 ^ g0

This matches our formula! ✓
```

---

## **Part 8: Step-by-Step for Gray 5 (101) → Binary 6 (110)**

Wait, let me recalculate correctly:

```
Gray 5 = 101 should give Binary = ?

Using formula: Binary to Gray of what number gives 101?
Let's trace the algorithm:

Initial:
Gray:  101
res:   101
n:     101

Iteration 1:
res >> 1:       010
res = 101 ^ 010 = 111
n = 101 >> 1 = 010

Iteration 2:
res >> 1:       011
res = 111 ^ 011 = 100
n = 010 >> 1 = 001

Iteration 3:
res >> 1:       010
res = 100 ^ 010 = 110
n = 001 >> 1 = 000

Loop exits (n = 0)

Result: 110 = 6 (binary)
```

**Verification:**

```
Binary 6 (110) to Gray:
110 ^ 011 = 101 ✓

So Gray 101 → Binary 110 ✓
```

---

## **Part 9: Complete Trace Table**

| Gray | Initial res | After Iter 1 | After Iter 2 | After Iter 3 | Binary | Decimal |
| ---- | ----------- | ------------ | ------------ | ------------ | ------ | ------- |
| 000  | 000         | 000          | 000          | 000          | 000    | 0       |
| 001  | 001         | 001          | 001          | 001          | 001    | 1       |
| 011  | 011         | 010          | 011          | 011          | 010    | 2       |
| 010  | 010         | 011          | 010          | 010          | 011    | 3       |
| 110  | 110         | 101          | 111          | 100          | 100    | 4       |
| 111  | 111         | 100          | 110          | 101          | 101    | 5       |
| 101  | 101         | 111          | 100          | 110          | 110    | 6       |
| 100  | 100         | 110          | 101          | 111          | 111    | 7       |

---

## **Part 10: Why Use `n >>= 1` as Loop Condition?**

```cpp
while (n) {
    res = res ^ (res >> 1);
    n >>= 1;
}
```

**The variable `n` is just a counter!**

- It tells us **how many more iterations** we need
- When `n` becomes 0, we've processed all necessary bit positions
- For an n-bit number, we need at most log₂(n) iterations

**Example:**

```
n = 110 (3 bits, value 6)

Iteration 1: n = 011 (shifted right)
Iteration 2: n = 001 (shifted right)
Iteration 3: n = 000 (shifted right) → EXIT

We did 3 iterations for a 3-bit number
```

---

## **Part 11: Complexity Analysis**

**Time Complexity:** O(log n)

- Number of iterations = number of bits in n
- For 32-bit integer: at most 32 iterations

**Space Complexity:** O(1)

- Only using two variables

---

## **Part 12: Alternative Understanding - Cumulative XOR**

The algorithm can be seen as building **cumulative XOR** from left to right:

```
Gray:    g₃  g₂  g₁  g₀

Binary:
b₃ = g₃
b₂ = g₃ ⊕ g₂
b₁ = g₃ ⊕ g₂ ⊕ g₁
b₀ = g₃ ⊕ g₂ ⊕ g₁ ⊕ g₀

Each binary bit accumulates all gray bits to its left!
```

---

## **Part 13: Complete Solution with Comments**

```cpp
class Solution {
public:
    int grayToBinary(int n) {
        int res = n;  // Start with Gray code

        // Continue until we've processed all bit positions
        while (n) {
            // XOR current result with right-shifted result
            // This progressively includes XOR of higher bits
            res = res ^ (res >> 1);

            // Shift n to track remaining iterations
            n >>= 1;
        }

        return res;  // Now res contains binary equivalent
    }
};

// Alternative implementation (more explicit)
int grayToBinary_v2(int gray) {
    int binary = gray;

    // For each bit position (from MSB to LSB)
    for (int shift = 1; shift < 32; shift <<= 1) {
        binary ^= (binary >> shift);
    }

    return binary;
}
```

---

## **Summary: Why This Algorithm is Brilliant**

1. **No explicit bit extraction** - works on the entire number at once

2. **Uses XOR properties:**

   - `a ^ a = 0` (self-canceling)
   - `a ^ 0 = a` (identity)
   - XOR is associative and commutative

3. **Cascading effect:**

   - Each iteration doubles the distance of XOR operation
   - Iteration 1: XOR with 1-bit shift
   - Iteration 2: XOR with 2-bit shift
   - Iteration 3: XOR with 4-bit shift
   - This covers all necessary bit combinations!

4. **Efficient:** O(log n) time, O(1) space

This is a beautiful example of **bit manipulation magic**! 🎯

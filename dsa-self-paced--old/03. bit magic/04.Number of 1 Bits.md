https://www.geeksforgeeks.org/problems/set-bits0143/1

```cpp
class Solution {
  public:
    int setBits(int n) {
        int count=0;
        for(int i=0;i<=31;i++){
            if(n&(1<<i)) count++;
        }
        return count;
    }
};
```

```cpp
class Solution {
  public:
    int setBits(int n) {
        int count=0;
        for(int i=0;i<=31;i++){
            if((n>>i)&1) count++;
        }
        return count;
    }
};
```

```cpp
class Solution {
  public:
    int setBits(int n) {
        int count=0;
        while(n){
            if(n&1) count++;
            n>>=1;
        }
        return count;
    }
};
```

```cpp
class Solution {
  public:
    int setBits(int n) {
        int count=0;
        while(n){
            count++;
            n=n&(n-1);
        }
        return count;
    }
};
```

```cpp
class Solution {
    int lookup[256]={};

    void initializeLookup() {
        lookup[0] = 0;
        for (int i = 1; i < 256; i++) {
            // Current bit + count in remaining bits
            lookup[i] = (i & 1) + lookup[i >> 1];
        }
    }
  public:
    Solution(){
       initializeLookup();
    }
    int setBits(int n) {
         return lookup[n & 0xFF] +           // Byte 0
           lookup[(n >> 8) & 0xFF] +    // Byte 1
           lookup[(n >> 16) & 0xFF] +   // Byte 2
           lookup[(n >> 24) & 0xFF];    // Byte 3
    }
};
```

# Count Set Bits Using Lookup Table - Complete Guide

Let me explain this clever optimization technique in detail!

---

## **Part 1: The Problem**

**Goal:** Count the number of 1s (set bits) in a binary number.

**Example:**

```
Number: 185
Binary: 10111001
Set bits: 5 (positions 0, 3, 4, 5, 7 have 1s)
```

---

## **Part 2: Naive Approaches (For Context)**

### **Method 1: Check Each Bit**

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        count += (n & 1);
        n >>= 1;
    }
    return count;
}
// Time: O(number of bits) = O(32) for int
```

### **Method 2: Brian Kernighan's Algorithm**

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n &= (n - 1);  // Remove rightmost set bit
        count++;
    }
    return count;
}
// Time: O(number of set bits)
```

**Both are decent, but can we do better?**

---

## **Part 3: The Lookup Table Approach - Core Idea**

### **The Insight:**

Instead of processing one bit at a time, what if we process **chunks of bits** at once?

**Key Observation:** If we have a lookup table that stores the count of set bits for all possible values of a chunk, we can just **look up** the answer instead of computing it!

---

## **Part 4: Building the Lookup Table**

### **Step 1: Choose Chunk Size**

Most common choice: **8 bits (1 byte)**

Why?

- 8-bit lookup table has 2^8 = 256 entries (manageable)
- We can process data in byte-sized chunks
- Good balance between memory and speed

### **Step 2: Create the Table**

We need a table where `table[i]` = number of set bits in number `i`

```cpp
// Table for all 8-bit numbers (0 to 255)
int lookup[256];

void initializeLookup() {
    lookup[0] = 0;  // 00000000 has 0 set bits

    for (int i = 1; i < 256; i++) {
        // Count set bits in i
        lookup[i] = (i & 1) + lookup[i / 2];
    }
}
```

**Let's trace how the table is built:**

```
i = 0: 00000000 → lookup[0] = 0

i = 1: 00000001 → lookup[1] = (1 & 1) + lookup[0] = 1 + 0 = 1

i = 2: 00000010 → lookup[2] = (2 & 1) + lookup[1] = 0 + 1 = 1

i = 3: 00000011 → lookup[3] = (3 & 1) + lookup[1] = 1 + 1 = 2

i = 4: 00000100 → lookup[4] = (4 & 1) + lookup[2] = 0 + 1 = 1

i = 5: 00000101 → lookup[5] = (5 & 1) + lookup[2] = 1 + 1 = 2

...

i = 255: 11111111 → lookup[255] = 8
```

---

## **Part 5: Complete Lookup Table (First 16 Entries)**

```
Decimal | Binary    | Set Bits | lookup[i]
--------|-----------|----------|----------
   0    | 0000 0000 |    0     |    0
   1    | 0000 0001 |    1     |    1
   2    | 0000 0010 |    1     |    1
   3    | 0000 0011 |    2     |    2
   4    | 0000 0100 |    1     |    1
   5    | 0000 0101 |    2     |    2
   6    | 0000 0110 |    2     |    2
   7    | 0000 0111 |    3     |    3
   8    | 0000 1000 |    1     |    1
   9    | 0000 1001 |    2     |    2
  10    | 0000 1010 |    2     |    2
  11    | 0000 1011 |    3     |    3
  12    | 0000 1100 |    2     |    2
  13    | 0000 1101 |    3     |    3
  14    | 0000 1110 |    3     |    3
  15    | 0000 1111 |    4     |    4
```

---

## **Part 6: Using the Lookup Table**

### **For 32-bit Integer:**

Break the 32-bit number into **4 bytes** (8 bits each) and look up each byte!

```cpp
int countSetBitsLookup(unsigned int n) {
    return lookup[n & 0xFF] +           // Last 8 bits
           lookup[(n >> 8) & 0xFF] +    // Next 8 bits
           lookup[(n >> 16) & 0xFF] +   // Next 8 bits
           lookup[(n >> 24) & 0xFF];    // First 8 bits
}
```

---

## **Part 7: Detailed Example - Count Set Bits in 185**

### **Step 1: Convert to Binary**

```
185 in decimal = 10111001 in binary
```

### **Step 2: Since it's less than 256, we can directly lookup**

```cpp
lookup[185] = ?
```

Let's calculate manually:

```
185 = 10111001
Set bits at positions: 0, 3, 4, 5, 7
Count = 5
```

So `lookup[185] = 5`

---

## **Part 8: Detailed Example - Count Set Bits in 123456789**

### **Step 1: Convert to Binary**

```
123456789 in decimal = 00000111 01011011 11001101 00010101 (32-bit)
```

### **Step 2: Break into 4 Bytes**

```
Byte 3 (bits 24-31): 00000111 = 7
Byte 2 (bits 16-23): 01011011 = 91
Byte 1 (bits 8-15):  11001101 = 205
Byte 0 (bits 0-7):   00010101 = 21
```

### **Step 3: Extract Each Byte and Lookup**

```cpp
n = 123456789

// Extract byte 0 (rightmost 8 bits)
byte0 = n & 0xFF = 123456789 & 0xFF = 21
lookup[21] = ?

21 in binary = 00010101
Set bits: 3 (positions 0, 2, 4)
lookup[21] = 3

// Extract byte 1
byte1 = (n >> 8) & 0xFF = (123456789 >> 8) & 0xFF = 205
lookup[205] = ?

205 in binary = 11001101
Set bits: 5 (positions 0, 2, 3, 6, 7)
lookup[205] = 5

// Extract byte 2
byte2 = (n >> 16) & 0xFF = (123456789 >> 16) & 0xFF = 91
lookup[91] = ?

91 in binary = 01011011
Set bits: 5 (positions 0, 1, 3, 4, 6)
lookup[91] = 5

// Extract byte 3
byte3 = (n >> 24) & 0xFF = (123456789 >> 24) & 0xFF = 7
lookup[7] = ?

7 in binary = 00000111
Set bits: 3 (positions 0, 1, 2)
lookup[7] = 3

// Total
Total = lookup[21] + lookup[205] + lookup[91] + lookup[7]
      = 3 + 5 + 5 + 3
      = 16
```

**Verification:**

```
123456789 in binary: 00000111 01011011 11001101 00010101

Count manually:
Byte 3: 00000111 → 3 ones ✓
Byte 2: 01011011 → 5 ones ✓
Byte 1: 11001101 → 5 ones ✓
Byte 0: 00010101 → 3 ones ✓

Total: 16 ✓
```

---

## **Part 9: Complete Working Code**

```cpp
#include <iostream>
using namespace std;

// Global lookup table
int lookup[256];

// Initialize lookup table
void initializeLookup() {
    lookup[0] = 0;
    for (int i = 1; i < 256; i++) {
        // Current bit + count in remaining bits
        lookup[i] = (i & 1) + lookup[i >> 1];
    }
}

// Alternative initialization (more intuitive)
void initializeLookupV2() {
    for (int i = 0; i < 256; i++) {
        int count = 0;
        int num = i;
        while (num) {
            count += (num & 1);
            num >>= 1;
        }
        lookup[i] = count;
    }
}

// Count set bits using lookup table
int countSetBits(unsigned int n) {
    return lookup[n & 0xFF] +           // Byte 0
           lookup[(n >> 8) & 0xFF] +    // Byte 1
           lookup[(n >> 16) & 0xFF] +   // Byte 2
           lookup[(n >> 24) & 0xFF];    // Byte 3
}

// For demonstration: print lookup table
void printLookupTable() {
    cout << "Lookup Table (first 32 entries):\n";
    cout << "Dec\tBinary\t\tSet Bits\n";
    for (int i = 0; i < 32; i++) {
        cout << i << "\t";
        // Print binary
        for (int j = 7; j >= 0; j--) {
            cout << ((i >> j) & 1);
        }
        cout << "\t" << lookup[i] << "\n";
    }
}

int main() {
    // Initialize the lookup table
    initializeLookup();

    // Print first few entries
    printLookupTable();

    // Test cases
    cout << "\n=== Test Cases ===\n";

    unsigned int test1 = 185;
    cout << "Number: " << test1 << "\n";
    cout << "Binary: ";
    for (int i = 31; i >= 0; i--) {
        cout << ((test1 >> i) & 1);
        if (i % 8 == 0) cout << " ";
    }
    cout << "\nSet bits: " << countSetBits(test1) << "\n\n";

    unsigned int test2 = 123456789;
    cout << "Number: " << test2 << "\n";
    cout << "Binary: ";
    for (int i = 31; i >= 0; i--) {
        cout << ((test2 >> i) & 1);
        if (i % 8 == 0) cout << " ";
    }
    cout << "\nSet bits: " << countSetBits(test2) << "\n\n";

    unsigned int test3 = 4294967295u;  // All 1s (max unsigned int)
    cout << "Number: " << test3 << "\n";
    cout << "Set bits: " << countSetBits(test3) << "\n";

    return 0;
}
```

---

## **Part 10: Why This Works - The Mathematics**

### **Principle: Divide and Conquer**

The count of set bits in a 32-bit number is:

```
Total = (count in bits 0-7) +
        (count in bits 8-15) +
        (count in bits 16-23) +
        (count in bits 24-31)
```

Each chunk is independent, so we can count them separately!

### **Why Lookup is Fast**

```cpp
// Method 1: Check each bit (32 iterations)
for (int i = 0; i < 32; i++) {
    if (n & (1 << i)) count++;
}

// Method 2: Lookup table (4 lookups + 3 additions)
lookup[byte0] + lookup[byte1] + lookup[byte2] + lookup[byte3]
```

**Speed comparison:**

- Bit-by-bit: 32 operations
- Lookup: 4 array accesses + 3 additions = **7 operations**

That's roughly **4-5x faster**!

---

## **Part 11: Variations and Optimizations**

### **Variation 1: 4-bit Lookup (Nibble)**

```cpp
int lookup[16];  // 2^4 = 16 entries

void initializeNibbleLookup() {
    int count[] = {0, 1, 1, 2, 1, 2, 2, 3,
                   1, 2, 2, 3, 2, 3, 3, 4};
    for (int i = 0; i < 16; i++) {
        lookup[i] = count[i];
    }
}

int countSetBitsNibble(unsigned int n) {
    return lookup[n & 0xF] +           // Nibble 0
           lookup[(n >> 4) & 0xF] +    // Nibble 1
           lookup[(n >> 8) & 0xF] +    // Nibble 2
           lookup[(n >> 12) & 0xF] +   // Nibble 3
           lookup[(n >> 16) & 0xF] +   // Nibble 4
           lookup[(n >> 20) & 0xF] +   // Nibble 5
           lookup[(n >> 24) & 0xF] +   // Nibble 6
           lookup[(n >> 28) & 0xF];    // Nibble 7
}
```

**Trade-off:**

- Smaller table (16 vs 256 entries)
- More lookups (8 vs 4)

### **Variation 2: Precomputed Constants**

```cpp
int lookup[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    // ... (continue for all 256 values)
};
```

No initialization needed—table is compile-time constant!

### **Variation 3: For 64-bit Numbers**

```cpp
int countSetBits64(unsigned long long n) {
    return lookup[n & 0xFF] +
           lookup[(n >> 8) & 0xFF] +
           lookup[(n >> 16) & 0xFF] +
           lookup[(n >> 24) & 0xFF] +
           lookup[(n >> 32) & 0xFF] +
           lookup[(n >> 40) & 0xFF] +
           lookup[(n >> 48) & 0xFF] +
           lookup[(n >> 56) & 0xFF];
}
```

---

## **Part 12: Performance Analysis**

### **Time Complexity:**

- **Initialization:** O(256) = O(1) - done once
- **Query:** O(1) - constant time (4 lookups + 3 additions)

### **Space Complexity:**

- O(256) = O(1) - fixed size array

### **Cache Efficiency:**

- Lookup table (256 ints = 1 KB) fits in L1 cache
- Excellent cache locality
- Much faster than branching in loops

---

## **Part 13: When to Use Lookup Table Approach**

✅ **Use when:**

- You need to count set bits **many times**
- Performance is critical
- Memory is not a constraint (1 KB is negligible)
- Working with fixed-width integers (32-bit, 64-bit)

❌ **Don't use when:**

- You only count set bits once or twice (initialization overhead)
- Extremely memory-constrained environment
- Working with arbitrary precision numbers

---

## **Part 14: Real-World Applications**

### **1. Image Processing**

```cpp
// Count black pixels (bit = 1) in binary image
int countBlackPixels(unsigned char* image, int size) {
    int count = 0;
    for (int i = 0; i < size; i++) {
        count += lookup[image[i]];
    }
    return count;
}
```

### **2. Network Programming**

```cpp
// Count set bits in subnet mask
int countNetworkBits(unsigned int mask) {
    return countSetBits(mask);
}
// Example: 255.255.255.0 → 24 bits set
```

### **3. Chess Programming**

```cpp
// Count pieces on board (bitboard representation)
int countPieces(unsigned long long bitboard) {
    return countSetBits64(bitboard);
}
```

---

## **Summary: Why Lookup Table Works**

1. **Pre-computation:** We calculate all possible counts once and store them

2. **Chunking:** Break large number into manageable pieces (bytes)

3. **Independence:** Each byte's set bit count is independent

4. **Fast Access:** Array lookup is O(1) - much faster than iteration

5. **Parallelism potential:** Each byte can be processed independently (CPU can pipeline)

**The key insight:** Trading a small amount of memory (1 KB) for significant speed improvement (4-5x faster)!

This is a classic example of **space-time tradeoff** in computer science! 🚀

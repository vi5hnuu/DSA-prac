https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-BitMagic/problem/maximum-and-value-1587115620

```cpp
class Solution {
  public:
    int maxAND(vector<int>& arr) {
        int sz=arr.size();
        int maxAnd=0;
        for(int i=0;i<sz;i++){
            for(int j=i+1;j<sz;j++){
                maxAnd=max(maxAnd,arr[i]&arr[j]);
            }
        }
        return maxAnd;
    }
};
```

```cpp
class Solution {
  public:
    int maxAND(vector<int>& arr) {
        if (arr.size() < 2) return 0;

        int maxAnd=0;
        int mxEl=*max_element(arr.begin(), arr.end());
        int msbBitPos=log2(mxEl);

        int pattern=0;
        for(int bitPos=msbBitPos;bitPos>=0;bitPos--){
            int condidate=pattern | (1<<bitPos);

            int cnt=0;
            for(int n:arr){
                if((n&condidate)==condidate) cnt++;
                if (cnt >= 2) break;  // Early termination
            }
            if(cnt>=2) pattern=condidate;
        }
        return pattern;
    }
};
```

# Maximum AND Value - Complete Solution

Let me explain this problem from basics to the optimal solution.

---

## **Part 1: Understanding the Problem**

**Goal:** Find the maximum value of `arr[i] & arr[j]` where i ‚â† j

**Example Analysis:**

```
arr[] = [4, 8, 12, 16]

Binary representation:
4  = 0100
8  = 1000
12 = 1100
16 = 10000

All possible pairs and their AND:
4 & 8  = 0100 & 1000 = 0000 = 0
4 & 12 = 0100 & 1100 = 0100 = 4
4 & 16 = 0100 & 10000 = 0000 = 0
8 & 12 = 1000 & 1100 = 1000 = 8  ‚Üê Maximum!
8 & 16 = 1000 & 10000 = 0000 = 0
12 & 16 = 1100 & 10000 = 0000 = 0

Maximum AND = 8
```

---

## **Part 2: Naive Approach (Brute Force)**

### **Algorithm:**

Check all pairs and find maximum AND

```cpp
int maxAND_Naive(vector<int>& arr) {
    int n = arr.size();
    int maxAnd = 0;

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            maxAnd = max(maxAnd, arr[i] & arr[j]);
        }
    }

    return maxAnd;
}
```

**Time Complexity:** O(n¬≤)
**Space Complexity:** O(1)

**Problem:** Too slow for n = 10^5 (would be 10^10 operations)

---

## **Part 3: Key Observations**

### **Observation 1: Greedy from MSB**

To maximize AND value, we want **as many high-order bits set as possible**.

```
Example:
1000 (8)  > 0111 (7)
10000 (16) > 01111 (15)
```

**Strategy:** Start from the most significant bit (MSB) and try to keep it set!

### **Observation 2: AND Properties**

```
For two numbers to have bit i set in their AND:
BOTH numbers must have bit i set!

Example:
12 = 1100
8  = 1000
     ----
AND: 1000

Only bit 3 is common, so only bit 3 is set in AND.
```

### **Observation 3: Pattern-Based Filtering**

If we want the result to have certain bits set, we need **at least 2 numbers** that have those bits set.

```
Example: Want result with pattern 11??
Need at least 2 numbers starting with 11

12 = 1100 ‚úì
13 = 1101 ‚úì
12 & 13 = 1100 ‚úì (keeps the pattern)
```

---

## **Part 4: Optimal Solution - Greedy Bit-by-Bit**

### **Core Idea:**

1. Start with a **pattern = 0**
2. For each bit position from MSB to LSB:
   - Try to set this bit in the pattern
   - Count how many numbers match this pattern
   - If ‚â• 2 numbers match, keep this bit set
   - Otherwise, unset this bit

### **Why This Works:**

- We're building the maximum possible AND value greedily
- At each step, we try to maximize the current bit position
- We only keep a bit if at least 2 numbers can contribute to it

---

## **Part 5: Complete Implementation**

```cpp
class Solution {
public:
    int maxAND(vector<int>& arr) {
        int n = arr.size();

        // Edge case
        if (n < 2) return 0;

        // Find maximum element to determine bit range
        int maxVal = *max_element(arr.begin(), arr.end());

        // Find MSB position
        int msb = 0;
        while ((1 << msb) <= maxVal) {
            msb++;
        }

        int pattern = 0;  // This will store our answer

        // Try to set bits from MSB to LSB
        for (int bit = msb - 1; bit >= 0; bit--) {
            // Try setting this bit
            int candidate = pattern | (1 << bit);

            // Count how many numbers match this pattern
            int count = 0;
            for (int num : arr) {
                if ((num & candidate) == candidate) {
                    count++;
                }
            }

            // If at least 2 numbers match, keep this bit
            if (count >= 2) {
                pattern = candidate;
            }
        }

        return pattern;
    }
};
```

---

## **Part 6: Detailed Trace for arr[] = [4, 8, 12, 16]**

### **Step 1: Setup**

```
arr[] = [4, 8, 12, 16]

Binary:
4  = 00100
8  = 01000
12 = 01100
16 = 10000

maxVal = 16
msb = 5 (because 2^5 = 32 > 16)
pattern = 0 (00000)
```

### **Step 2: Try bit 4 (MSB)**

```
candidate = pattern | (1 << 4) = 0 | 10000 = 10000

Check which numbers have pattern 10000:
4  & 10000 = 00100 & 10000 = 00000 ‚â† 10000 ‚úó
8  & 10000 = 01000 & 10000 = 00000 ‚â† 10000 ‚úó
12 & 10000 = 01100 & 10000 = 00000 ‚â† 10000 ‚úó
16 & 10000 = 10000 & 10000 = 10000 ‚úì

Count = 1 (only 16 matches)
Since count < 2, DON'T set this bit
pattern remains 00000
```

### **Step 3: Try bit 3**

```
candidate = pattern | (1 << 3) = 0 | 01000 = 01000

Check which numbers have pattern 01000:
4  & 01000 = 00100 & 01000 = 00000 ‚â† 01000 ‚úó
8  & 01000 = 01000 & 01000 = 01000 ‚úì
12 & 01000 = 01100 & 01000 = 01000 ‚úì
16 & 01000 = 10000 & 01000 = 00000 ‚â† 01000 ‚úó

Count = 2 (8 and 12 match)
Since count ‚â• 2, SET this bit!
pattern = 01000
```

### **Step 4: Try bit 2**

```
candidate = pattern | (1 << 2) = 01000 | 00100 = 01100

Check which numbers have pattern 01100:
4  & 01100 = 00100 & 01100 = 00100 ‚â† 01100 ‚úó
8  & 01100 = 01000 & 01100 = 01000 ‚â† 01100 ‚úó
12 & 01100 = 01100 & 01100 = 01100 ‚úì
16 & 01100 = 10000 & 01100 = 00000 ‚â† 01100 ‚úó

Count = 1 (only 12 matches)
Since count < 2, DON'T set this bit
pattern remains 01000
```

### **Step 5: Try bit 1**

```
candidate = pattern | (1 << 1) = 01000 | 00010 = 01010

Check which numbers have pattern 01010:
4  & 01010 = 00100 & 01010 = 00000 ‚â† 01010 ‚úó
8  & 01010 = 01000 & 01010 = 01000 ‚â† 01010 ‚úó
12 & 01010 = 01100 & 01010 = 01000 ‚â† 01010 ‚úó
16 & 01010 = 10000 & 01010 = 00000 ‚â† 01010 ‚úó

Count = 0
pattern remains 01000
```

### **Step 6: Try bit 0**

```
candidate = pattern | (1 << 0) = 01000 | 00001 = 01001

Check which numbers have pattern 01001:
4  & 01001 = 00100 & 01001 = 00000 ‚â† 01001 ‚úó
8  & 01001 = 01000 & 01001 = 01000 ‚â† 01001 ‚úó
12 & 01001 = 01100 & 01001 = 01000 ‚â† 01001 ‚úó
16 & 01001 = 10000 & 01001 = 00000 ‚â† 01001 ‚úó

Count = 0
pattern remains 01000
```

### **Final Result:**

```
pattern = 01000 = 8

Verification:
The pair (8, 12) gives: 01000 & 01100 = 01000 = 8 ‚úì
```

---

## **Part 7: Another Example - arr[] = [12, 13, 14, 15]**

```
Binary:
12 = 1100
13 = 1101
14 = 1110
15 = 1111

msb = 4
pattern = 0
```

### **Bit 3:**

```
candidate = 1000

12 & 1000 = 1100 & 1000 = 1000 ‚úì
13 & 1000 = 1101 & 1000 = 1000 ‚úì
14 & 1000 = 1110 & 1000 = 1000 ‚úì
15 & 1000 = 1111 & 1000 = 1000 ‚úì

Count = 4 ‚â• 2
pattern = 1000
```

### **Bit 2:**

```
candidate = 1100

12 & 1100 = 1100 & 1100 = 1100 ‚úì
13 & 1100 = 1101 & 1100 = 1100 ‚úì
14 & 1100 = 1110 & 1100 = 1100 ‚úì
15 & 1100 = 1111 & 1100 = 1100 ‚úì

Count = 4 ‚â• 2
pattern = 1100
```

### **Bit 1:**

```
candidate = 1110

12 & 1110 = 1100 & 1110 = 1100 ‚â† 1110 ‚úó
13 & 1110 = 1101 & 1110 = 1100 ‚â† 1110 ‚úó
14 & 1110 = 1110 & 1110 = 1110 ‚úì
15 & 1110 = 1111 & 1110 = 1110 ‚úì

Count = 2 ‚â• 2
pattern = 1110
```

### **Bit 0:**

```
candidate = 1111

12 & 1111 = 1100 & 1111 = 1100 ‚â† 1111 ‚úó
13 & 1111 = 1101 & 1111 = 1101 ‚â† 1111 ‚úó
14 & 1111 = 1110 & 1111 = 1110 ‚â† 1111 ‚úó
15 & 1111 = 1111 & 1111 = 1111 ‚úì

Count = 1 < 2
pattern remains 1110
```

**Result: 1110 = 14**

**Verification:**

```
14 & 15 = 1110 & 1111 = 1110 = 14 ‚úì
```

---

## **Part 8: Optimized Implementation with Early Termination**

```cpp
class Solution {
public:
    int maxAND(vector<int>& arr) {
        int n = arr.size();
        if (n < 2) return 0;

        // Find the maximum value to determine bit range
        int maxVal = *max_element(arr.begin(), arr.end());

        int pattern = 0;

        // Try to set bits from MSB to LSB
        for (int bit = 31; bit >= 0; bit--) {
            int candidate = pattern | (1 << bit);

            // Count numbers matching this pattern
            int count = 0;
            for (int num : arr) {
                if ((num & candidate) == candidate) {
                    count++;
                    if (count >= 2) break;  // Early termination
                }
            }

            if (count >= 2) {
                pattern = candidate;
            }
        }

        return pattern;
    }
};
```

---

## **Part 9: Further Optimization - Store Candidates**

```cpp
class Solution {
public:
    int maxAND(vector<int>& arr) {
        int n = arr.size();
        if (n < 2) return 0;

        int pattern = 0;
        vector<int> candidates = arr;

        // Try to set bits from MSB to LSB
        for (int bit = 31; bit >= 0; bit--) {
            int newPattern = pattern | (1 << bit);

            // Filter candidates that match new pattern
            vector<int> newCandidates;
            for (int num : candidates) {
                if ((num & newPattern) == newPattern) {
                    newCandidates.push_back(num);
                }
            }

            // If at least 2 candidates, update pattern and candidates
            if (newCandidates.size() >= 2) {
                pattern = newPattern;
                candidates = newCandidates;
            }
        }

        return pattern;
    }
};
```

**Advantage:** Reduces the search space in subsequent iterations!

---

## **Part 10: Complexity Analysis**

### **Time Complexity:**

- **Outer loop:** 32 iterations (for 32 bits)
- **Inner loop:** O(n) in worst case
- **Total:** O(32 √ó n) = **O(n)**

### **Space Complexity:**

- **Basic version:** O(1)
- **Optimized version:** O(n) for storing candidates

### **Comparison:**

| Approach    | Time  | Space | For n=10^5       |
| ----------- | ----- | ----- | ---------------- |
| Brute Force | O(n¬≤) | O(1)  | ~10^10 ops ‚ùå    |
| Greedy Bit  | O(n)  | O(1)  | ~3.2√ó10^6 ops ‚úÖ |

---

## **Part 11: Complete Solution with All Cases**

```cpp
class Solution {
public:
    int maxAND(vector<int>& arr) {
        int n = arr.size();

        // Edge cases
        if (n < 2) return 0;
        if (n == 2) return arr[0] & arr[1];

        int pattern = 0;

        // Try each bit from MSB to LSB
        for (int bit = 31; bit >= 0; bit--) {
            int candidate = pattern | (1 << bit);

            // Count numbers that have all bits of candidate set
            int count = 0;
            for (int num : arr) {
                if ((num & candidate) == candidate) {
                    count++;
                    if (count >= 2) break;  // Early exit
                }
            }

            // If at least 2 numbers match, keep this bit
            if (count >= 2) {
                pattern = candidate;
            }
        }

        return pattern;
    }
};

// Driver code for testing
int main() {
    Solution sol;

    // Test case 1
    vector<int> arr1 = {4, 8, 12, 16};
    cout << "Test 1: " << sol.maxAND(arr1) << " (Expected: 8)\n";

    // Test case 2
    vector<int> arr2 = {4, 8, 16, 2};
    cout << "Test 2: " << sol.maxAND(arr2) << " (Expected: 0)\n";

    // Test case 3
    vector<int> arr3 = {12, 13, 14, 15};
    cout << "Test 3: " << sol.maxAND(arr3) << " (Expected: 14)\n";

    return 0;
}
```

---

## **Summary**

### **Key Insights:**

1. **Greedy works**: Build the answer bit-by-bit from MSB
2. **Pattern matching**: Check if ‚â•2 numbers match each candidate pattern
3. **Early termination**: Stop counting after finding 2 matches

### **Why This is Optimal:**

- We prioritize higher bits (which contribute more to the value)
- We only keep a bit if it's achievable by at least one pair
- Linear time complexity makes it efficient for large inputs

This is a beautiful example of using **bit manipulation** and **greedy strategy** together! üéØ

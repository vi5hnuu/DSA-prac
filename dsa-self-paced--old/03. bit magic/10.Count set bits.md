https://www.geeksforgeeks.org/batch/dsa-4/track/DSASP-BitMagic/problem/count-total-set-bits-1587115620

### TLE

```cpp
class Solution {
  public:
    int countSetBits(int n) {
        int bitSetCount=0;
        for(int i=1;i<=n;i++){
            bitSetCount+=countSetBitsFor(i);
        }
        return bitSetCount;
    }
    int countSetBitsFor(int n) {
        int bitCount=0;
        while(n){
            bitCount++;
            n=n&(n-1);
        }
        return bitCount;
    }
};
```

### TLE

```cpp
class Solution {
    int bitCountLookUp[256];
    void intializeBitCountLookUp(){
        bitCountLookUp[0]=0;
        for(int i=1;i<=255;i++){
            bitCountLookUp[i]= (i&1) + bitCountLookUp[i>>1];
        }
    }
  public:
    Solution(){
        intializeBitCountLookUp();
    }
    int countSetBits(int n) {
        int bitSetCount=0;
        for(int i=1;i<=n;i++){
            bitSetCount+=(bitCountLookUp[i&(0XFF)] +
                bitCountLookUp[(i>>8)&(0XFF)] +
                bitCountLookUp[(i>>16)&(0XFF)] +
                bitCountLookUp[(i>>24)&(0XFF)]);
        }
        return bitSetCount;
    }
};
```

```cpp
class Solution {
    int largestPow2Idx(int n){
        /*int x=0;
        while((1<<x)<=n){
            x++;
        }
        return x-1;*/
        return log2(n);
    }
  public:
    int countSetBits(int n) {
        if(n==0) return 0;
        int k=largestPow2Idx(n);
        int before2x=(1<<(k-1))*k;
        int after2xMsb=n-(1<<k)+1;
        int rest=n-(1<<k);
        return before2x+after2xMsb+countSetBits(rest);
    }
};
```

# Counting Set Bits from 1 to N - Mathematical Approach

This is a **brilliant recursive solution** that counts total set bits in all numbers from 1 to N without iterating through each number! Let me break it down completely.

---

## **The Problem**

**Given:** A number N

**Find:** Total count of set bits in all numbers from 1 to N

**Example:**

```
N = 5
Numbers: 1, 2, 3, 4, 5
Binary:  001, 010, 011, 100, 101

Set bits count:
1 â†’ 1 set bit
2 â†’ 1 set bit
3 â†’ 2 set bits
4 â†’ 1 set bit
5 â†’ 2 set bits

Total = 1 + 1 + 2 + 1 + 2 = 7
```

---

## **Naive Approach (What We Want to Avoid)**

```cpp
int countSetBits(int n) {
    int total = 0;
    for (int i = 1; i <= n; i++) {
        total += __builtin_popcount(i);
    }
    return total;
}
// Time: O(n * log n) - Too slow for large n!
```

---

## **The Mathematical Insight**

### **Key Observation:**

Let's look at numbers from 0 to 7 (2^3 - 1):

```
Decimal | Binary | Position:  2  1  0
--------|--------|-------------------
   0    |  000   |            0  0  0
   1    |  001   |            0  0  1
   2    |  010   |            0  1  0
   3    |  011   |            0  1  1
   4    |  100   |            1  0  0
   5    |  101   |            1  0  1
   6    |  110   |            1  1  0
   7    |  111   |            1  1  1
```

**Pattern Recognition:**

- **Position 0 (rightmost):** Pattern is 01010101 â†’ 4 ones
- **Position 1:** Pattern is 00110011 â†’ 4 ones
- **Position 2 (MSB):** Pattern is 00001111 â†’ 4 ones

**For numbers 0 to 2^k - 1:**

- Each bit position has exactly **2^(k-1)** ones

But what about arbitrary N (not a power of 2)? That's where this algorithm shines!

---

## **Understanding the Code - Step by Step**

### **Part 1: Finding Maximum Power of 2**

```cpp
int maxPowOf2inRangeIndex(int n) {
    int x = 0;
    while ((1 << x) <= n)
        x++;
    return x - 1;
}
```

**Purpose:** Find the position (index) of the highest set bit in N.

**Example:**

```
N = 13 (binary: 1101)

x = 0: (1 << 0) = 1 â‰¤ 13 âœ“, x++
x = 1: (1 << 1) = 2 â‰¤ 13 âœ“, x++
x = 2: (1 << 2) = 4 â‰¤ 13 âœ“, x++
x = 3: (1 << 3) = 8 â‰¤ 13 âœ“, x++
x = 4: (1 << 4) = 16 > 13 âœ—, stop

Return x - 1 = 3

This means: largest power of 2 â‰¤ 13 is 2^3 = 8
```

---

## **Part 2: The Main Algorithm - Three Components**

For N = 13, let's break down the solution:

```
Numbers 1 to 13:
1   = 0001
2   = 0010
3   = 0011
4   = 0100
5   = 0101
6   = 0110
7   = 0111
8   = 1000
9   = 1001
10  = 1010
11  = 1011
12  = 1100
13  = 1101
```

**The algorithm divides this into THREE parts:**

---

### **Component 1: `ttlBits1` - Count from numbers < largest power of 2**

```cpp
int ttlBits1 = (1 << (maxpow2Index - 1)) * maxpow2Index;
```

**What it calculates:** Total set bits in all positions (except MSB) for numbers from 1 to (2^k - 1)

**For N = 13:**

- maxpow2Index = 3
- We look at numbers 0 to 7 (which is 2^3 - 1)

```
Numbers 0-7:
0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111
```

**Pattern in each bit position:**

For range [0, 2^k - 1]:

- Total numbers = 2^k
- Each bit position has 2^(k-1) ones

But we want [1, 2^k - 1] (excluding 0), so:

- Each bit position still contributes equally
- **Formula:** 2^(k-1) ones Ã— k positions = 2^(k-1) Ã— k

**Calculation:**

```
ttlBits1 = (1 << (3 - 1)) Ã— 3
         = (1 << 2) Ã— 3
         = 4 Ã— 3
         = 12
```

**Verification:**

```
Position 0: 1,3,5,7 â†’ 4 ones
Position 1: 2,3,6,7 â†’ 4 ones
Position 2: 4,5,6,7 â†’ 4 ones
Total: 12 âœ“
```

---

### **Component 2: `restmsbSetbit` - Count MSB for numbers â‰¥ 2^k**

```cpp
int restmsbSetbit = n - (1 << maxpow2Index) + 1;
```

**What it calculates:** How many numbers from 1 to N have their MSB set at position `maxpow2Index`

**For N = 13:**

- Numbers from 8 to 13 all have MSB (bit 3) set
- These are: 8, 9, 10, 11, 12, 13

```
8  = 1000  â† MSB set
9  = 1001  â† MSB set
10 = 1010  â† MSB set
11 = 1011  â† MSB set
12 = 1100  â† MSB set
13 = 1101  â† MSB set
```

**Calculation:**

```
restmsbSetbit = 13 - (1 << 3) + 1
              = 13 - 8 + 1
              = 6
```

**This counts the MSB contribution from numbers [8, 13]**

---

### **Component 3: `rest` - Recursively count remaining bits**

```cpp
int rest = n - (1 << maxpow2Index);
int ans = ttlBits1 + restmsbSetbit + countSetBits(rest);
```

**What it calculates:** After removing the MSB from numbers [8, 13], we get [0, 5]. Count set bits in [1, 5] recursively.

**For N = 13:**

```
Numbers 8-13 with MSB removed:
8  = 1000 â†’ 000 (0)
9  = 1001 â†’ 001 (1)
10 = 1010 â†’ 010 (2)
11 = 1011 â†’ 011 (3)
12 = 1100 â†’ 100 (4)
13 = 1101 â†’ 101 (5)
```

**Calculation:**

```
rest = 13 - 8 = 5

Now recursively call: countSetBits(5)
```

---

## **Complete Execution Trace for N = 13**

### **First Call: countSetBits(13)**

```
maxpow2Index = 3 (because 2^3 = 8 â‰¤ 13 < 2^4 = 16)

ttlBits1 = (1 << 2) Ã— 3 = 4 Ã— 3 = 12
(Counts bits in numbers 1-7)

restmsbSetbit = 13 - 8 + 1 = 6
(Counts MSB for numbers 8-13)

rest = 13 - 8 = 5
(Remaining problem: count bits in 1-5)

Recurse: countSetBits(5)
```

### **Second Call: countSetBits(5)**

```
maxpow2Index = 2 (because 2^2 = 4 â‰¤ 5 < 2^3 = 8)

ttlBits1 = (1 << 1) Ã— 2 = 2 Ã— 2 = 4
(Counts bits in numbers 1-3)

restmsbSetbit = 5 - 4 + 1 = 2
(Counts MSB for numbers 4-5)

rest = 5 - 4 = 1
(Remaining problem: count bits in 1)

Recurse: countSetBits(1)
```

### **Third Call: countSetBits(1)**

```
maxpow2Index = 0 (because 2^0 = 1 â‰¤ 1 < 2^1 = 2)

ttlBits1 = (1 << -1) Ã— 0 = 0
(No bits before 2^0)

restmsbSetbit = 1 - 1 + 1 = 1
(Number 1 has MSB set)

rest = 1 - 1 = 0
(No remaining numbers)

Recurse: countSetBits(0)
```

### **Fourth Call: countSetBits(0)**

```
Base case: return 0
```

---

## **Unwinding the Recursion**

```
countSetBits(0) = 0

countSetBits(1) = 0 + 1 + 0 = 1
                  â†‘   â†‘   â†‘
                  |   |   countSetBits(0)
                  |   restmsbSetbit
                  ttlBits1

countSetBits(5) = 4 + 2 + 1 = 7
                  â†‘   â†‘   â†‘
                  |   |   countSetBits(1)
                  |   restmsbSetbit
                  ttlBits1

countSetBits(13) = 12 + 6 + 7 = 25
                   â†‘    â†‘   â†‘
                   |    |   countSetBits(5)
                   |    restmsbSetbit
                   ttlBits1
```

**Final Answer: 25**

---

## **Verification by Brute Force**

```
1  = 0001 â†’ 1 bit
2  = 0010 â†’ 1 bit
3  = 0011 â†’ 2 bits
4  = 0100 â†’ 1 bit
5  = 0101 â†’ 2 bits
6  = 0110 â†’ 2 bits
7  = 0111 â†’ 3 bits
8  = 1000 â†’ 1 bit
9  = 1001 â†’ 2 bits
10 = 1010 â†’ 2 bits
11 = 1011 â†’ 3 bits
12 = 1100 â†’ 2 bits
13 = 1101 â†’ 3 bits

Total = 1+1+2+1+2+2+3+1+2+2+3+2+3 = 25 âœ“
```

---

## **Another Example: N = 7**

```
countSetBits(7):

maxpow2Index = 2 (2^2 = 4 â‰¤ 7 < 2^3 = 8)

ttlBits1 = (1 << 1) Ã— 2 = 2 Ã— 2 = 4
Numbers 1-3: 001, 010, 011 â†’ 4 bits total

restmsbSetbit = 7 - 4 + 1 = 4
Numbers 4-7 all have bit 2 set â†’ 4 bits from MSB

rest = 7 - 4 = 3
Recurse: countSetBits(3)

countSetBits(3):
maxpow2Index = 1 (2^1 = 2 â‰¤ 3 < 2^2 = 4)

ttlBits1 = (1 << 0) Ã— 1 = 1 Ã— 1 = 1
Number 1: 01 â†’ 1 bit

restmsbSetbit = 3 - 2 + 1 = 2
Numbers 2-3 have bit 1 set â†’ 2 bits

rest = 3 - 2 = 1
Recurse: countSetBits(1)

countSetBits(1):
maxpow2Index = 0
ttlBits1 = 0
restmsbSetbit = 1
rest = 0
Recurse: countSetBits(0) = 0

Unwind:
countSetBits(1) = 0 + 1 + 0 = 1
countSetBits(3) = 1 + 2 + 1 = 4
countSetBits(7) = 4 + 4 + 4 = 12
```

**Verify:**

```
1=001 â†’ 1
2=010 â†’ 1
3=011 â†’ 2
4=100 â†’ 1
5=101 â†’ 2
6=110 â†’ 2
7=111 â†’ 3
Total = 12 âœ“
```

---

## **Visual Understanding for N = 13**

```
Range: 1 to 13
Binary representation (4 bits):

      Bit 3  Bit 2  Bit 1  Bit 0
      (MSB)
 1    0      0      0      1
 2    0      0      1      0
 3    0      0      1      1
 4    0      1      0      0
 5    0      1      0      1
 6    0      1      1      0
 7    0      1      1      1
 8    1      0      0      0
 9    1      0      0      1
10    1      0      1      0
11    1      0      1      1
12    1      1      0      0
13    1      1      0      1

Component 1 (ttlBits1 = 12):
Count bits 0,1,2 for numbers 1-7
Bit 0: 4 ones (1,3,5,7)
Bit 1: 4 ones (2,3,6,7)
Bit 2: 4 ones (4,5,6,7)
Total: 12 âœ“

Component 2 (restmsbSetbit = 6):
Count bit 3 for numbers 8-13
All 6 numbers have bit 3 set
Total: 6 âœ“

Component 3 (recursion on rest = 5):
Remove bit 3 from numbers 8-13
We get: 0,1,2,3,4,5
Count bits in 1-5 recursively
Total: 7 âœ“

Grand Total: 12 + 6 + 7 = 25 âœ“
```

---

## **Time Complexity Analysis**

**Recurrence Relation:**

```
T(n) = T(n/2) + O(1)
```

At each step, we reduce the problem size by half (approximately).

**Solution:** T(n) = O(log n)

**Space Complexity:** O(log n) due to recursion stack

**Comparison:**

- Naive: O(n log n)
- This algorithm: **O(log n)** ðŸš€

For n = 10^9:

- Naive: ~30 billion operations
- This: ~30 operations!

---

## **Summary of the Algorithm**

The key insight is **divide and conquer**:

1. **Split the range** at the largest power of 2 (â‰¤ n)

2. **Count three parts:**

   - Bits in the "complete" lower half (closed form formula)
   - MSB contributions from upper half
   - Remaining bits in upper half (recursive call)

3. **Base case:** When n = 0, return 0

This is a beautiful example of finding **mathematical patterns** in binary representations to avoid brute force!

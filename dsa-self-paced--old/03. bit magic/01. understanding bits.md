# Complete Guide to Bitwise Operators for DSA Mastery

Let me give you a comprehensive guide from basics to advanced techniques with real DSA problems.

---

## **Part 1: Understanding Binary Representation First**

Before diving into operators, let's understand how numbers are stored.

### **Binary Representation:**

```
Decimal: 5  ‚Üí  Binary: 0000 0101  (8-bit representation)
Decimal: 3  ‚Üí  Binary: 0000 0011
Decimal: -5 ‚Üí  Binary: 1111 1011  (Two's complement)
```

**Key Concepts:**

- **Bit positions:** Numbered from right to left, starting at 0
- **Positive numbers:** Direct binary representation
- **Negative numbers:** Stored in two's complement form

---

## **Part 2: The Six Core Bitwise Operators**

---

## **1. AND Operator (&)**

### **How it works:**

Returns 1 only if **both bits are 1**, otherwise 0.

### **Truth Table:**

```
A | B | A & B
--|---|------
0 | 0 |  0
0 | 1 |  0
1 | 0 |  0
1 | 1 |  1
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a & b;

/*
    0101  (5)
  & 0011  (3)
  ------
    0001  (1)
*/

cout << c;  // Output: 1
```

### **Common Use Cases:**

#### **Use Case 1: Check if a number is even or odd**

```cpp
bool isOdd(int n) {
    return n & 1;  // If last bit is 1, it's odd
}

// Examples:
5 & 1 = 0101 & 0001 = 0001 = 1 (odd) ‚úì
4 & 1 = 0100 & 0001 = 0000 = 0 (even) ‚úì
```

**Why it works:** In binary, odd numbers always have the last bit as 1.

#### **Use Case 2: Check if a specific bit is set**

```cpp
bool isBitSet(int num, int pos) {
    return (num & (1 << pos)) != 0;
}

// Example: Check if 3rd bit of 13 is set
int num = 13;  // 1101
int pos = 2;   // Check 3rd bit (0-indexed)

/*
13 in binary: 1101
1 << 2 = 0100
1101 & 0100 = 0100 (non-zero, so bit is set)
*/

cout << isBitSet(13, 2);  // Output: 1 (true)
```

#### **Use Case 3: Clear all bits after position i**

```cpp
int clearBitsAfter(int num, int i) {
    int mask = (-1 << (i + 1));  // All 1s, then 0s after position i
    return num & mask;
}

// Example: Clear bits after position 2 in 15 (1111)
clearBitsAfter(15, 2);  // Returns 12 (1100)
```

---

## **2. OR Operator (|)**

### **How it works:**

Returns 1 if **at least one bit is 1**, otherwise 0.

### **Truth Table:**

```
A | B | A | B
--|---|------
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  1
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a | b;

/*
    0101  (5)
  | 0011  (3)
  ------
    0111  (7)
*/

cout << c;  // Output: 7
```

### **Common Use Cases:**

#### **Use Case 1: Set a specific bit**

```cpp
int setBit(int num, int pos) {
    return num | (1 << pos);
}

// Example: Set 2nd bit of 5 (0101)
int result = setBit(5, 1);

/*
5 in binary: 0101
1 << 1 = 0010
0101 | 0010 = 0111 (7)
*/

cout << result;  // Output: 7
```

#### **Use Case 2: Combine multiple flags**

```cpp
// Permission system
const int READ = 1;    // 001
const int WRITE = 2;   // 010
const int EXECUTE = 4; // 100

int permissions = READ | WRITE;  // 001 | 010 = 011 (3)

// Check if has read permission
if (permissions & READ) {
    cout << "Can read";  // Will print
}
```

#### **Use Case 3: Find union of two sets (represented as bitmasks)**

```cpp
// Set A = {0, 2, 3} ‚Üí represented as 1101 (bits 0,2,3 set)
// Set B = {1, 3}    ‚Üí represented as 1010 (bits 1,3 set)

int setA = 0b1101;  // 13
int setB = 0b1010;  // 10
int unionSet = setA | setB;  // 1101 | 1010 = 1111 (15)

// Union = {0, 1, 2, 3}
```

---

## **3. XOR Operator (^)**

### **How it works:**

Returns 1 if bits are **different**, 0 if they're the same.

### **Truth Table:**

```
A | B | A ^ B
--|---|------
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  0
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a ^ b;

/*
    0101  (5)
  ^ 0011  (3)
  ------
    0110  (6)
*/

cout << c;  // Output: 6
```

### **XOR Properties (VERY IMPORTANT!):**

1. **a ^ a = 0** (any number XOR itself is 0)
2. **a ^ 0 = a** (any number XOR 0 is itself)
3. **XOR is commutative:** a ^ b = b ^ a
4. **XOR is associative:** (a ^ b) ^ c = a ^ (b ^ c)

### **Common Use Cases:**

#### **Use Case 1: Swap two numbers without a temp variable**

```cpp
void swap(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;  // b = (a^b) ^ b = a
    a = a ^ b;  // a = (a^b) ^ a = b
}

// Example:
int x = 5, y = 3;
swap(x, y);
cout << x << " " << y;  // Output: 3 5
```

**Step-by-step trace:**

```
Initial: a=5 (0101), b=3 (0011)

Step 1: a = a ^ b = 0101 ^ 0011 = 0110 (6)
        a=6, b=3

Step 2: b = a ^ b = 0110 ^ 0011 = 0101 (5)
        a=6, b=5

Step 3: a = a ^ b = 0110 ^ 0101 = 0011 (3)
        a=3, b=5

Final: a=3, b=5 ‚úì
```

#### **Use Case 2: Find the unique element (all others appear twice)**

```cpp
// Problem: Array has all elements appearing twice except one
int findUnique(vector<int>& arr) {
    int result = 0;
    for (int num : arr) {
        result ^= num;
    }
    return result;  // All pairs cancel out, unique remains
}

// Example: [4, 1, 2, 1, 2]
int arr[] = {4, 1, 2, 1, 2};

/*
result = 0
result ^= 4 ‚Üí 0 ^ 4 = 4
result ^= 1 ‚Üí 4 ^ 1 = 5
result ^= 2 ‚Üí 5 ^ 2 = 7
result ^= 1 ‚Üí 7 ^ 1 = 6
result ^= 2 ‚Üí 6 ^ 2 = 4
*/

// Answer: 4 (the unique element)
```

#### **Use Case 3: Toggle a specific bit**

```cpp
int toggleBit(int num, int pos) {
    return num ^ (1 << pos);
}

// Example: Toggle 2nd bit of 5 (0101)
int result = toggleBit(5, 1);

/*
5 in binary: 0101
1 << 1 = 0010
0101 ^ 0010 = 0111 (7)
*/

cout << result;  // Output: 7

// Toggle again
result = toggleBit(7, 1);  // 0111 ^ 0010 = 0101 (5) - back to original!
```

#### **Use Case 4: Check if two numbers have opposite signs**

```cpp
bool oppositeSigns(int a, int b) {
    return (a ^ b) < 0;
}

// Why? XOR of two numbers with different signs has MSB = 1 (negative)
oppositeSigns(5, -3);   // true
oppositeSigns(5, 3);    // false
oppositeSigns(-5, -3);  // false
```

---

## **4. NOT Operator (~)**

### **How it works:**

Flips all bits (0 ‚Üí 1, 1 ‚Üí 0). This is a **unary operator**.

### **Example:**

```cpp
int a = 5;  // 0000 0101 (8-bit)
int b = ~a;

/*
  ~0000 0101
  -----------
   1111 1010  (This is -6 in two's complement)
*/

cout << b;  // Output: -6
```

### **Why ~5 = -6?**

In two's complement:

- ~5 flips all bits
- The result represents -(5+1) = -6

**Formula:** ~n = -(n+1)

### **Common Use Cases:**

#### **Use Case 1: Create masks**

```cpp
// Create a mask with all 1s except at position i
int createMask(int i) {
    return ~(1 << i);
}

// Example: Create mask to clear 2nd bit
int mask = createMask(2);  // ~(0100) = 1011
int num = 15;              // 1111
int result = num & mask;   // 1111 & 1011 = 1011 (11)
```

#### **Use Case 2: Clear a specific bit**

```cpp
int clearBit(int num, int pos) {
    int mask = ~(1 << pos);
    return num & mask;
}

// Example: Clear 2nd bit of 7 (0111)
clearBit(7, 2);  // 0111 & 1011 = 0011 (3)
```

#### **Use Case 3: Get all 1s of specific length**

```cpp
// Get n bits of 1s
int getAllOnes(int n) {
    return (1 << n) - 1;
}

// Or using NOT:
int getAllOnes2(int n) {
    return ~(~0 << n);
}

getAllOnes(3);   // 0111 = 7
getAllOnes(5);   // 11111 = 31
```

---

## **5. Left Shift Operator (<<)**

### **How it works:**

Shifts all bits to the **left** by n positions, filling with 0s on the right.

### **Example:**

```cpp
int a = 5;       // 0000 0101
int b = a << 1;  // 0000 1010 (10)
int c = a << 2;  // 0001 0100 (20)

cout << b << " " << c;  // Output: 10 20
```

### **Mathematical Meaning:**

**n << k = n √ó 2^k**

```cpp
5 << 1 = 5 √ó 2¬π = 10
5 << 2 = 5 √ó 2¬≤ = 20
5 << 3 = 5 √ó 2¬≥ = 40
```

### **Common Use Cases:**

#### **Use Case 1: Fast multiplication by powers of 2**

```cpp
int multiplyBy8(int n) {
    return n << 3;  // Much faster than n * 8
}

// Examples:
7 << 3 = 56   (7 √ó 8)
10 << 2 = 40  (10 √ó 4)
```

#### **Use Case 2: Create power of 2**

```cpp
int powerOf2(int k) {
    return 1 << k;
}

// Examples:
1 << 0 = 1    (2‚Å∞)
1 << 3 = 8    (2¬≥)
1 << 5 = 32   (2‚Åµ)
```

#### **Use Case 3: Set/Check specific bits (as we saw earlier)**

```cpp
// Check if bit at position i is set
bool checkBit(int num, int i) {
    return (num & (1 << i)) != 0;
}

// Set bit at position i
int setBit(int num, int i) {
    return num | (1 << i);
}
```

#### **Use Case 4: Generate all subsets of a set**

```cpp
void printAllSubsets(vector<int>& arr) {
    int n = arr.size();
    int totalSubsets = 1 << n;  // 2^n subsets

    for (int mask = 0; mask < totalSubsets; mask++) {
        cout << "{ ";
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {  // Check if i-th bit is set
                cout << arr[i] << " ";
            }
        }
        cout << "}\n";
    }
}

// Example: arr = [1, 2, 3]
/*
mask=0 (000): { }
mask=1 (001): { 1 }
mask=2 (010): { 2 }
mask=3 (011): { 1 2 }
mask=4 (100): { 3 }
mask=5 (101): { 1 3 }
mask=6 (110): { 2 3 }
mask=7 (111): { 1 2 3 }
*/
```

---

## **6. Right Shift Operator (>>)**

### **How it works:**

Shifts all bits to the **right** by n positions.

- **Logical shift:** Fills with 0s on the left (for unsigned)
- **Arithmetic shift:** Fills with sign bit (for signed)

### **Example:**

```cpp
int a = 20;      // 0001 0100
int b = a >> 1;  // 0000 1010 (10)
int c = a >> 2;  // 0000 0101 (5)

cout << b << " " << c;  // Output: 10 5
```

### **Mathematical Meaning:**

**n >> k = n / 2^k** (integer division)

```cpp
20 >> 1 = 20 / 2¬π = 10
20 >> 2 = 20 / 2¬≤ = 5
20 >> 3 = 20 / 2¬≥ = 2
```

### **Common Use Cases:**

#### **Use Case 1: Fast division by powers of 2**

```cpp
int divideBy4(int n) {
    return n >> 2;  // Much faster than n / 4
}

// Examples:
32 >> 2 = 8   (32 / 4)
100 >> 3 = 12 (100 / 8)
```

#### **Use Case 2: Extract specific bits**

```cpp
// Get rightmost k bits
int getRightmostBits(int num, int k) {
    return num & ((1 << k) - 1);
}

// Get bits from position i to j
int getBits(int num, int i, int j) {
    int len = j - i + 1;
    int mask = (1 << len) - 1;
    return (num >> i) & mask;
}

// Example: Get bits 2-4 of 27 (11011)
getBits(27, 2, 4);  // Returns 110 (6)
```

#### **Use Case 3: Count trailing zeros**

```cpp
int countTrailingZeros(int n) {
    if (n == 0) return 32;
    int count = 0;
    while ((n & 1) == 0) {
        n >>= 1;
        count++;
    }
    return count;
}

// Examples:
countTrailingZeros(8);   // 1000 ‚Üí 3 zeros
countTrailingZeros(12);  // 1100 ‚Üí 2 zeros
```

---

## **Part 3: Advanced Bit Manipulation Techniques**

### **Technique 1: Check if number is power of 2**

```cpp
bool isPowerOf2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// Why it works:
/*
8 in binary:  1000
7 in binary:  0111
8 & 7:        0000 ‚úì

6 in binary:  0110
5 in binary:  0101
6 & 5:        0100 ‚úó (not zero)

Powers of 2 have exactly one bit set!
*/
```

### **Technique 2: Count number of set bits (Hamming Weight)**

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // Removes rightmost set bit
        count++;
    }
    return count;
}

// Example trace for n = 13 (1101):
/*
Iteration 1: 1101 & 1100 = 1100, count = 1
Iteration 2: 1100 & 1011 = 1000, count = 2
Iteration 3: 1000 & 0111 = 0000, count = 3
Result: 3 set bits ‚úì
*/

// Alternative: Brian Kernighan's Algorithm
```

**Built-in function (GCC):**

```cpp
int count = __builtin_popcount(n);     // for int
int count = __builtin_popcountll(n);   // for long long
```

### **Technique 3: Get rightmost set bit**

```cpp
int getRightmostSetBit(int n) {
    return n & -n;
}

// Why it works:
/*
n = 12 (1100)
-n in two's complement = ~n + 1 = 0011 + 1 = 0100
n & -n = 1100 & 0100 = 0100 (4)

The rightmost set bit is at position 2 (value 4)
*/
```

### **Technique 4: Turn off rightmost set bit**

```cpp
int turnOffRightmost(int n) {
    return n & (n - 1);
}

// Example: 12 (1100) ‚Üí 8 (1000)
```

### **Technique 5: Isolate rightmost 0-bit**

```cpp
int isolateRightmostZero(int n) {
    return ~n & (n + 1);
}

// Example: 13 (1101) has rightmost 0 at position 1
// Result: 0010 (2)
```

### **Technique 6: Check if bits are alternating**

```cpp
bool areAlternating(int n) {
    int xorResult = n ^ (n >> 1);
    return (xorResult & (xorResult + 1)) == 0;
}

// Examples:
areAlternating(5);   // 0101 ‚Üí true
areAlternating(10);  // 1010 ‚Üí true
areAlternating(7);   // 0111 ‚Üí false
```

---

## **Part 4: Classic DSA Problems Using Bitwise Operators**

### **Problem 1: Single Number**

_Every element appears twice except one. Find it._

```cpp
int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

// Time: O(n), Space: O(1)
```

### **Problem 2: Single Number II**

_Every element appears three times except one. Find it._

```cpp
int singleNumber(vector<int>& nums) {
    int ones = 0, twos = 0;

    for (int num : nums) {
        twos |= ones & num;  // Add to twos if already in ones
        ones ^= num;         // Toggle in ones
        int threes = ones & twos;
        ones &= ~threes;     // Remove from ones if in threes
        twos &= ~threes;     // Remove from twos if in threes
    }

    return ones;
}

```
## Explanation: We track bits that appeared once and twice

### **classic bit-manipulation pattern** used to solve a powerful problem efficiently:

> **Find the number that appears once when every other number appears three times** ‚Äî all in *O(n)* time and *O(1)* space.

Let‚Äôs decode this function **line by line**, with intuition, visuals, and a mental model of what‚Äôs going on inside the CPU registers.

---

## üöÄ Problem Statement

You‚Äôre given an array `nums`, where every element appears **three times** except one, which appears **exactly once**.
Return that single element ‚Äî using no extra memory and no hashing.

**Example:**

```cpp
Input:  [2, 2, 3, 2]
Output: 3
```

We‚Äôll track how many times each *bit* has appeared (mod 3).

---

## üí° Core Idea

Every number in binary form has 32 bits (for `int`).

If we could count **how many times each bit (0‚Äì31)** appears across all numbers, then take each count `% 3`,
‚Äî bits that belong to the unique number would remain.

But instead of maintaining a 32-element array of counters,
we **use bitmasks** (`ones`, `twos`, and `threes`) to track counts cleverly.

---

## üß† Meaning of Variables

| Variable | Meaning                                         | What it tracks           |
| -------- | ----------------------------------------------- | ------------------------ |
| `ones`   | bits that have appeared **once (mod 3)**        | ‚Üí single occurrence bits |
| `twos`   | bits that have appeared **twice (mod 3)**       | ‚Üí double occurrence bits |
| `threes` | bits that have appeared **three times (mod 3)** | ‚Üí reset mask             |

We keep flipping bits as they appear ‚Äî using `AND`, `OR`, `XOR`, and `NOT` operations.

---

## ‚öôÔ∏è Step-by-Step Breakdown

```cpp
for (int num : nums) {
    twos |= ones & num;   // 1Ô∏è‚É£
    ones ^= num;          // 2Ô∏è‚É£
    int threes = ones & twos; // 3Ô∏è‚É£
    ones &= ~threes;      // 4Ô∏è‚É£
    twos &= ~threes;      // 5Ô∏è‚É£
}
```

Let's go line by line üëá

---

### üß© Step 1: `twos |= ones & num;`

**Intuition:**
If a bit is already in `ones` and it appears again in `num`,
‚Üí that means this bit has now appeared *twice*,
so add it to `twos`.

**Example (bitwise):**

```
ones: 0010  (bit 1 was seen once)
num:  0010  (bit 1 again)
ones & num ‚Üí 0010 ‚Üí add to twos
```

---

### üß© Step 2: `ones ^= num;`

**Intuition:**
XOR toggles bits ‚Äî it **adds new bits** to `ones` if they weren‚Äôt there,
and **removes them** if they already were.

So this line updates `ones` with the bits that have appeared once (mod 2 currently).

---

### üß© Step 3: `int threes = ones & twos;`

**Intuition:**
Now, if any bit is **set in both** `ones` and `twos`,
it means that bit appeared *three times*.

Store it in `threes`.

---

### üß© Step 4 & 5: Remove bits that appeared three times

```cpp
ones &= ~threes;
twos &= ~threes;
```

We clear out those bits because we only care about counts mod 3.
Once a bit has appeared 3 times, it should reset to 0 in both masks.

---

## üìä Example Walkthrough

Let‚Äôs trace `[2, 2, 3, 2]`

| Step  | num      | ones (binary) | twos (binary) | threes | Explanation                    |
| ----- | -------- | ------------- | ------------- | ------ | ------------------------------ |
| Start | ‚Äî        | 0000          | 0000          | ‚Äî      | all 0                          |
| 1     | 2 (0010) | 0010          | 0000          | 0000   | `ones` = 2                     |
| 2     | 2 (0010) | 0000          | 0010          | 0000   | second time ‚Üí moves to `twos`  |
| 3     | 3 (0011) | 0001          | 0010          | 0000   | bit0 (1) new ‚Üí added to `ones` |
| 4     | 2 (0010) | 0011          | 0000          | 0010   | bit1 appeared thrice ‚Üí removed |

‚úÖ **Final `ones = 0011` ‚Üí 3**

That‚Äôs your answer.

---

## üß© Conceptual Visualization

Each bit position cycles like this:

| Occurrence    | `ones` | `twos`    |
| ------------- | ------ | --------- |
| Seen 1st time | 1      | 0         |
| Seen 2nd time | 0      | 1         |
| Seen 3rd time | 0      | 0 (reset) |

This rotation continues for every bit independently.
The end result is that `ones` holds all bits that appeared **exactly once**.

---

## ‚ö° Why It‚Äôs Elegant

‚úÖ No arrays
‚úÖ No hashmaps
‚úÖ O(1) space
‚úÖ O(n) time
‚úÖ Fully bitwise (constant per operation)

---

## üß≠ TL;DR Mental Model

Think of it as:

> **`ones`, `twos`, and `threes` are 3-bit registers per bit position that cycle through counts mod 3.**
> When you finish the loop, only the bits that appeared once survive in `ones`.

---


### **Problem 3: Single Number III**

_Every element appears twice except two. Find both._

```cpp
vector<int> singleNumber(vector<int>& nums) {
    int xorAll = 0;
    for (int num : nums) {
        xorAll ^= num;  // XOR of the two unique numbers
    }

    // Find rightmost set bit (where the two numbers differ)
    int rightmost = xorAll & -xorAll;

    int num1 = 0, num2 = 0;
    for (int num : nums) {
        if (num & rightmost)
            num1 ^= num;
        else
            num2 ^= num;
    }

    return {num1, num2};
}
```

### **Problem 4: Maximum XOR of Two Numbers**

```cpp
int findMaximumXOR(vector<int>& nums) {
    int maxXOR = 0, mask = 0;

    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);
        set<int> prefixes;

        for (int num : nums) {
            prefixes.insert(num & mask);
        }

        int candidate = maxXOR | (1 << i);
        for (int prefix : prefixes) {
            if (prefixes.count(candidate ^ prefix)) {
                maxXOR = candidate;
                break;
            }
        }
    }

    return maxXOR;
}
```


## **Finding the maximum XOR of any two numbers in an array** ‚Äî all in O(32¬∑n) time, with zero extra data structures beyond a set.

This is a *bit-by-bit greedy construction algorithm*, and it‚Äôs absolutely worth understanding in depth because it builds XOR intuitively from the **most significant bit (MSB)** downward.

---

## üß© Problem Statement

Given an array `nums`,
find two numbers `a` and `b` such that their XOR (`a ^ b`) is **maximum** among all pairs.

Return that maximum XOR value.

**Example:**

```cpp
Input:  [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: 5 ^ 25 = 28
```

---

## üß† Intuition: Build XOR Bit-by-Bit

Instead of comparing all pairs (O(n¬≤)),
we can **construct the maximum XOR one bit at a time** ‚Äî from the **MSB (bit 31)** to the **LSB (bit 0)**.

At each bit position `i`, we ask:

> ‚ÄúCan we set this bit to 1 in the final XOR result?‚Äù

We tentatively try to make this bit `1`, and then *verify if it‚Äôs possible* using prefixes of numbers seen so far (masked up to bit `i`).

---

## ‚öôÔ∏è Step-by-Step Breakdown

```cpp
int findMaximumXOR(vector<int>& nums) {
    int maxXOR = 0, mask = 0;

    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);          // 1Ô∏è‚É£ Include the current bit in the mask
        set<int> prefixes;

        for (int num : nums) {
            prefixes.insert(num & mask);  // 2Ô∏è‚É£ Store prefixes (nums truncated to current bits)
        }

        int candidate = maxXOR | (1 << i);  // 3Ô∏è‚É£ Try to set this bit to 1

        for (int prefix : prefixes) {
            // 4Ô∏è‚É£ If there exist two prefixes that can achieve this XOR candidate
            if (prefixes.count(candidate ^ prefix)) {
                maxXOR = candidate;  // ‚úÖ It's possible! Keep this bit set.
                break;
            }
        }
    }

    return maxXOR;
}
```

---

## üß© Let‚Äôs Walk Through It

Take input:

```
nums = [3, 10, 5, 25, 2, 8]
```

### Step 0 ‚Äì Initialization

```
maxXOR = 0
mask = 0
```

We‚Äôll process bits from **31 ‚Üí 0**, progressively revealing more of the numbers.

---

### üß† Step 1 ‚Äì Understanding the Mask

At each iteration:

```cpp
mask |= (1 << i);
```

If `i = 31`, mask = `1000...0`
If `i = 30`, mask = `1100...0`, and so on.

Essentially, we‚Äôre *keeping only the leftmost (higher) bits* of each number to test prefixes.

---

### üß© Step 2 ‚Äì Building Prefixes

For each number `num`,
we insert `(num & mask)` into `prefixes`.

Example (simplified to 5 bits for clarity):

| num | binary | mask (11100) | num & mask | prefix |
| --- | ------ | ------------ | ---------- | ------ |
| 3   | 00011  | 11100        | 00000      | 0      |
| 10  | 01010  | 11100        | 01000      | 8      |
| 5   | 00101  | 11100        | 00100      | 4      |
| 25  | 11001  | 11100        | 11000      | 24     |
| 2   | 00010  | 11100        | 00000      | 0      |
| 8   | 01000  | 11100        | 01000      | 8      |

So `prefixes = {0, 4, 8, 24}` at this step.

These represent the **higher bits** of all numbers so far.

---

### üß† Step 3 ‚Äì Try to Set Current Bit in maxXOR

We now **tentatively** assume:

> Maybe this bit can be 1.

```cpp
int candidate = maxXOR | (1 << i);
```

Example:
If `maxXOR = 20` (10100) and we‚Äôre checking bit `2`,
then `candidate = 10100 | 00100 = 10100` (still 20, or 28 if bit wasn‚Äôt set before).

---

### üß© Step 4 ‚Äì Check If It‚Äôs Possible

Here‚Äôs the magic:

```cpp
if (prefixes.count(candidate ^ prefix))
```

If for any prefix `p1`, there exists another prefix `p2` such that:

```
p1 ^ p2 == candidate
```

then it means two numbers in the array can yield that XOR at this bit level.

**Reasoning:**
If `p1 ^ p2 = candidate`,
then there exist two numbers whose prefixes produce the desired high bits of the XOR.

Thus, it‚Äôs possible to have a `1` at this bit position in the final XOR.

If yes ‚Üí update `maxXOR = candidate`.

If no ‚Üí keep the bit as 0.

---

## üîç Example Visualization (Simplified 5-bit version)

### Iteration by bit (MSB ‚Üí LSB)

| Bit | mask  | candidate | Is possible? | maxXOR     |
| --- | ----- | --------- | ------------ | ---------- |
| 4   | 10000 | 10000     | ‚úÖ yes        | 10000 (16) |
| 3   | 11000 | 11000     | ‚úÖ yes        | 11000 (24) |
| 2   | 11100 | 11100     | ‚úÖ yes        | 11100 (28) |
| 1   | 11110 | 11110     | ‚ùå no         | 11100 (28) |
| 0   | 11111 | 11101     | ‚ùå no         | 11100 (28) |

‚úÖ Final answer = `11100` (binary) = **28**.

---

## ‚ö° Complexity

| Metric | Value                   |
| ------ | ----------------------- |
| Time   | O(32 √ó n) ‚âà O(n)        |
| Space  | O(n) (for prefixes set) |

---

## üß≠ Intuitive Summary

Think of it like **bitwise progressive guessing**:

1. Start from the top bit.
2. Tentatively set it to 1.
3. Check if any two numbers can achieve that XOR given their current prefixes.
4. If yes ‚Üí lock in that bit.
5. Repeat for the next lower bit.

At the end, you‚Äôve *greedily built the largest possible XOR value*.

---

## üß© Bonus: Visualization Analogy

Imagine each number as a ‚Äúpath‚Äù in a binary trie.
This algorithm essentially *builds the trie in your mind without explicitly creating it*,
and tests whether two paths can diverge at the current bit to make the XOR higher.

It‚Äôs a **space-optimized trie-based XOR search**.

---

## ‚úÖ TL;DR

| Step | What It Does               | Why It Works               |
| ---- | -------------------------- | -------------------------- |
| 1Ô∏è‚É£  | Build mask bit-by-bit      | Keeps leftmost bits        |
| 2Ô∏è‚É£  | Record prefixes            | Capture possible high bits |
| 3Ô∏è‚É£  | Try setting new bit in XOR | Greedy choice              |
| 4Ô∏è‚É£  | Verify existence using set | Ensures achievable XOR     |
| ‚úÖ    | Update `maxXOR`            | Lock in confirmed bit      |

Final `maxXOR` = **maximum XOR of any two numbers in nums** üéØ

---

### **Problem 5: Subset Generation**

```cpp
void generateSubsets(vector<int>& nums) {
    int n = nums.size();
    int totalSubsets = 1 << n;  // 2^n

    for (int mask = 0; mask < totalSubsets; mask++) {
        vector<int> subset;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
            }
        }
        // Process subset
    }
}
```

### **Problem 6: Number of 1 Bits (Hamming Weight)**

```cpp
int hammingWeight(uint32_t n) {
    int count = 0;
    while (n) {
        n &= (n - 1);  // Turn off rightmost 1
        count++;
    }
    return count;
}
```

### **Problem 7: Reverse Bits**

```cpp
uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    for (int i = 0; i < 32; i++) {
        result <<= 1;           // Make space for next bit
        result |= (n & 1);      // Add rightmost bit of n
        n >>= 1;                // Move to next bit
    }
    return result;
}
```

### **Problem 8: Power of Two**

```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

### **Problem 9: Power of Four**

```cpp
bool isPowerOfFour(int n) {
    // Must be power of 2 AND set bit must be at even position
    return n > 0 &&
           (n & (n - 1)) == 0 &&
           (n & 0x55555555) != 0;  // 0x55555555 = 01010101...
}
```

### **Problem 10: Missing Number**

```cpp
int missingNumber(vector<int>& nums) {
    int result = nums.size();
    for (int i = 0; i < nums.size(); i++) {
        result ^= i ^ nums[i];
    }
    return result;
}

// All numbers cancel except the missing one!
```

---

## **Part 5: Bit Manipulation Tricks Cheat Sheet**

```cpp
// Check if k-th bit is set
bool isSet = (n & (1 << k)) != 0;

// Set k-th bit
n |= (1 << k);

// Clear k-th bit
n &= ~(1 << k);

// Toggle k-th bit
n ^= (1 << k);

// Turn off rightmost 1
n &= (n - 1);

// Isolate rightmost 1
rightmost = n & -n;

// Check if power of 2
isPow2 = (n > 0) && ((n & (n - 1)) == 0);

// Get rightmost k bits
mask = (1 << k) - 1;
result = n & mask;

// Swap two numbers
a ^= b; b ^= a; a ^= b;

// Get absolute value (for negative numbers in two's complement)
abs = (n ^ (n >> 31)) - (n >> 31);

// Check if same sign
sameSign = (a ^ b) >= 0;

// Multiply by 2^k
n << k;

// Divide by 2^k
n >> k;

// Modulo 2^k
n & ((1 << k) - 1);

// Check if n is divisible by 2^k
(n & ((1 << k) - 1)) == 0;
```

---

## **Summary: When to Use Each Operator**

| Operator | Primary Use Cases                                    |
| -------- | ---------------------------------------------------- |
| **&**    | Check bits, clear bits, masks, even/odd check        |
| **\|**   | Set bits, combine flags, union operations            |
| **^**    | Toggle bits, find unique elements, swap without temp |
| **~**    | Create complement masks, flip all bits               |
| **<<**   | Multiply by 2^k, create powers of 2, generate masks  |
| **>>**   | Divide by 2^k, extract bits, shift processing        |

**Key Principle:** Bitwise operations are O(1) and incredibly fast‚Äîuse them whenever you can to optimize your code!

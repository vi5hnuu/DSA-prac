# Complete Guide to Bitwise Operators for DSA Mastery

Let me give you a comprehensive guide from basics to advanced techniques with real DSA problems.

---

## **Part 1: Understanding Binary Representation First**

Before diving into operators, let's understand how numbers are stored.

### **Binary Representation:**

```
Decimal: 5  →  Binary: 0000 0101  (8-bit representation)
Decimal: 3  →  Binary: 0000 0011
Decimal: -5 →  Binary: 1111 1011  (Two's complement)
```

**Key Concepts:**

- **Bit positions:** Numbered from right to left, starting at 0
- **Positive numbers:** Direct binary representation
- **Negative numbers:** Stored in two's complement form

---

## **Part 2: The Six Core Bitwise Operators**

---

## **1. AND Operator (&)**

### **How it works:**

Returns 1 only if **both bits are 1**, otherwise 0.

### **Truth Table:**

```
A | B | A & B
--|---|------
0 | 0 |  0
0 | 1 |  0
1 | 0 |  0
1 | 1 |  1
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a & b;

/*
    0101  (5)
  & 0011  (3)
  ------
    0001  (1)
*/

cout << c;  // Output: 1
```

### **Common Use Cases:**

#### **Use Case 1: Check if a number is even or odd**

```cpp
bool isOdd(int n) {
    return n & 1;  // If last bit is 1, it's odd
}

// Examples:
5 & 1 = 0101 & 0001 = 0001 = 1 (odd) ✓
4 & 1 = 0100 & 0001 = 0000 = 0 (even) ✓
```

**Why it works:** In binary, odd numbers always have the last bit as 1.

#### **Use Case 2: Check if a specific bit is set**

```cpp
bool isBitSet(int num, int pos) {
    return (num & (1 << pos)) != 0;
}

// Example: Check if 3rd bit of 13 is set
int num = 13;  // 1101
int pos = 2;   // Check 3rd bit (0-indexed)

/*
13 in binary: 1101
1 << 2 = 0100
1101 & 0100 = 0100 (non-zero, so bit is set)
*/

cout << isBitSet(13, 2);  // Output: 1 (true)
```

#### **Use Case 3: Clear all bits after position i**

```cpp
int clearBitsAfter(int num, int i) {
    int mask = (-1 << (i + 1));  // All 1s, then 0s after position i
    return num & mask;
}

// Example: Clear bits after position 2 in 15 (1111)
clearBitsAfter(15, 2);  // Returns 12 (1100)
```

---

## **2. OR Operator (|)**

### **How it works:**

Returns 1 if **at least one bit is 1**, otherwise 0.

### **Truth Table:**

```
A | B | A | B
--|---|------
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  1
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a | b;

/*
    0101  (5)
  | 0011  (3)
  ------
    0111  (7)
*/

cout << c;  // Output: 7
```

### **Common Use Cases:**

#### **Use Case 1: Set a specific bit**

```cpp
int setBit(int num, int pos) {
    return num | (1 << pos);
}

// Example: Set 2nd bit of 5 (0101)
int result = setBit(5, 1);

/*
5 in binary: 0101
1 << 1 = 0010
0101 | 0010 = 0111 (7)
*/

cout << result;  // Output: 7
```

#### **Use Case 2: Combine multiple flags**

```cpp
// Permission system
const int READ = 1;    // 001
const int WRITE = 2;   // 010
const int EXECUTE = 4; // 100

int permissions = READ | WRITE;  // 001 | 010 = 011 (3)

// Check if has read permission
if (permissions & READ) {
    cout << "Can read";  // Will print
}
```

#### **Use Case 3: Find union of two sets (represented as bitmasks)**

```cpp
// Set A = {0, 2, 3} → represented as 1101 (bits 0,2,3 set)
// Set B = {1, 3}    → represented as 1010 (bits 1,3 set)

int setA = 0b1101;  // 13
int setB = 0b1010;  // 10
int unionSet = setA | setB;  // 1101 | 1010 = 1111 (15)

// Union = {0, 1, 2, 3}
```

---

## **3. XOR Operator (^)**

### **How it works:**

Returns 1 if bits are **different**, 0 if they're the same.

### **Truth Table:**

```
A | B | A ^ B
--|---|------
0 | 0 |  0
0 | 1 |  1
1 | 0 |  1
1 | 1 |  0
```

### **Example:**

```cpp
int a = 5;  // 0101
int b = 3;  // 0011
int c = a ^ b;

/*
    0101  (5)
  ^ 0011  (3)
  ------
    0110  (6)
*/

cout << c;  // Output: 6
```

### **XOR Properties (VERY IMPORTANT!):**

1. **a ^ a = 0** (any number XOR itself is 0)
2. **a ^ 0 = a** (any number XOR 0 is itself)
3. **XOR is commutative:** a ^ b = b ^ a
4. **XOR is associative:** (a ^ b) ^ c = a ^ (b ^ c)

### **Common Use Cases:**

#### **Use Case 1: Swap two numbers without a temp variable**

```cpp
void swap(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;  // b = (a^b) ^ b = a
    a = a ^ b;  // a = (a^b) ^ a = b
}

// Example:
int x = 5, y = 3;
swap(x, y);
cout << x << " " << y;  // Output: 3 5
```

**Step-by-step trace:**

```
Initial: a=5 (0101), b=3 (0011)

Step 1: a = a ^ b = 0101 ^ 0011 = 0110 (6)
        a=6, b=3

Step 2: b = a ^ b = 0110 ^ 0011 = 0101 (5)
        a=6, b=5

Step 3: a = a ^ b = 0110 ^ 0101 = 0011 (3)
        a=3, b=5

Final: a=3, b=5 ✓
```

#### **Use Case 2: Find the unique element (all others appear twice)**

```cpp
// Problem: Array has all elements appearing twice except one
int findUnique(vector<int>& arr) {
    int result = 0;
    for (int num : arr) {
        result ^= num;
    }
    return result;  // All pairs cancel out, unique remains
}

// Example: [4, 1, 2, 1, 2]
int arr[] = {4, 1, 2, 1, 2};

/*
result = 0
result ^= 4 → 0 ^ 4 = 4
result ^= 1 → 4 ^ 1 = 5
result ^= 2 → 5 ^ 2 = 7
result ^= 1 → 7 ^ 1 = 6
result ^= 2 → 6 ^ 2 = 4
*/

// Answer: 4 (the unique element)
```

#### **Use Case 3: Toggle a specific bit**

```cpp
int toggleBit(int num, int pos) {
    return num ^ (1 << pos);
}

// Example: Toggle 2nd bit of 5 (0101)
int result = toggleBit(5, 1);

/*
5 in binary: 0101
1 << 1 = 0010
0101 ^ 0010 = 0111 (7)
*/

cout << result;  // Output: 7

// Toggle again
result = toggleBit(7, 1);  // 0111 ^ 0010 = 0101 (5) - back to original!
```

#### **Use Case 4: Check if two numbers have opposite signs**

```cpp
bool oppositeSigns(int a, int b) {
    return (a ^ b) < 0;
}

// Why? XOR of two numbers with different signs has MSB = 1 (negative)
oppositeSigns(5, -3);   // true
oppositeSigns(5, 3);    // false
oppositeSigns(-5, -3);  // false
```

---

## **4. NOT Operator (~)**

### **How it works:**

Flips all bits (0 → 1, 1 → 0). This is a **unary operator**.

### **Example:**

```cpp
int a = 5;  // 0000 0101 (8-bit)
int b = ~a;

/*
  ~0000 0101
  -----------
   1111 1010  (This is -6 in two's complement)
*/

cout << b;  // Output: -6
```

### **Why ~5 = -6?**

In two's complement:

- ~5 flips all bits
- The result represents -(5+1) = -6

**Formula:** ~n = -(n+1)

### **Common Use Cases:**

#### **Use Case 1: Create masks**

```cpp
// Create a mask with all 1s except at position i
int createMask(int i) {
    return ~(1 << i);
}

// Example: Create mask to clear 2nd bit
int mask = createMask(2);  // ~(0100) = 1011
int num = 15;              // 1111
int result = num & mask;   // 1111 & 1011 = 1011 (11)
```

#### **Use Case 2: Clear a specific bit**

```cpp
int clearBit(int num, int pos) {
    int mask = ~(1 << pos);
    return num & mask;
}

// Example: Clear 2nd bit of 7 (0111)
clearBit(7, 2);  // 0111 & 1011 = 0011 (3)
```

#### **Use Case 3: Get all 1s of specific length**

```cpp
// Get n bits of 1s
int getAllOnes(int n) {
    return (1 << n) - 1;
}

// Or using NOT:
int getAllOnes2(int n) {
    return ~(~0 << n);
}

getAllOnes(3);   // 0111 = 7
getAllOnes(5);   // 11111 = 31
```

---

## **5. Left Shift Operator (<<)**

### **How it works:**

Shifts all bits to the **left** by n positions, filling with 0s on the right.

### **Example:**

```cpp
int a = 5;       // 0000 0101
int b = a << 1;  // 0000 1010 (10)
int c = a << 2;  // 0001 0100 (20)

cout << b << " " << c;  // Output: 10 20
```

### **Mathematical Meaning:**

**n << k = n × 2^k**

```cpp
5 << 1 = 5 × 2¹ = 10
5 << 2 = 5 × 2² = 20
5 << 3 = 5 × 2³ = 40
```

### **Common Use Cases:**

#### **Use Case 1: Fast multiplication by powers of 2**

```cpp
int multiplyBy8(int n) {
    return n << 3;  // Much faster than n * 8
}

// Examples:
7 << 3 = 56   (7 × 8)
10 << 2 = 40  (10 × 4)
```

#### **Use Case 2: Create power of 2**

```cpp
int powerOf2(int k) {
    return 1 << k;
}

// Examples:
1 << 0 = 1    (2⁰)
1 << 3 = 8    (2³)
1 << 5 = 32   (2⁵)
```

#### **Use Case 3: Set/Check specific bits (as we saw earlier)**

```cpp
// Check if bit at position i is set
bool checkBit(int num, int i) {
    return (num & (1 << i)) != 0;
}

// Set bit at position i
int setBit(int num, int i) {
    return num | (1 << i);
}
```

#### **Use Case 4: Generate all subsets of a set**

```cpp
void printAllSubsets(vector<int>& arr) {
    int n = arr.size();
    int totalSubsets = 1 << n;  // 2^n subsets

    for (int mask = 0; mask < totalSubsets; mask++) {
        cout << "{ ";
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {  // Check if i-th bit is set
                cout << arr[i] << " ";
            }
        }
        cout << "}\n";
    }
}

// Example: arr = [1, 2, 3]
/*
mask=0 (000): { }
mask=1 (001): { 1 }
mask=2 (010): { 2 }
mask=3 (011): { 1 2 }
mask=4 (100): { 3 }
mask=5 (101): { 1 3 }
mask=6 (110): { 2 3 }
mask=7 (111): { 1 2 3 }
*/
```

---

## **6. Right Shift Operator (>>)**

### **How it works:**

Shifts all bits to the **right** by n positions.

- **Logical shift:** Fills with 0s on the left (for unsigned)
- **Arithmetic shift:** Fills with sign bit (for signed)

### **Example:**

```cpp
int a = 20;      // 0001 0100
int b = a >> 1;  // 0000 1010 (10)
int c = a >> 2;  // 0000 0101 (5)

cout << b << " " << c;  // Output: 10 5
```

### **Mathematical Meaning:**

**n >> k = n / 2^k** (integer division)

```cpp
20 >> 1 = 20 / 2¹ = 10
20 >> 2 = 20 / 2² = 5
20 >> 3 = 20 / 2³ = 2
```

### **Common Use Cases:**

#### **Use Case 1: Fast division by powers of 2**

```cpp
int divideBy4(int n) {
    return n >> 2;  // Much faster than n / 4
}

// Examples:
32 >> 2 = 8   (32 / 4)
100 >> 3 = 12 (100 / 8)
```

#### **Use Case 2: Extract specific bits**

```cpp
// Get rightmost k bits
int getRightmostBits(int num, int k) {
    return num & ((1 << k) - 1);
}

// Get bits from position i to j
int getBits(int num, int i, int j) {
    int len = j - i + 1;
    int mask = (1 << len) - 1;
    return (num >> i) & mask;
}

// Example: Get bits 2-4 of 27 (11011)
getBits(27, 2, 4);  // Returns 110 (6)
```

#### **Use Case 3: Count trailing zeros**

```cpp
int countTrailingZeros(int n) {
    if (n == 0) return 32;
    int count = 0;
    while ((n & 1) == 0) {
        n >>= 1;
        count++;
    }
    return count;
}

// Examples:
countTrailingZeros(8);   // 1000 → 3 zeros
countTrailingZeros(12);  // 1100 → 2 zeros
```

---

## **Part 3: Advanced Bit Manipulation Techniques**

### **Technique 1: Check if number is power of 2**

```cpp
bool isPowerOf2(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}

// Why it works:
/*
8 in binary:  1000
7 in binary:  0111
8 & 7:        0000 ✓

6 in binary:  0110
5 in binary:  0101
6 & 5:        0100 ✗ (not zero)

Powers of 2 have exactly one bit set!
*/
```

### **Technique 2: Count number of set bits (Hamming Weight)**

```cpp
int countSetBits(int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // Removes rightmost set bit
        count++;
    }
    return count;
}

// Example trace for n = 13 (1101):
/*
Iteration 1: 1101 & 1100 = 1100, count = 1
Iteration 2: 1100 & 1011 = 1000, count = 2
Iteration 3: 1000 & 0111 = 0000, count = 3
Result: 3 set bits ✓
*/

// Alternative: Brian Kernighan's Algorithm
```

**Built-in function (GCC):**

```cpp
int count = __builtin_popcount(n);     // for int
int count = __builtin_popcountll(n);   // for long long
```

### **Technique 3: Get rightmost set bit**

```cpp
int getRightmostSetBit(int n) {
    return n & -n;
}

// Why it works:
/*
n = 12 (1100)
-n in two's complement = ~n + 1 = 0011 + 1 = 0100
n & -n = 1100 & 0100 = 0100 (4)

The rightmost set bit is at position 2 (value 4)
*/
```

### **Technique 4: Turn off rightmost set bit**

```cpp
int turnOffRightmost(int n) {
    return n & (n - 1);
}

// Example: 12 (1100) → 8 (1000)
```

### **Technique 5: Isolate rightmost 0-bit**

```cpp
int isolateRightmostZero(int n) {
    return ~n & (n + 1);
}

// Example: 13 (1101) has rightmost 0 at position 1
// Result: 0010 (2)
```

### **Technique 6: Check if bits are alternating**

```cpp
bool areAlternating(int n) {
    int xorResult = n ^ (n >> 1);
    return (xorResult & (xorResult + 1)) == 0;
}

// Examples:
areAlternating(5);   // 0101 → true
areAlternating(10);  // 1010 → true
areAlternating(7);   // 0111 → false
```

---

## **Part 4: Classic DSA Problems Using Bitwise Operators**

### **Problem 1: Single Number**

_Every element appears twice except one. Find it._

```cpp
int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}

// Time: O(n), Space: O(1)
```

### **Problem 2: Single Number II**

_Every element appears three times except one. Find it._

```cpp
int singleNumber(vector<int>& nums) {
    int ones = 0, twos = 0;

    for (int num : nums) {
        twos |= ones & num;  // Add to twos if already in ones
        ones ^= num;         // Toggle in ones
        int threes = ones & twos;
        ones &= ~threes;     // Remove from ones if in threes
        twos &= ~threes;     // Remove from twos if in threes
    }

    return ones;
}

```
## Explanation: We track bits that appeared once and twice

### **classic bit-manipulation pattern** used to solve a powerful problem efficiently:

> **Find the number that appears once when every other number appears three times** — all in *O(n)* time and *O(1)* space.

Let’s decode this function **line by line**, with intuition, visuals, and a mental model of what’s going on inside the CPU registers.

---

## 🚀 Problem Statement

You’re given an array `nums`, where every element appears **three times** except one, which appears **exactly once**.
Return that single element — using no extra memory and no hashing.

**Example:**

```cpp
Input:  [2, 2, 3, 2]
Output: 3
```

We’ll track how many times each *bit* has appeared (mod 3).

---

## 💡 Core Idea

Every number in binary form has 32 bits (for `int`).

If we could count **how many times each bit (0–31)** appears across all numbers, then take each count `% 3`,
— bits that belong to the unique number would remain.

But instead of maintaining a 32-element array of counters,
we **use bitmasks** (`ones`, `twos`, and `threes`) to track counts cleverly.

---

## 🧠 Meaning of Variables

| Variable | Meaning                                         | What it tracks           |
| -------- | ----------------------------------------------- | ------------------------ |
| `ones`   | bits that have appeared **once (mod 3)**        | → single occurrence bits |
| `twos`   | bits that have appeared **twice (mod 3)**       | → double occurrence bits |
| `threes` | bits that have appeared **three times (mod 3)** | → reset mask             |

We keep flipping bits as they appear — using `AND`, `OR`, `XOR`, and `NOT` operations.

---

## ⚙️ Step-by-Step Breakdown

```cpp
for (int num : nums) {
    twos |= ones & num;   // 1️⃣
    ones ^= num;          // 2️⃣
    int threes = ones & twos; // 3️⃣
    ones &= ~threes;      // 4️⃣
    twos &= ~threes;      // 5️⃣
}
```

Let's go line by line 👇

---

### 🧩 Step 1: `twos |= ones & num;`

**Intuition:**
If a bit is already in `ones` and it appears again in `num`,
→ that means this bit has now appeared *twice*,
so add it to `twos`.

**Example (bitwise):**

```
ones: 0010  (bit 1 was seen once)
num:  0010  (bit 1 again)
ones & num → 0010 → add to twos
```

---

### 🧩 Step 2: `ones ^= num;`

**Intuition:**
XOR toggles bits — it **adds new bits** to `ones` if they weren’t there,
and **removes them** if they already were.

So this line updates `ones` with the bits that have appeared once (mod 2 currently).

---

### 🧩 Step 3: `int threes = ones & twos;`

**Intuition:**
Now, if any bit is **set in both** `ones` and `twos`,
it means that bit appeared *three times*.

Store it in `threes`.

---

### 🧩 Step 4 & 5: Remove bits that appeared three times

```cpp
ones &= ~threes;
twos &= ~threes;
```

We clear out those bits because we only care about counts mod 3.
Once a bit has appeared 3 times, it should reset to 0 in both masks.

---

## 📊 Example Walkthrough

Let’s trace `[2, 2, 3, 2]`

| Step  | num      | ones (binary) | twos (binary) | threes | Explanation                    |
| ----- | -------- | ------------- | ------------- | ------ | ------------------------------ |
| Start | —        | 0000          | 0000          | —      | all 0                          |
| 1     | 2 (0010) | 0010          | 0000          | 0000   | `ones` = 2                     |
| 2     | 2 (0010) | 0000          | 0010          | 0000   | second time → moves to `twos`  |
| 3     | 3 (0011) | 0001          | 0010          | 0000   | bit0 (1) new → added to `ones` |
| 4     | 2 (0010) | 0011          | 0000          | 0010   | bit1 appeared thrice → removed |

✅ **Final `ones = 0011` → 3**

That’s your answer.

---

## 🧩 Conceptual Visualization

Each bit position cycles like this:

| Occurrence    | `ones` | `twos`    |
| ------------- | ------ | --------- |
| Seen 1st time | 1      | 0         |
| Seen 2nd time | 0      | 1         |
| Seen 3rd time | 0      | 0 (reset) |

This rotation continues for every bit independently.
The end result is that `ones` holds all bits that appeared **exactly once**.

---

## ⚡ Why It’s Elegant

✅ No arrays
✅ No hashmaps
✅ O(1) space
✅ O(n) time
✅ Fully bitwise (constant per operation)

---

## 🧭 TL;DR Mental Model

Think of it as:

> **`ones`, `twos`, and `threes` are 3-bit registers per bit position that cycle through counts mod 3.**
> When you finish the loop, only the bits that appeared once survive in `ones`.

---


### **Problem 3: Single Number III**

_Every element appears twice except two. Find both._

```cpp
vector<int> singleNumber(vector<int>& nums) {
    int xorAll = 0;
    for (int num : nums) {
        xorAll ^= num;  // XOR of the two unique numbers
    }

    // Find rightmost set bit (where the two numbers differ)
    int rightmost = xorAll & -xorAll;

    int num1 = 0, num2 = 0;
    for (int num : nums) {
        if (num & rightmost)
            num1 ^= num;
        else
            num2 ^= num;
    }

    return {num1, num2};
}
```

### **Problem 4: Maximum XOR of Two Numbers**

```cpp
int findMaximumXOR(vector<int>& nums) {
    int maxXOR = 0, mask = 0;

    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);
        set<int> prefixes;

        for (int num : nums) {
            prefixes.insert(num & mask);
        }

        int candidate = maxXOR | (1 << i);
        for (int prefix : prefixes) {
            if (prefixes.count(candidate ^ prefix)) {
                maxXOR = candidate;
                break;
            }
        }
    }

    return maxXOR;
}
```


## **Finding the maximum XOR of any two numbers in an array** — all in O(32·n) time, with zero extra data structures beyond a set.

This is a *bit-by-bit greedy construction algorithm*, and it’s absolutely worth understanding in depth because it builds XOR intuitively from the **most significant bit (MSB)** downward.

---

## 🧩 Problem Statement

Given an array `nums`,
find two numbers `a` and `b` such that their XOR (`a ^ b`) is **maximum** among all pairs.

Return that maximum XOR value.

**Example:**

```cpp
Input:  [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: 5 ^ 25 = 28
```

---

## 🧠 Intuition: Build XOR Bit-by-Bit

Instead of comparing all pairs (O(n²)),
we can **construct the maximum XOR one bit at a time** — from the **MSB (bit 31)** to the **LSB (bit 0)**.

At each bit position `i`, we ask:

> “Can we set this bit to 1 in the final XOR result?”

We tentatively try to make this bit `1`, and then *verify if it’s possible* using prefixes of numbers seen so far (masked up to bit `i`).

---

## ⚙️ Step-by-Step Breakdown

```cpp
int findMaximumXOR(vector<int>& nums) {
    int maxXOR = 0, mask = 0;

    for (int i = 31; i >= 0; i--) {
        mask |= (1 << i);          // 1️⃣ Include the current bit in the mask
        set<int> prefixes;

        for (int num : nums) {
            prefixes.insert(num & mask);  // 2️⃣ Store prefixes (nums truncated to current bits)
        }

        int candidate = maxXOR | (1 << i);  // 3️⃣ Try to set this bit to 1

        for (int prefix : prefixes) {
            // 4️⃣ If there exist two prefixes that can achieve this XOR candidate
            if (prefixes.count(candidate ^ prefix)) {
                maxXOR = candidate;  // ✅ It's possible! Keep this bit set.
                break;
            }
        }
    }

    return maxXOR;
}
```

---

## 🧩 Let’s Walk Through It

Take input:

```
nums = [3, 10, 5, 25, 2, 8]
```

### Step 0 – Initialization

```
maxXOR = 0
mask = 0
```

We’ll process bits from **31 → 0**, progressively revealing more of the numbers.

---

### 🧠 Step 1 – Understanding the Mask

At each iteration:

```cpp
mask |= (1 << i);
```

If `i = 31`, mask = `1000...0`
If `i = 30`, mask = `1100...0`, and so on.

Essentially, we’re *keeping only the leftmost (higher) bits* of each number to test prefixes.

---

### 🧩 Step 2 – Building Prefixes

For each number `num`,
we insert `(num & mask)` into `prefixes`.

Example (simplified to 5 bits for clarity):

| num | binary | mask (11100) | num & mask | prefix |
| --- | ------ | ------------ | ---------- | ------ |
| 3   | 00011  | 11100        | 00000      | 0      |
| 10  | 01010  | 11100        | 01000      | 8      |
| 5   | 00101  | 11100        | 00100      | 4      |
| 25  | 11001  | 11100        | 11000      | 24     |
| 2   | 00010  | 11100        | 00000      | 0      |
| 8   | 01000  | 11100        | 01000      | 8      |

So `prefixes = {0, 4, 8, 24}` at this step.

These represent the **higher bits** of all numbers so far.

---

### 🧠 Step 3 – Try to Set Current Bit in maxXOR

We now **tentatively** assume:

> Maybe this bit can be 1.

```cpp
int candidate = maxXOR | (1 << i);
```

Example:
If `maxXOR = 20` (10100) and we’re checking bit `2`,
then `candidate = 10100 | 00100 = 10100` (still 20, or 28 if bit wasn’t set before).

---

### 🧩 Step 4 – Check If It’s Possible

Here’s the magic:

```cpp
if (prefixes.count(candidate ^ prefix))
```

If for any prefix `p1`, there exists another prefix `p2` such that:

```
p1 ^ p2 == candidate
```

then it means two numbers in the array can yield that XOR at this bit level.

**Reasoning:**
If `p1 ^ p2 = candidate`,
then there exist two numbers whose prefixes produce the desired high bits of the XOR.

Thus, it’s possible to have a `1` at this bit position in the final XOR.

If yes → update `maxXOR = candidate`.

If no → keep the bit as 0.

---

## 🔍 Example Visualization (Simplified 5-bit version)

### Iteration by bit (MSB → LSB)

| Bit | mask  | candidate | Is possible? | maxXOR     |
| --- | ----- | --------- | ------------ | ---------- |
| 4   | 10000 | 10000     | ✅ yes        | 10000 (16) |
| 3   | 11000 | 11000     | ✅ yes        | 11000 (24) |
| 2   | 11100 | 11100     | ✅ yes        | 11100 (28) |
| 1   | 11110 | 11110     | ❌ no         | 11100 (28) |
| 0   | 11111 | 11101     | ❌ no         | 11100 (28) |

✅ Final answer = `11100` (binary) = **28**.

---

## ⚡ Complexity

| Metric | Value                   |
| ------ | ----------------------- |
| Time   | O(32 × n) ≈ O(n)        |
| Space  | O(n) (for prefixes set) |

---

## 🧭 Intuitive Summary

Think of it like **bitwise progressive guessing**:

1. Start from the top bit.
2. Tentatively set it to 1.
3. Check if any two numbers can achieve that XOR given their current prefixes.
4. If yes → lock in that bit.
5. Repeat for the next lower bit.

At the end, you’ve *greedily built the largest possible XOR value*.

---

## 🧩 Bonus: Visualization Analogy

Imagine each number as a “path” in a binary trie.
This algorithm essentially *builds the trie in your mind without explicitly creating it*,
and tests whether two paths can diverge at the current bit to make the XOR higher.

It’s a **space-optimized trie-based XOR search**.

---

## ✅ TL;DR

| Step | What It Does               | Why It Works               |
| ---- | -------------------------- | -------------------------- |
| 1️⃣  | Build mask bit-by-bit      | Keeps leftmost bits        |
| 2️⃣  | Record prefixes            | Capture possible high bits |
| 3️⃣  | Try setting new bit in XOR | Greedy choice              |
| 4️⃣  | Verify existence using set | Ensures achievable XOR     |
| ✅    | Update `maxXOR`            | Lock in confirmed bit      |

Final `maxXOR` = **maximum XOR of any two numbers in nums** 🎯

---

### **Problem 5: Subset Generation**

```cpp
void generateSubsets(vector<int>& nums) {
    int n = nums.size();
    int totalSubsets = 1 << n;  // 2^n

    for (int mask = 0; mask < totalSubsets; mask++) {
        vector<int> subset;
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                subset.push_back(nums[i]);
            }
        }
        // Process subset
    }
}
```

### **Problem 6: Number of 1 Bits (Hamming Weight)**

```cpp
int hammingWeight(uint32_t n) {
    int count = 0;
    while (n) {
        n &= (n - 1);  // Turn off rightmost 1
        count++;
    }
    return count;
}
```

### **Problem 7: Reverse Bits**

```cpp
uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    for (int i = 0; i < 32; i++) {
        result <<= 1;           // Make space for next bit
        result |= (n & 1);      // Add rightmost bit of n
        n >>= 1;                // Move to next bit
    }
    return result;
}
```

### **Problem 8: Power of Two**

```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

### **Problem 9: Power of Four**

```cpp
bool isPowerOfFour(int n) {
    // Must be power of 2 AND set bit must be at even position
    return n > 0 &&
           (n & (n - 1)) == 0 &&
           (n & 0x55555555) != 0;  // 0x55555555 = 01010101...
}
```

### **Problem 10: Missing Number**

```cpp
int missingNumber(vector<int>& nums) {
    int result = nums.size();
    for (int i = 0; i < nums.size(); i++) {
        result ^= i ^ nums[i];
    }
    return result;
}

// All numbers cancel except the missing one!
```

---

## **Part 5: Bit Manipulation Tricks Cheat Sheet**

```cpp
// Check if k-th bit is set
bool isSet = (n & (1 << k)) != 0;

// Set k-th bit
n |= (1 << k);

// Clear k-th bit
n &= ~(1 << k);

// Toggle k-th bit
n ^= (1 << k);

// Turn off rightmost 1
n &= (n - 1);

// Isolate rightmost 1
rightmost = n & -n;

// Check if power of 2
isPow2 = (n > 0) && ((n & (n - 1)) == 0);

// Get rightmost k bits
mask = (1 << k) - 1;
result = n & mask;

// Swap two numbers
a ^= b; b ^= a; a ^= b;

// Get absolute value (for negative numbers in two's complement)
abs = (n ^ (n >> 31)) - (n >> 31);

// Check if same sign
sameSign = (a ^ b) >= 0;

// Multiply by 2^k
n << k;

// Divide by 2^k
n >> k;

// Modulo 2^k
n & ((1 << k) - 1);

// Check if n is divisible by 2^k
(n & ((1 << k) - 1)) == 0;
```

---

## **Summary: When to Use Each Operator**

| Operator | Primary Use Cases                                    |
| -------- | ---------------------------------------------------- |
| **&**    | Check bits, clear bits, masks, even/odd check        |
| **\|**   | Set bits, combine flags, union operations            |
| **^**    | Toggle bits, find unique elements, swap without temp |
| **~**    | Create complement masks, flip all bits               |
| **<<**   | Multiply by 2^k, create powers of 2, generate masks  |
| **>>**   | Divide by 2^k, extract bits, shift processing        |

**Key Principle:** Bitwise operations are O(1) and incredibly fast—use them whenever you can to optimize your code!
